function codepoint_to_utf8(codepoints,err) result(string)
!
! converting Unicode code points to UTF-8
! internally without using I/O directly requires manual implementation of
! the UTF-8 encoding rules because there's no direct intrinsic function
! for this conversion.
!
!    UTF-8 is a variable-width encoding that uses 1 to 4 bytes to represent
!    Unicode characters.
!
!    The number of bytes depends on the value of the Unicode code point:
!        0x0000  - 0x007F (ASCII): 1 byte (0xxxxxxx).
!        0x0080  - 0x07FF: 2 bytes (110xxxxx 10xxxxxx).
!        0x0800  - 0xFFFF (Basic Multilingual Plane): 3 bytes (1110xxxx 10xxxxxx 10xxxxxx).
!        0x10000 - 0x10FFFF (Supplementary Planes): 4 bytes (11110xxx 10xxxxxx 10xxxxxx 10xxxxxx).
!
!    Continuation bytes in multi-byte sequences always start with the
!    bit pattern 10xxxxxx.
!
! Conversion Algorithm (Conceptual Example)
!
! Iterate through the 4-byte codepoint integers, each of which identifies a unicode glyph.
! Apply the UTF-8 encoding rules based on the code point's value to
! build a new byte array or a character string with character(len=1) elements, representing the
! UTF-8 sequence.
!
! The Unicode standard doesn't require a BOM for UTF-8, but it may be
! encountered at the start of files. This internal conversion doesn't
! add a BOM.
!
! This procedure does not explicitly handle surrogate pairs, which are
! used in UTF-16 to represent characters outside the Basic Multilingual
! Plane. Since UCS-4 already directly represents code points, surrogates
! are not a direct concern for UCS-4 to UTF-8 conversion, but it's
! good to be aware of them when dealing with other Unicode encodings.
!
use iso_fortran_env, only: error_unit

integer,intent(in)                      :: code_points(:)
integer, intent(out),optional           :: err
character(len=:,kind=ascii),allocatable :: string

! utf8_bytes stores the resulting UTF-8 byte sequence. It's declared
! with kind=ascii and a length determined by the maximum possible
! bytes for the UCS-4 string length (each UCS-4 character can be up
! to 4 bytes in UTF-8).
character(len=len(ucs4_string)*4)       :: utf8_bytes ! Max 4 bytes per UCS-4 char

integer                                 :: i, j, code_point
integer                                 :: num_bytes, utf8_index
integer, dimension(4)                   :: utf8_code

  utf8_index = 1
  if(present(err)) err = 0

  do i = 1, size(code_points)   ! iterate through each UCS-4 character.

    code_point = code_points(i) ! Get the integer value of the UCS-4 char

    ! The if/elseif statements check the code point value and determine
    ! the number of bytes required for UTF-8 encoding.
    !
    ! Bitwise operations (ior, ishft, iand) are used to construct the
    ! individual UTF-8 bytes according to the standard rules.
    !
    if (code_point < int(z'80') ) then  ! 1-byte UTF-8 (ASCII)
      num_bytes = 1
      utf8_code(1) = code_point
    else if (code_point < int(z'800') ) then ! 2-byte UTF-8
      num_bytes = 2
      utf8_code(1) = ior(z'C0', ishft(code_point, -6))
      utf8_code(2) = ior(z'80', iand(code_point, z'3F'))
    else if (code_point < int(z'10000') ) then ! 3-byte UTF-8
      num_bytes = 3
      utf8_code(1) = ior(z'E0', ishft(code_point, -12))
      utf8_code(2) = ior(z'80', iand(ishft(code_point, -6), z'3F'))
      utf8_code(3) = ior(z'80', iand(code_point, z'3F'))
    else if (code_point < int(z'110000') ) then ! 4-byte UTF-8
      num_bytes = 4
      utf8_code(1) = ior(z'F0', ishft(code_point, -18))
      utf8_code(2) = ior(z'80', iand(ishft(code_point, -12), z'3F'))
      utf8_code(3) = ior(z'80', iand(ishft(code_point, -6), z'3F'))
      utf8_code(4) = ior(z'80', iand(code_point, z'3F'))
    else
      ! Handle invalid code points or error conditions as needed
      write(error_unit,*) "Error: Invalid Unicode code point:", code_point
      if(.not.present(err))stop 1
      err=err+1
      cycle
    endif

    ! Append the UTF-8 bytes to the utf8_bytes string
    do j = 1, num_bytes
      ! The utf8_bytes string is built byte by byte using char with kind=ascii.
      utf8_bytes(utf8_index:utf8_index) = char(utf8_code(j), kind=ascii)
      utf8_index = utf8_index + 1
    enddo
  enddo

  string=trim(utf8_bytes(1:utf8_index-1)) ! the UTF-8 byte sequence

end function codepoint_to_utf8
