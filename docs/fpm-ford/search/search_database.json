var tipuesearch = {"pages":[{"title":" M_time ","text":"M_time M_utf8 A WIP (Work In Progress) Fortran does not inherently provide a direct built-in function to\nconvert an arbitrary UTF-8 encoded string to UCS-4 (ISO_10646) character\nkind. While Fortran 2003 and later standards introduce support for\ndifferent character kinds, including ISO_10646 (UCS-4), the conversion\nfrom a byte-stream representing UTF-8 to the UCS-4 character kind typically\nrequires manual decoding accept when reading and writing from a file with\nencoding set to “UTF-8”. Herein are some experiments in helping to facilitate using source codes\ncontaining UTF-8 encoded strings as standard Fortran Unicode characters\ninstead of as ASCII byte streams that contain UTF-8 constant strings, such\nas the procedures M_utf8 module utf8_to_codepoints, codepoints_to_utf8 utf8_to_ucs4, ucs4_to_utf8 utf8_to_ucs4_via_io, ucs4_to_utf8_via_io ascii_to_ucs4, ucs4_to_ascii isolatin_to_unicode, unicode_to_isolatin utf8_to_isolatin, isolatin_to_utf8 isolatin_to_utf32, utf32_to_isolatin Initially based on a discussion begun in\nhttps://fortran-lang.discourse.group/t/how-to-use-utf-8-in-gfortran/9949, 2025-08;\nincluding features and enhancements from Francois Jacq. The improvements include procedures for handling ASCII encoding extensions\noften used for internationalization that pre-date Unicode, such as the\nLatin encoudings. Purpose Fortran optionally supports internal representation of Unicode using\n4-byte-per-character UCS-4 encoding for characters/glyphs quite well,\nincluding an option to automatically encode and decode data read and\nwritten to UTF-8 files. Where the issues start is that the standard\nspecifies default character kinds for the OPEN FILE= specifier, filenames\non INQUIRE, strings returned by GET_COMMAND_ARGUMENT, … . So you can\nnot just forget about ASCII quite yet.  And some systems might use other\nencodings like UTF-16, so basically Fortran still needs procedures or\nmethods for converting between UCS-4, UTF-16, UTF-8, and possibly other\nencodings before you can just use Unicode everywhere in Fortran and forget\nabout ASCII or other encodings. The intent is for the information to useful for all Fortran processing, but currently\nis primarily tested with gfortran on Linux and Cygwin. program testit use iso_fortran_env , only : stdout => output_unit use M_utf8 , only : utf8_to_ucs4 implicit none integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = :, kind = ucs4 ), allocatable :: str open ( stdout , encoding = 'UTF-8' ) ! standard method str = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) write ( stdout , * ) str ! converting pseudo-utf8 to ucs4 str = utf8_to_ucs4 ( 'Hello World and Ni Hao -- 你好' ) write ( stdout , * ) str write ( stdout , * ) len ( str ) write ( stdout , * ) str ( 27 : 27 ) end program testit Tutorial There apparently is currently a dearth of documentation about using\nUnicode from Fortran, so as this project progresses a companion tutorial\nis being produced as well that first describes the general challenges of\nusing Unicode from Fortran when supported; and then using it from utf-8 files\nusing Unicode when not supported. Unicode Tutorial See Also https://fortran-lang.discourse.group/t/how-to-use-utf-8-in-gfortran/9949 https://fortran-lang.discourse.group/t/how-do-i-file-read-french-special-characters-like-e-etc/6618 https://fortran-lang.discourse.group/t/using-unicode-characters-in-fortran/2764 Other languages, such as the Python encode() and decode() procedures, supply related functionality. Developer Info John S. Urban","tags":"home","url":"index.html"},{"title":"unicode_type – M_time ","text":"type, public :: unicode_type Constructor public        interface unicode_type private module function new_codes(codes) result(new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: codes (:) Return Value type( unicode_type ) private elemental module function new_str(string) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( unicode_type ) Type-Bound Procedures procedure, public :: adjustl => oop_adjustl private  function oop_adjustl(self) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value type( unicode_type ) procedure, public :: adjustr => oop_adjustr private  function oop_adjustr(self) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value type( unicode_type ) procedure, public :: bytes => oop_bytes private pure function oop_bytes(self) result(bytes_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value character(len=:), allocatable, (:) procedure, public :: character => oop_character private  function oop_character(self, first, last, step) result(bytes_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: step Return Value character(len=:), allocatable procedure, public :: index => oop_index private impure function oop_index(self, substring) result(index_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self class(*), intent(in) :: substring Return Value integer procedure, public :: len => oop_len private pure function oop_len(self) result(len_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value integer procedure, public :: len_trim => oop_len_trim private pure function oop_len_trim(self) result(len_trim_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value integer procedure, public :: trim => oop_trim private pure function oop_trim(self) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value type( unicode_type ) Source Code type :: unicode_type ! Unicode string type holding an arbitrary sequence of integer codes. !sequence ! not used for storage association; a kludge to prevent extending this type. private integer , allocatable :: codes (:) contains ! METHODS: procedure :: character => oop_character procedure :: bytes => oop_bytes procedure :: adjustl => oop_adjustl procedure :: adjustr => oop_adjustr procedure :: trim => oop_trim procedure :: len => oop_len procedure :: len_trim => oop_len_trim procedure :: index => oop_index !DECLARATION OF OVERLOADED OPERATORS FOR TYPE(UNICODE_TYPE) procedure , private :: eq => oop_eq !   generic           :: operator(==) => eq !   procedure,private :: ge => oop_ge !   generic           :: operator(>=) => oop_ge !   procedure,private :: lt => oop_lt !   generic           :: operator(<)  => oop_lt !   procedure,private :: gt => oop_gt !   generic           :: operator(>)  => oop_gt !   procedure,private :: le => oop_le !   generic           :: operator(<=) => oop_le !   procedure,private :: ne => oop_ne !   generic           :: operator(/=) => oop_ne !   procedure,private :: string_append_value !   generic           :: operator(//) => string_append_value end type unicode_type","tags":"","url":"type/unicode_type.html"},{"title":"ascii_to_ucs4 – M_time","text":"function ascii_to_ucs4(astr) result(ustr) Arguments Type Intent Optional Attributes Name character(kind=ascii, len=*), intent(in) :: astr Return Value character(kind=ucs4, len=len) Variables Type Visibility Attributes Name Initial integer, public :: i Source Code function ascii_to_ucs4 ( astr ) result ( ustr ) ! @(#) make the same conversion as an assignment statement from ASCII to UCS4 character ( len =* , kind = ascii ), intent ( in ) :: astr character ( len = len ( astr ), kind = ucs4 ) :: ustr integer :: i do i = 1 , len ( astr ) ustr ( i : i ) = achar ( iachar ( astr ( i : i )), kind = ucs4 ) enddo end function ascii_to_ucs4","tags":"","url":"proc/ascii_to_ucs4.html"},{"title":"ucs4_to_ascii – M_time","text":"function ucs4_to_ascii(ustr) result(astr) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ustr Return Value character(kind=ascii, len=len) Variables Type Visibility Attributes Name Initial integer, public :: i Source Code function ucs4_to_ascii ( ustr ) result ( astr ) ! @(#) make the same conversion as an assignment statement from UCS4 o ASCII character ( len =* , kind = ucs4 ), intent ( in ) :: ustr character ( len = len ( ustr ), kind = ascii ) :: astr integer :: i do i = 1 , len ( ustr ) astr ( i : i ) = achar ( iachar ( ustr ( i : i )), kind = ascii ) enddo end function ucs4_to_ascii","tags":"","url":"proc/ucs4_to_ascii.html"},{"title":"checkit – M_time","text":"subroutine checkit(label, test) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label logical, intent(in) :: test Source Code subroutine checkit ( label , test ) character ( len =* ), intent ( in ) :: label logical , intent ( in ) :: test write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label if (. not . test ) total = total + 1 end subroutine checkit","tags":"","url":"proc/checkit.html"},{"title":"utf8_to_utf32 – M_time","text":"function utf8_to_utf32(string) result(corrected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=ucs4, len=:), allocatable Variables Type Visibility Attributes Name Initial character(kind=ucs4, len=255), public :: line integer, public :: lun Source Code function utf8_to_utf32 ( string ) result ( corrected ) character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = 255 , kind = ucs4 ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) string rewind ( lun ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) open ( output_unit , encoding = 'UTF-8' ) end function utf8_to_utf32","tags":"","url":"proc/utf8_to_utf32.html"},{"title":"create_date_string – M_time","text":"subroutine create_date_string(string) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*) :: string Variables Type Visibility Attributes Name Initial character(kind=ucs4, len=1), public, parameter :: gatsu = char(int(z'6708'), ucs4) character(kind=ucs4, len=1), public, parameter :: nen = char(int(z'5e74'), ucs4) character(kind=ucs4, len=1), public, parameter :: nichi = char(int(z'65e5'), ucs4) integer, public, parameter :: ucs4 = selected_char_kind(\"ISO_10646\") integer, public :: values (8) Source Code subroutine create_date_string ( string ) intrinsic date_and_time , selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = 1 , kind = ucs4 ), parameter :: & nen = char ( int ( z '5e74' ), ucs4 ), & ! year gatsu = char ( int ( z '6708' ), ucs4 ), & ! month nichi = char ( int ( z '65e5' ), ucs4 ) ! day character ( len = * , kind = ucs4 ) string integer values ( 8 ) call date_and_time ( values = values ) write ( string , 101 ) values ( 1 ), nen , values ( 2 ), gatsu , values ( 3 ), nichi 101 format ( * ( i0 , a )) end subroutine create_date_string","tags":"","url":"proc/create_date_string.html"},{"title":"isolatin_to_unicode – M_time","text":"public pure subroutine isolatin_to_unicode(isolatin, unicode, nerr) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: isolatin (:) integer, intent(out), allocatable :: unicode (:) integer, intent(out) :: nerr Source Code pure subroutine isolatin_to_unicode ( isolatin , unicode , nerr ) character , intent ( in ) :: isolatin (:) integer , allocatable , intent ( out ) :: unicode (:) integer , intent ( out ) :: nerr integer :: i , n , char_code nerr = 0 n = size ( isolatin ) allocate ( unicode ( n )) do i = 1 , n char_code = ichar ( isolatin ( i )) ! Only 8 characters do not correspond to unicode select case ( char_code ) case ( 164 ); unicode ( i ) = 8364 ! Symbol Euro case ( 166 ); unicode ( i ) = 352 ! S caron case ( 168 ); unicode ( i ) = 353 ! s caron case ( 180 ); unicode ( i ) = 381 ! Z caron case ( 184 ); unicode ( i ) = 382 ! z caron case ( 188 ); unicode ( i ) = 338 ! OE majuscule case ( 189 ); unicode ( i ) = 339 ! oe minuscule case ( 190 ); unicode ( i ) = 376 ! Y trema case default unicode ( i ) = char_code end select enddo end subroutine isolatin_to_unicode","tags":"","url":"proc/isolatin_to_unicode.html"},{"title":"isolatin_to_utf8 – M_time","text":"public pure subroutine isolatin_to_utf8(isolatin, utf8, nerr) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: isolatin (:) character(len=1), intent(out), allocatable :: utf8 (:) integer, intent(out) :: nerr Source Code pure subroutine isolatin_to_utf8 ( isolatin , utf8 , nerr ) character , intent ( in ) :: isolatin (:) character , allocatable , intent ( out ) :: utf8 (:) integer , intent ( out ) :: nerr integer , allocatable :: unicode (:) call isolatin_to_unicode ( isolatin , unicode , nerr ) call codepoints_to_utf8 ( unicode , utf8 , nerr ) end subroutine isolatin_to_utf8","tags":"","url":"proc/isolatin_to_utf8.html"},{"title":"unicode_to_isolatin – M_time","text":"public pure subroutine unicode_to_isolatin(unicode, isolatin, nerr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unicode (:) character(len=1), intent(out), allocatable :: isolatin (:) integer, intent(out) :: nerr Source Code pure subroutine unicode_to_isolatin ( unicode , isolatin , nerr ) integer , intent ( in ) :: unicode (:) character , allocatable , intent ( out ) :: isolatin (:) integer , intent ( out ) :: nerr integer :: i , n , cp integer :: replacement_count nerr = 0 n = size ( unicode ) allocate ( isolatin ( n )) do i = 1 , n cp = unicode ( i ) select case ( cp ) ! 8 special characters case ( 8364 ); isolatin ( i ) = char ( 164 ) ! Euro case ( 352 ); isolatin ( i ) = char ( 166 ) ! S caron case ( 353 ); isolatin ( i ) = char ( 168 ) ! s caron case ( 381 ); isolatin ( i ) = char ( 180 ) ! Z caron case ( 382 ); isolatin ( i ) = char ( 184 ) ! z caron case ( 338 ); isolatin ( i ) = char ( 188 ) ! OE majuscule case ( 339 ); isolatin ( i ) = char ( 189 ) ! oe minuscule case ( 376 ); isolatin ( i ) = char ( 190 ) ! Y trema case ( 0 : 163 , 165 , 167 , 169 : 179 , 181 : 183 , 185 : 187 , 191 : 255 ) isolatin ( i ) = char ( cp ) case default nerr = nerr + 1 isolatin ( i ) = '?' ! replacement character end select enddo end subroutine unicode_to_isolatin","tags":"","url":"proc/unicode_to_isolatin.html"},{"title":"utf8_to_isolatin – M_time","text":"public pure subroutine utf8_to_isolatin(utf8, isolatin, nerr) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: utf8 (:) character(len=1), intent(out), allocatable :: isolatin (:) integer, intent(out) :: nerr Source Code pure subroutine utf8_to_isolatin ( utf8 , isolatin , nerr ) character , intent ( in ) :: utf8 (:) character , allocatable , intent ( out ) :: isolatin (:) integer , intent ( out ) :: nerr integer , allocatable :: unicode (:) call utf8_to_codepoints ( utf8 , unicode , nerr ) call unicode_to_isolatin ( unicode , isolatin , nerr ) end subroutine utf8_to_isolatin","tags":"","url":"proc/utf8_to_isolatin.html"},{"title":"adjustl – M_time","text":"public interface adjustl Module Procedures private elemental function adjustl_str(string) result(adjusted) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type )","tags":"","url":"interface/adjustl.html"},{"title":"adjustr – M_time","text":"public interface adjustr Module Procedures private elemental function adjustr_str(string) result(adjusted) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type )","tags":"","url":"interface/adjustr.html"},{"title":"assignment(=) – M_time","text":"public interface assignment(=) Module Procedures private elemental subroutine assign_str_char(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs private  subroutine assign_str_codes(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs integer, intent(in) :: rhs (:)","tags":"","url":"interface/assignment(=).html"},{"title":"character – M_time","text":"public interface character Module Procedures private pure function char_str(string) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value character(len=:), allocatable private pure function char_str_range(string, first, last) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: first integer, intent(in) :: last Return Value character(len=:), allocatable private pure function char_str_range_step(string, first, last, step) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: first integer, intent(in) :: last integer, intent(in) :: step Return Value character(len=:), allocatable","tags":"","url":"interface/character.html"},{"title":"codepoints_to_utf8 – M_time","text":"public interface codepoints_to_utf8 Module Procedures private pure subroutine codepoints_to_utf8_str(unicode, utf8, nerr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unicode (:) character(len=:), intent(out), allocatable :: utf8 integer, intent(out) :: nerr private pure subroutine codepoints_to_utf8_chars(unicode, utf8, nerr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unicode (:) character(len=1), intent(out), allocatable :: utf8 (:) integer, intent(out) :: nerr","tags":"","url":"interface/codepoints_to_utf8.html"},{"title":"index – M_time","text":"public interface index Module Procedures private elemental function index_str_str(string, substring) result(foundat) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: substring Return Value integer private elemental function index_str_char(string, substring) result(foundat) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value integer private elemental function index_char_str(string, substring) result(foundat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( unicode_type ), intent(in) :: substring Return Value integer","tags":"","url":"interface/index.html"},{"title":"len – M_time","text":"public interface len Module Procedures private elemental function len_str(string) result(length) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer","tags":"","url":"interface/len.html"},{"title":"len_trim – M_time","text":"public interface len_trim Module Procedures private elemental function len_trim_str(string) result(length) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer","tags":"","url":"interface/len_trim.html"},{"title":"leq – M_time","text":"public interface leq Module Procedures private elemental function leq_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function leq_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function leq_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/leq.html"},{"title":"lge – M_time","text":"public interface lge Module Procedures private elemental function lge_str_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lge_str_char(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lge.html"},{"title":"lgt – M_time","text":"public interface lgt Module Procedures private elemental function lgt_str_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lgt_str_char(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lgt.html"},{"title":"lle – M_time","text":"public interface lle Module Procedures private elemental function lle_str_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lle_str_char(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lle.html"},{"title":"llt – M_time","text":"public interface llt Module Procedures private elemental function llt_str_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function llt_str_char(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/llt.html"},{"title":"lne – M_time","text":"public interface lne Module Procedures private elemental function lne_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lne_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lne_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lne.html"},{"title":"operator(//) – M_time","text":"public interface operator(//) Module Procedures private elemental function concat_str_str(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value type( unicode_type ) private elemental function concat_str_char(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value type( unicode_type ) private elemental function concat_char_str(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value type( unicode_type )","tags":"","url":"interface/operator(SLASHSLASH).html"},{"title":"operator(/=) – M_time","text":"public interface operator(/=) Module Procedures private elemental function lne_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lne_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lne_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(SLASH=).html"},{"title":"operator(<) – M_time","text":"public interface operator(<) Module Procedures private elemental function llt_str_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function llt_str_char(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(lt).html"},{"title":"operator(<=) – M_time","text":"public interface operator(<=) Module Procedures private elemental function lle_str_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lle_str_char(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(lt=).html"},{"title":"operator(==) – M_time","text":"public interface operator(==) Module Procedures private elemental function leq_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function leq_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function leq_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(==).html"},{"title":"operator(>) – M_time","text":"public interface operator(>) Module Procedures private elemental function lgt_str_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lgt_str_char(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(gt).html"},{"title":"operator(>=) – M_time","text":"public interface operator(>=) Module Procedures private elemental function lge_str_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lge_str_char(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(gt=).html"},{"title":"repeat – M_time","text":"public interface repeat Module Procedures private elemental function repeat_str(string, ncopies) result(repeated_str) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( unicode_type )","tags":"","url":"interface/repeat.html"},{"title":"trim – M_time","text":"public interface trim Module Procedures private elemental function trim_str(string) result(trimmed_str) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type )","tags":"","url":"interface/trim.html"},{"title":"unicode_type – M_time","text":"public interface unicode_type Functions private module function new_codes(codes) result(new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: codes (:) Return Value type( unicode_type ) private elemental module function new_str(string) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( unicode_type )","tags":"","url":"interface/unicode_type.html"},{"title":"utf8_to_codepoints – M_time","text":"public interface utf8_to_codepoints Module Procedures private pure subroutine utf8_to_codepoints_str(utf8, unicode, nerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: utf8 integer, intent(out), allocatable :: unicode (:) integer, intent(out) :: nerr private pure subroutine utf8_to_codepoints_chars(utf8, unicode, nerr) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: utf8 (:) integer, intent(out), allocatable :: unicode (:) integer, intent(out) :: nerr","tags":"","url":"interface/utf8_to_codepoints.html"},{"title":"ascii_to_ucs4 – M_time","text":"public  function ascii_to_ucs4(astr) result(ustr) Arguments Type Intent Optional Attributes Name character(kind=ascii, len=*), intent(in) :: astr Return Value character(kind=ucs4, len=len) Source Code function ascii_to_ucs4 ( astr ) result ( ustr ) ! @(#) make the same conversion as an assignment statement from ASCII to UCS4 character ( len =* , kind = ascii ), intent ( in ) :: astr character ( len = len ( astr ), kind = ucs4 ) :: ustr integer :: i do i = 1 , len ( astr ) ustr ( i : i ) = achar ( iachar ( astr ( i : i )), kind = ucs4 ) enddo end function ascii_to_ucs4","tags":"","url":"proc/ascii_to_ucs4~2.html"},{"title":"extended_ascii_to_ucs4 – M_time","text":"public  function extended_ascii_to_ucs4(astr) result(ustr) Arguments Type Intent Optional Attributes Name character(kind=default, len=*), intent(in) :: astr Return Value character(kind=ucs4, len=len) Source Code function extended_ascii_to_ucs4 ( astr ) result ( ustr ) ! @(#) make the conversion extended_ascii to UCS4 character ( len =* , kind = default ), intent ( in ) :: astr character ( len = len ( astr ), kind = ucs4 ) :: ustr integer :: i do i = 1 , len ( astr ) ustr ( i : i ) = char ( ichar ( astr ( i : i )), kind = ucs4 ) enddo end function extended_ascii_to_ucs4","tags":"","url":"proc/extended_ascii_to_ucs4.html"},{"title":"ucs4_to_ascii – M_time","text":"public  function ucs4_to_ascii(ustr) result(astr) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ustr Return Value character(kind=ascii, len=len) Source Code function ucs4_to_ascii ( ustr ) result ( astr ) ! @(#) make the same conversion as an assignment statement from UCS4 to ASCII character ( len =* , kind = ucs4 ), intent ( in ) :: ustr character ( len = len ( ustr ), kind = ascii ) :: astr integer :: i do i = 1 , len ( ustr ) astr ( i : i ) = achar ( iachar ( ustr ( i : i )), kind = ascii ) enddo end function ucs4_to_ascii","tags":"","url":"proc/ucs4_to_ascii~2.html"},{"title":"ucs4_to_extended_ascii – M_time","text":"public  function ucs4_to_extended_ascii(ustr) result(astr) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ustr Return Value character(kind=default, len=len) Source Code function ucs4_to_extended_ascii ( ustr ) result ( astr ) ! @(#) make the conversion from UCS4 to extended_ascii character ( len =* , kind = ucs4 ), intent ( in ) :: ustr character ( len = len ( ustr ), kind = default ) :: astr integer :: i do i = 1 , len ( ustr ) astr ( i : i ) = char ( ichar ( ustr ( i : i )), kind = default ) enddo end function ucs4_to_extended_ascii","tags":"","url":"proc/ucs4_to_extended_ascii.html"},{"title":"ucs4_to_utf8 – M_time","text":"public  function ucs4_to_utf8(ucs4_string, err) result(string) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ucs4_string integer, intent(out), optional :: err Return Value character(len=:), allocatable Source Code function ucs4_to_utf8 ( ucs4_string , err ) result ( string ) ! return bytes representing utf8 glyphs from a string of kind ucs4 character ( len =* , kind = ucs4 ), intent ( in ) :: ucs4_string ! stores the UCS-4 string. integer , intent ( out ), optional :: err character ( len = :), allocatable :: string integer :: codepoints ( len ( ucs4_string )) integer :: i integer :: nerr codepoints = [( ichar ( ucs4_string ( i : i )), i = 1 , len ( ucs4_string ))] call codepoints_to_utf8 ( codepoints , string , nerr ) if ( present ( err )) then err = nerr elseif ( nerr . ne . 0 ) then stop '<ERROR>*ucs4_to_utf8*' endif end function ucs4_to_utf8","tags":"","url":"proc/ucs4_to_utf8.html"},{"title":"ucs4_to_utf8_via_io – M_time","text":"public  function ucs4_to_utf8_via_io(ucs4_string) result(corrected) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ucs4_string Return Value character(kind=ascii, len=:), allocatable Source Code function ucs4_to_utf8_via_io ( ucs4_string ) result ( corrected ) character ( len =* , kind = ucs4 ), intent ( in ) :: ucs4_string character ( len = :, kind = ascii ), allocatable :: corrected character ( len = ( len ( ucs4_string ) * 4 ), kind = ascii ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) ucs4_string rewind ( lun ) open ( unit = lun , encoding = 'default' ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function ucs4_to_utf8_via_io","tags":"","url":"proc/ucs4_to_utf8_via_io.html"},{"title":"utf8_to_ucs4 – M_time","text":"public  function utf8_to_ucs4(string) result(corrected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=ucs4, len=:), allocatable Source Code function utf8_to_ucs4 ( string ) result ( corrected ) ! return a string of kind ucs4 from bytes representing utf8 glyphs character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected integer , allocatable :: codepoints (:) integer :: i , n integer :: err call utf8_to_codepoints ( string , codepoints , err ) n = size ( codepoints ) allocate ( character ( len = n , kind = ucs4 ) :: corrected ) if (. not . allocated ( codepoints )) then corrected = '' return endif do i = 1 , n corrected ( i : i ) = char ( codepoints ( i ), kind = ucs4 ) enddo end function utf8_to_ucs4","tags":"","url":"proc/utf8_to_ucs4.html"},{"title":"utf8_to_ucs4_via_io – M_time","text":"public  function utf8_to_ucs4_via_io(string) result(corrected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=ucs4, len=:), allocatable Source Code function utf8_to_ucs4_via_io ( string ) result ( corrected ) character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = ( len ( string )), kind = ucs4 ) :: line character ( len = 255 ) :: iomsg integer :: i integer :: lun integer :: iostat open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) do i = 1 , len ( string ) write ( lun , '(A)' , iostat = iostat , iomsg = iomsg , advance = 'no' ) string ( i : i ) if ( iostat . ne . 0 ) then ! not definite: after an error the position may be undefined write ( lun , '(A)' , iostat = iostat , iomsg = iomsg , advance = 'no' ) '?' write ( stderr , '(A)' ) trim ( iomsg ) endif enddo write ( lun , '(A)' , advance = 'yes' ) rewind ( lun ) read ( lun , '(A)' , iostat = iostat ) line close ( lun ) corrected = trim ( line ) end function utf8_to_ucs4_via_io","tags":"","url":"proc/utf8_to_ucs4_via_io.html"},{"title":"check – M_time","text":"subroutine check(label, test) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label logical, intent(in) :: test Source Code subroutine check ( label , test ) character ( len =* ), intent ( in ) :: label logical , intent ( in ) :: test write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label if (. not . test ) total = total + 1 end subroutine check","tags":"","url":"proc/check.html"},{"title":"checkit – M_time","text":"subroutine checkit(label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline character(len=*), intent(in) :: answer character(len=*), intent(in) :: expected Source Code subroutine checkit ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer character ( len =* ), intent ( in ) :: expected write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , answer . eq . expected ), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( answer . ne . expected ) total = total + 1 end subroutine checkit","tags":"","url":"proc/checkit~2.html"},{"title":"checkits – M_time","text":"subroutine checkits(label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline character(len=*), intent(in) :: answer (:) character(len=*), intent(in) :: expected (:) Source Code subroutine checkits ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer (:) character ( len =* ), intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eq . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . ne . expected )) total = total + 1 end subroutine checkits","tags":"","url":"proc/checkits.html"},{"title":"checkits_l – M_time","text":"subroutine checkits_l(label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline logical, intent(in) :: answer (:) logical, intent(in) :: expected (:) Source Code subroutine checkits_l ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline logical , intent ( in ) :: answer (:) logical , intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eqv . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . neqv . expected )) total = total + 1 end subroutine checkits_l","tags":"","url":"proc/checkits_l.html"},{"title":"getargs – M_time","text":"function getargs() result(command_line) Arguments None Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial integer, public :: length Source Code function getargs () result ( command_line ) integer :: length character ( len = :), allocatable :: command_line call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = adjustl ( command_line ( length + 1 :)) end function getargs","tags":"","url":"proc/getargs.html"},{"title":"ucs4_to_utf8 – M_time","text":"function ucs4_to_utf8(ucs4_string) result(corrected) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ucs4_string Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial character(len=len=(len(ucs4_string)*4)), public :: line integer, public :: lun Source Code function ucs4_to_utf8 ( ucs4_string ) result ( corrected ) character ( len =* , kind = ucs4 ), intent ( in ) :: ucs4_string character ( len = :), allocatable :: corrected character ( len = ( len ( ucs4_string ) * 4 )) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) ucs4_string rewind ( lun ) open ( unit = lun , encoding = 'default' ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function ucs4_to_utf8","tags":"","url":"proc/ucs4_to_utf8~2.html"},{"title":"utf8_to_ucs4 – M_time","text":"function utf8_to_ucs4(string) result(corrected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=ucs4, len=:), allocatable Variables Type Visibility Attributes Name Initial character(kind=ucs4, len=len=(len(string))), public :: line integer, public :: lun Source Code function utf8_to_ucs4 ( string ) result ( corrected ) character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = ( len ( string )), kind = ucs4 ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) string rewind ( lun ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function utf8_to_ucs4","tags":"","url":"proc/utf8_to_ucs4~2.html"},{"title":"ucs4_to_utf8 – M_time","text":"function ucs4_to_utf8(ucs4_string) result(ascii_string) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ucs4_string Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial character(len=len=(len(ucs4_string)*4)), public :: line integer, public :: lun Source Code function ucs4_to_utf8 ( ucs4_string ) result ( ascii_string ) character ( len =* , kind = ucs4 ), intent ( in ) :: ucs4_string character ( len = :), allocatable :: ascii_string character ( len = ( len ( ucs4_string ) * 4 )) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) ucs4_string rewind ( lun ) open ( unit = lun , encoding = 'default' ) read ( lun , '(A)' ) line close ( lun ) ascii_string = trim ( line ) end function ucs4_to_utf8","tags":"","url":"proc/ucs4_to_utf8~3.html"},{"title":"M_unicode – M_time","text":"Uses iso_fortran_env Interfaces public        interface adjustl private elemental function adjustl_str(string) result(adjusted) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type ) public        interface adjustr private elemental function adjustr_str(string) result(adjusted) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type ) public        interface assignment(=) private elemental subroutine assign_str_char(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs private  subroutine assign_str_codes(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs integer, intent(in) :: rhs (:) public        interface character private pure function char_str(string) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value character(len=:), allocatable private pure function char_str_range(string, first, last) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: first integer, intent(in) :: last Return Value character(len=:), allocatable private pure function char_str_range_step(string, first, last, step) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: first integer, intent(in) :: last integer, intent(in) :: step Return Value character(len=:), allocatable public        interface codepoints_to_utf8 private pure subroutine codepoints_to_utf8_str(unicode, utf8, nerr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unicode (:) character(len=:), intent(out), allocatable :: utf8 integer, intent(out) :: nerr private pure subroutine codepoints_to_utf8_chars(unicode, utf8, nerr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unicode (:) character(len=1), intent(out), allocatable :: utf8 (:) integer, intent(out) :: nerr public        interface index private elemental function index_str_str(string, substring) result(foundat) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: substring Return Value integer private elemental function index_str_char(string, substring) result(foundat) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value integer private elemental function index_char_str(string, substring) result(foundat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( unicode_type ), intent(in) :: substring Return Value integer public        interface len private elemental function len_str(string) result(length) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer public        interface len_trim private elemental function len_trim_str(string) result(length) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer public        interface leq private elemental function leq_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function leq_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function leq_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface lge private elemental function lge_str_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lge_str_char(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface lgt private elemental function lgt_str_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lgt_str_char(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface lle private elemental function lle_str_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lle_str_char(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface llt private elemental function llt_str_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function llt_str_char(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface lne private elemental function lne_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lne_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lne_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(//) private elemental function concat_str_str(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value type( unicode_type ) private elemental function concat_str_char(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value type( unicode_type ) private elemental function concat_char_str(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value type( unicode_type ) public        interface operator(/=) private elemental function lne_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lne_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lne_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(<) private elemental function llt_str_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function llt_str_char(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(<=) private elemental function lle_str_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lle_str_char(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(==) private elemental function leq_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function leq_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function leq_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(>) private elemental function lgt_str_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lgt_str_char(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(>=) private elemental function lge_str_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lge_str_char(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface repeat private elemental function repeat_str(string, ncopies) result(repeated_str) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( unicode_type ) public        interface trim private elemental function trim_str(string) result(trimmed_str) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type ) public        interface unicode_type private module function new_codes(codes) result(new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: codes (:) Return Value type( unicode_type ) private elemental module function new_str(string) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( unicode_type ) public        interface utf8_to_codepoints private pure subroutine utf8_to_codepoints_str(utf8, unicode, nerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: utf8 integer, intent(out), allocatable :: unicode (:) integer, intent(out) :: nerr private pure subroutine utf8_to_codepoints_chars(utf8, unicode, nerr) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: utf8 (:) integer, intent(out), allocatable :: unicode (:) integer, intent(out) :: nerr Derived Types type, public :: unicode_type Constructor private\n\n                    module\n                    function new_codes (codes) private\n\n                    elemental, module\n                    function new_str (string) Type-Bound Procedures procedure, public :: adjustl => oop_adjustl procedure, public :: adjustr => oop_adjustr procedure, public :: bytes => oop_bytes procedure, public :: character => oop_character procedure, public :: index => oop_index procedure, public :: len => oop_len procedure, public :: len_trim => oop_len_trim procedure, public :: trim => oop_trim Subroutines public pure subroutine isolatin_to_unicode (isolatin, unicode, nerr) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: isolatin (:) integer, intent(out), allocatable :: unicode (:) integer, intent(out) :: nerr public pure subroutine isolatin_to_utf8 (isolatin, utf8, nerr) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: isolatin (:) character(len=1), intent(out), allocatable :: utf8 (:) integer, intent(out) :: nerr public pure subroutine unicode_to_isolatin (unicode, isolatin, nerr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unicode (:) character(len=1), intent(out), allocatable :: isolatin (:) integer, intent(out) :: nerr public pure subroutine utf8_to_isolatin (utf8, isolatin, nerr) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: utf8 (:) character(len=1), intent(out), allocatable :: isolatin (:) integer, intent(out) :: nerr","tags":"","url":"module/m_unicode.html"},{"title":"M_utf8 – M_time","text":"Uses iso_fortran_env M_unicode Functions public  function ascii_to_ucs4 (astr) result(ustr) Arguments Type Intent Optional Attributes Name character(kind=ascii, len=*), intent(in) :: astr Return Value character(kind=ucs4, len=len) public  function extended_ascii_to_ucs4 (astr) result(ustr) Arguments Type Intent Optional Attributes Name character(kind=default, len=*), intent(in) :: astr Return Value character(kind=ucs4, len=len) public  function ucs4_to_ascii (ustr) result(astr) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ustr Return Value character(kind=ascii, len=len) public  function ucs4_to_extended_ascii (ustr) result(astr) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ustr Return Value character(kind=default, len=len) public  function ucs4_to_utf8 (ucs4_string, err) result(string) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ucs4_string integer, intent(out), optional :: err Return Value character(len=:), allocatable public  function ucs4_to_utf8_via_io (ucs4_string) result(corrected) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ucs4_string Return Value character(kind=ascii, len=:), allocatable public  function utf8_to_ucs4 (string) result(corrected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=ucs4, len=:), allocatable public  function utf8_to_ucs4_via_io (string) result(corrected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=ucs4, len=:), allocatable","tags":"","url":"module/m_utf8.html"},{"title":"concatenate – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(len=:), allocatable :: a1 character(len=:), allocatable :: a2 character(len=:), allocatable :: aline integer, parameter :: ascii = selected_char_kind(\"ascii\") character(len=1), allocatable :: ch (:) character(len=1), allocatable :: ch2 (:) integer, parameter :: default = selected_char_kind(\"default\") character(len=*), parameter :: g = '(*(g0))' character(kind=ucs4, len=1), allocatable :: glyph (:) integer :: i integer :: iostat integer :: nerr character(len=1) :: paws character(kind=ucs4, len=1) :: smiley = char(int(z'1F603'), kind=ucs4) character(kind=ucs4, len=:), allocatable :: u1 character(kind=ucs4, len=:), allocatable :: u2 integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(kind=ucs4, len=:), allocatable :: uline Functions function ascii_to_ucs4 (astr) result(ustr) Arguments Type Intent Optional Attributes Name character(kind=ascii, len=*), intent(in) :: astr Return Value character(kind=ucs4, len=len) function ucs4_to_ascii (ustr) result(astr) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ustr Return Value character(kind=ascii, len=len) Source Code program concatenate use iso_fortran_env , only : stdout => output_unit , stdin => input_unit implicit none intrinsic selected_char_kind integer , parameter :: default = selected_char_kind ( \"default\" ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: g = '(*(g0))' character ( len = :), allocatable :: aline , a1 , a2 character ( len = :, kind = ucs4 ), allocatable :: uline , u1 , u2 character ( len = 1 ), allocatable :: ch (:), ch2 (:) character ( len = 1 , kind = ucs4 ), allocatable :: glyph (:) integer :: i integer :: iostat integer :: nerr character ( len = 1 ) :: paws character ( len = 1 , kind = ucs4 ) :: smiley = char ( int ( z '1F603' ), kind = ucs4 ) ! 😃 Smiling face with open mouth open ( stdout , encoding = 'DEFAULT' ) open ( stdout , encoding = 'UTF-8' ) ! ! Concatenation: ! write ( stdout , '(A)' ) repeat ( '=' , 80 ) write ( stdout , '(a)' ) 'strings of different kinds cannot be concatenated.' !uline='ascii string'// smiley // 'ascii string' ! NO. Kinds must match write ( stdout , '(a)' ) 'Of course constants can have their KIND specified.' uline = ucs4_ 'first UCS4 string' // smiley // ucs4_ 'another UCS4 string ' write ( stdout , '(A)' ) uline ! write ( stdout , '(A)' ) repeat ( '=' , 80 ) write ( stdout , '(a)' ) 'you can use simple assigns to do conversions' ! so if I have a UCS4 string u1 = smiley // ucs4_ 'UCS4 strings' // smiley // ucs4_ 'appended together' // smiley ! and an ASCII string a1 = 'ascii strings' // 'appended together' ! the ASCII string can be converted to UCS4 with an assign u2 = a1 ! use allocation to convert ASCII to UCS4 ! now with a copy of everthing as UCS4 the append will work uline = u1 // u2 ! now append together the two strings which are now of the same kind write ( stdout , '(a)' ) uline ! write ( stdout , '(A)' ) repeat ( '=' , 80 ) write ( stdout , '(a)' ) 'we can make functions to convert to and from ASCII and UCS4' ! using the same conversions as used by an assign. uline = smiley // ascii_to_ucs4 ( 'ascii string' ) // smiley // ucs4_ 'unicode string' // smiley write ( stdout , '(a)' ) uline ! write ( stdout , '(A)' ) 'unrepresentable characters:' write ( stdout , '(a)' ) 'what about characters that have no equivalent in the other kind?' write ( stdout , '(A)' ) 'conversion by assignment' aline = uline write ( stdout , g ) aline , ' ' , len ( aline ), ' ' , len ( uline ) write ( stdout , '(a)' ) 'conversion by ACHAR/ICHAR:' aline = ucs4_to_ascii ( uline ) ! is \"smiley\" replaced with a character used for errors? write ( stdout , g ) aline , ' ' , len ( aline ), ' ' , len ( uline ) write ( stdout , '(a)' ) 'which character replaces the unrepresentable characters is processor-dependent' write ( stdout , '(a)' ) 'and might be unprintable' aline = smiley write ( stdout , '(a,i0,a)' ) 'ADE:' , ichar ( aline ), ' CHARACTER:' , aline write ( stdout , '(A)' ) repeat ( '=' , 80 ) contains function ascii_to_ucs4 ( astr ) result ( ustr ) ! @(#) make the same conversion as an assignment statement from ASCII to UCS4 character ( len =* , kind = ascii ), intent ( in ) :: astr character ( len = len ( astr ), kind = ucs4 ) :: ustr integer :: i do i = 1 , len ( astr ) ustr ( i : i ) = achar ( iachar ( astr ( i : i )), kind = ucs4 ) enddo end function ascii_to_ucs4 function ucs4_to_ascii ( ustr ) result ( astr ) ! @(#) make the same conversion as an assignment statement from UCS4 o ASCII character ( len =* , kind = ucs4 ), intent ( in ) :: ustr character ( len = len ( ustr ), kind = ascii ) :: astr integer :: i do i = 1 , len ( ustr ) astr ( i : i ) = achar ( iachar ( ustr ( i : i )), kind = ascii ) enddo end function ucs4_to_ascii end program concatenate","tags":"","url":"program/concatenate.html"},{"title":"internal_io – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(kind=ascii, len=:), allocatable :: aline character(len=*), parameter :: all = '(*(g0))' integer, parameter :: ascii = selected_char_kind(\"ascii\") character(kind=ascii, len=:), allocatable :: astr character(kind=ucs4, len=1) :: glyph integer :: i integer, parameter :: ucs4 = selected_char_kind(\"ISO_10646\") character(kind=ucs4, len=:), allocatable :: uline character(kind=ucs4, len=:), allocatable :: ustr Source Code program internal_io use iso_fortran_env , only : stdout => output_unit implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = 1 , kind = ucs4 ) :: glyph character ( len =* ), parameter :: all = '(*(g0))' character ( len = :, kind = ascii ), allocatable :: aline character ( len = :, kind = ascii ), allocatable :: astr character ( len = :, kind = ucs4 ), allocatable :: uline character ( len = :, kind = ucs4 ), allocatable :: ustr integer :: i open ( stdout , encoding = 'UTF-8' ) print all , 'unicode UCS-4 string' ustr = ucs4_ 'Hello World and Ni Hao -- ' // char ( int ( z '4F60' ), ucs4 ) // char ( int ( z '597D' ), ucs4 ) write ( * , * ) ustr print all , 'length  :' , len ( ustr ) print all , 'bytes   :' , storage_size ( ustr ) / 8 print all , 'ASCII bytes' astr = 'Hello World and Ni Hao -- 你好' write ( * , * ) astr print all , 'length  :' , len ( astr ) print all , 'bytes   :' , storage_size ( astr ) / 8 ! SHOULD WRITE INTO ASCII CREATE RAW UTF8 OR WHAT? print all , 'UCS4 characters written to ASCII internal file' aline = repeat ( ' ' , len ( ustr )) write ( aline , all ) ustr aline = trim ( aline ) print all , 'length        :' , len ( aline ) print all , 'bytes         :' , storage_size ( aline ) / 8 print all , aline ! SHOULD WRITE INTO UCS4 DO ANYTHING DIFFERENT? print all print all , 'UCS4 characters written to UCS4 internal file' uline = repeat ( ' ' , len ( ustr )) write ( uline , all ) ustr uline = trim ( uline ) print all , 'length        :' , len ( uline ) print all , 'bytes         :' , storage_size ( uline ) / 8 print all , uline ! SHOULD WRITE INTO ASCII CREATE RAW UTF8 OR WHAT? print all , 'ASCII characters into ASCII internal file' aline = repeat ( ' ' , len ( astr )) write ( aline , all ) astr aline = trim ( aline ) print all , 'length        :' , len ( aline ) print all , 'bytes         :' , storage_size ( aline ) / 8 print all , aline ! SHOULD WRITE INTO UCS4 DO ANYTHING DIFFERENT? print all print all , 'ASCII characters into UCS4 internal file' uline = repeat ( ' ' , len ( astr )) write ( uline , all ) astr uline = trim ( uline ) print all , 'length        :' , len ( uline ) print all , 'bytes         :' , storage_size ( uline ) / 8 print all , uline write ( stdout , all )( ichar ( uline ( i : i )), \",\" , i = 1 , len ( uline )) print all , 'And back again' write ( stdout , all ) 'before:' , astr write ( stdout , all )( ichar ( astr ( i : i )), \",\" , i = 1 , len ( astr )) read ( uline , '(a)' ) astr write ( stdout , all ) 'after:' , astr write ( stdout , all )( ichar ( astr ( i : i )), \",\" , i = 1 , len ( astr )) end program internal_io","tags":"","url":"program/internal_io.html"},{"title":"count_glyphs – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0))' integer :: i character(len=255) :: iomsg integer :: iostat integer :: length integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(kind=ucs4, len=4096) :: uline Source Code program count_glyphs ! @(#) read a utf-8 file and write it out with lines prefixed with glyph count of the line use , intrinsic :: iso_fortran_env , only : output_unit , input_unit implicit none intrinsic selected_char_kind intrinsic is_iostat_end intrinsic len_trim integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: i integer :: iostat character ( len = 4096 , kind = ucs4 ) :: uline ! specifies maximum line length of 4096 glyphs not bytes character ( len = 255 ) :: iomsg open ( input_unit , encoding = 'UTF-8' ) open ( output_unit , encoding = 'UTF-8' ) do read ( input_unit , '(a)' , iostat = iostat , iomsg = iomsg ) uline if ( iostat . eq . 0 ) then length = len_trim ( uline ) write ( output_unit , '(i9,\": \",a)' ) length , uline (: length ) elseif ( is_iostat_end ( iostat )) then exit else ! does the message have to be converted to ucs-4? write ( output_unit , g ) '<ERROR>' , trim ( iomsg ) exit endif enddo end program count_glyphs","tags":"","url":"program/count_glyphs.html"},{"title":"test_for_iso_10646 – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial integer, parameter :: ucs4 = selected_char_kind('ISO_10646') Source Code program test_for_iso_10646 use iso_fortran_env , only : output_unit implicit none intrinsic selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) open ( output_unit , encoding = 'utf-8' ) write ( * , * ) 'Smiling face with open mouth' , char ( int ( z '1F603' ), kind = ucs4 ) ! 😃 end program test_for_iso_10646","tags":"","url":"program/test_for_iso_10646.html"},{"title":"test_M_utf8 – M_time","text":"Uses iso_fortran_env M_utf8 Variables Type Attributes Name Initial integer, parameter :: ascii = selected_char_kind(\"ascii\") character(len=:), allocatable :: astr character(kind=ucs4, len=*), parameter :: boz = char(int(z'4E03'), kind=ucs4)//char(int(z'8EE2'), kind=ucs4)//char(int(z'3073'), kind=ucs4)//char(int(z'516B'), kind=ucs4)//char(int(z'8D77'), kind=ucs4)//char(int(z'304D'), kind=ucs4)//char(int(z'3002'), kind=ucs4)//char(int(z'8EE2'), kind=ucs4)//char(int(z'3093'), kind=ucs4)//char(int(z'3067'), kind=ucs4)//char(int(z'3082'), kind=ucs4)//char(int(z'307E'), kind=ucs4)//char(int(z'305F'), kind=ucs4)//char(int(z'7ACB'), kind=ucs4)//char(int(z'3061'), kind=ucs4)//char(int(z'4E0A'), kind=ucs4)//char(int(z'304C'), kind=ucs4)//char(int(z'308B'), kind=ucs4)//char(int(z'3002'), kind=ucs4)//char(int(z'304F'), kind=ucs4)//char(int(z'3058'), kind=ucs4)//char(int(z'3051'), kind=ucs4)//char(int(z'305A'), kind=ucs4)//char(int(z'306B'), kind=ucs4)//char(int(z'524D'), kind=ucs4)//char(int(z'3092'), kind=ucs4)//char(int(z'5411'), kind=ucs4)//char(int(z'3044'), kind=ucs4)//char(int(z'3066'), kind=ucs4)//char(int(z'6B69'), kind=ucs4)//char(int(z'3044'), kind=ucs4)//char(int(z'3066'), kind=ucs4)//char(int(z'3044'), kind=ucs4)//char(int(z'3053'), kind=ucs4)//char(int(z'3046'), kind=ucs4)//char(int(z'3002'), kind=ucs4) integer :: err character(len=*), parameter :: g0 = '(*(g0))' character(len=*), parameter :: gx = '(*(g0,1x))' character(kind=ucs4, len=1) :: stop integer :: total integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(len=*), parameter :: upagain = \"七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。\" character(kind=ucs4, len=:), allocatable :: ustr Subroutines subroutine checkit (label, test) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label logical, intent(in) :: test Source Code program test_M_utf8 use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 , ucs4_to_utf8 implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) character ( len =* ), parameter :: g0 = '(*(g0))' character ( len =* ), parameter :: gx = '(*(g0,1x))' ! character ( len =* ), parameter :: upagain = \"七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。\" ! Romanization: ! Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! \"Fall seven times, stand up eight. Even if you fall down, you will get up again. Don't be discouraged, just keep walking forward.\" ! character ( len = 1 , kind = ucs4 ) :: stop character ( len = :, kind = ucs4 ), allocatable :: ustr character ( len = :), allocatable :: astr integer :: total integer :: err ! OUTPUT:七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。 character ( len =* , kind = ucs4 ), parameter :: boz = & char ( int ( z '4E03' ), kind = ucs4 ) // char ( int ( z '8EE2' ), kind = ucs4 ) // char ( int ( z '3073' ), kind = ucs4 ) // & char ( int ( z '516B' ), kind = ucs4 ) // char ( int ( z '8D77' ), kind = ucs4 ) // char ( int ( z '304D' ), kind = ucs4 ) // & char ( int ( z '3002' ), kind = ucs4 ) // char ( int ( z '8EE2' ), kind = ucs4 ) // char ( int ( z '3093' ), kind = ucs4 ) // & char ( int ( z '3067' ), kind = ucs4 ) // char ( int ( z '3082' ), kind = ucs4 ) // char ( int ( z '307E' ), kind = ucs4 ) // & char ( int ( z '305F' ), kind = ucs4 ) // char ( int ( z '7ACB' ), kind = ucs4 ) // char ( int ( z '3061' ), kind = ucs4 ) // & char ( int ( z '4E0A' ), kind = ucs4 ) // char ( int ( z '304C' ), kind = ucs4 ) // char ( int ( z '308B' ), kind = ucs4 ) // & char ( int ( z '3002' ), kind = ucs4 ) // char ( int ( z '304F' ), kind = ucs4 ) // char ( int ( z '3058' ), kind = ucs4 ) // & char ( int ( z '3051' ), kind = ucs4 ) // char ( int ( z '305A' ), kind = ucs4 ) // char ( int ( z '306B' ), kind = ucs4 ) // & char ( int ( z '524D' ), kind = ucs4 ) // char ( int ( z '3092' ), kind = ucs4 ) // char ( int ( z '5411' ), kind = ucs4 ) // & char ( int ( z '3044' ), kind = ucs4 ) // char ( int ( z '3066' ), kind = ucs4 ) // char ( int ( z '6B69' ), kind = ucs4 ) // & char ( int ( z '3044' ), kind = ucs4 ) // char ( int ( z '3066' ), kind = ucs4 ) // char ( int ( z '3044' ), kind = ucs4 ) // & char ( int ( z '3053' ), kind = ucs4 ) // char ( int ( z '3046' ), kind = ucs4 ) // char ( int ( z '3002' ), kind = ucs4 ) total = 0 write ( * , g0 ) 'utf8_to_ucs4' ustr = utf8_to_ucs4 ( upagain ) write ( * , g0 ) 'if file is not open for utf-8 encoding automatic conversion does not occur' write ( * , g0 ) 'utf8:' , upagain ! these are the bytes to represent the utf-8 characters write ( * , g0 ) 'ucs4:' , ustr ! this is 4-byte unicode that needs converted. Does it print as noise or all \"?\"? write ( * , g0 ) write ( * , g0 ) 'encoding can be altered on an open file' open ( output_unit , encoding = 'UTF-8' ) write ( * , g0 ) 'utf8:' , upagain write ( * , g0 ) 'ucs4:' , ustr ! so this should get \"automatically\" printed properly now write ( * , g0 ) stop = ustr ( 7 : 7 ) call checkit ( 'check len() is 36 :' , len ( ustr ) == 36 ) call checkit ( 'check index       :' , index ( ustr , stop , kind = ucs4 , back = . false .) == 7 ) call checkit ( 'check index       :' , index ( ustr , stop , back = . true ., kind = ucs4 ) == len ( ustr ) ) call checkit ( 'storage_size      :' , storage_size ( ustr ) == len ( ustr ) * 4 * 8 ) write ( * , g0 ) '## ucs4_to_utf8' write ( * , g0 ) write ( * , g0 ) 'boz=' , boz write ( * , g0 ) 'converted by external routine:' , ucs4_to_utf8 ( boz ) ! it is converted by the routine write ( * , g0 ) 'converted because file is encoded to utf-8:' , boz ! converted by standard Fortran ! standard method. Note ASCII one-byte characters become 4-byte characters, but multi-byte characters are not recognized ustr = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) astr = ucs4_to_utf8 ( ustr , err ) call checkit ( 'convert to ASCII bytes representing utf8' , astr == 'Hello World and Ni Hao -- 你好' ) if ( total . ne . 0 ) then write ( * , g0 ) total , 'failures' stop 1 endif contains subroutine checkit ( label , test ) character ( len =* ), intent ( in ) :: label logical , intent ( in ) :: test write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label if (. not . test ) total = total + 1 end subroutine checkit end program test_M_utf8","tags":"","url":"program/test_m_utf8.html"},{"title":"multi_line – M_time","text":"Uses iso_fortran_env M_utf8 Variables Type Attributes Name Initial integer, parameter :: ascii = selected_char_kind(\"ascii\") integer :: i integer :: j character(kind=ucs4, len=3) :: line integer :: longest integer, parameter :: ucs4 = selected_char_kind(\"ISO_10646\") character(len=255), parameter :: upagain (3) = [character(len=255)::\"七転び八起き。\", \"転んでもまた立ち上がる。\", \"くじけずに前を向いて歩いていこう。\"] character(kind=ucs4, len=4) :: ustr (size(upagain)) Source Code program multi_line use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) integer :: i , j , longest character ( len = 3 , kind = ucs4 ) :: line character ( len = 255 ), parameter :: upagain ( 3 ) = [ character ( len = 255 ) :: & \"七転び八起き。\" , & \"転んでもまた立ち上がる。\" , & \"くじけずに前を向いて歩いていこう。\" ] ! ! Romanization: ! Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! \"Fall seven times, stand up eight. Even if you fall down, you will get up again. Don't be discouraged, just keep walking forward.\" ! character ( len = 4 * len ( upagain ), kind = ucs4 ) :: ustr ( size ( upagain )) open ( output_unit , encoding = 'UTF-8' ) ! convert pseudo-utf-8 ascii to actual Fortran ucs4 unicode longest = 0 ! get longest trimmed line do i = 1 , size ( upagain ) ustr ( i ) = utf8_to_ucs4 ( upagain ( i )) longest = max ( longest , len_trim ( ustr ( i ))) enddo write ( output_unit , * ) write ( output_unit , * ) 'longest=' , longest write ( output_unit , * )( trim ( ustr ( i )), i = 1 , size ( ustr )) write ( output_unit , * ) ! does not work too well if not a fixed-space font, but even when fixed-spaced having problems in mintty anyway, at least do i = 1 , longest ! not lining up write ( output_unit , '(*(A))' ) ( ustr ( j )( i : i ), j = size ( upagain ), 1 , - 1 ) ! numbers for T seems to be for ASCII bytes !write(output_unit,'(T1,A,T5,A,T9,A)') (ustr(j)(i:i),j=1,size(upagain)) !line=ustr(3)(i:i)//ustr(2)(i:i)//ustr(1)(i:i) !write(*,*)line enddo do i = 1 , longest ! not lining up write ( output_unit , '(*(A))' ) ( ustr ( j )( i : i ), j = 1 , size ( upagain )) enddo end program multi_line","tags":"","url":"program/multi_line.html"},{"title":"demo_selected_char_kind – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(kind=ascii, len=26) :: alphabet integer, parameter :: ascii = selected_char_kind(\"ascii\") character(kind=ucs4, len=:), allocatable :: corrected integer, parameter :: default = selected_char_kind(\"default\") character(kind=ucs4, len=30) :: hello_world integer :: i character(len=*), parameter :: not_ascii = \"ľščťžýáßĄĘ®™√🙂\" character(kind=ucs4, len=30) :: string integer, parameter :: ucs4 = selected_char_kind('ISO_10646') integer, parameter :: utf8 = selected_char_kind('utf-8') Functions function utf8_to_utf32 (string) result(corrected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=ucs4, len=:), allocatable Subroutines subroutine create_date_string (string) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*) :: string Source Code program demo_selected_char_kind use iso_fortran_env implicit none intrinsic date_and_time , selected_char_kind ! set some aliases for common character kinds ! as the numbers can vary from platform to platform integer , parameter :: default = selected_char_kind ( \"default\" ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) integer , parameter :: utf8 = selected_char_kind ( 'utf-8' ) ! assuming ASCII and UCS4 are supported (ie. not equal to -1) ! define some string variables character ( len = 26 , kind = ascii ) :: alphabet character ( len = 30 , kind = ucs4 ) :: hello_world character ( len = 30 , kind = ucs4 ) :: string character ( len =* ), parameter :: not_ascii = \"ľščťžýáßĄĘ®™√🙂\" character ( len = :, kind = ucs4 ), allocatable :: corrected integer :: i write ( * , * ) 'ASCII     ' ,& & merge ( 'Supported    ' , 'Not Supported' , ascii /= - 1 ) write ( * , * ) 'ISO_10646 ' ,& & merge ( 'Supported    ' , 'Not Supported' , ucs4 /= - 1 ) write ( * , * ) 'UTF-8     ' ,& & merge ( 'Supported    ' , 'Not Supported' , utf8 /= - 1 ) if ( default . eq . ascii ) then write ( * , * ) 'ASCII is the default on this processor' endif ! for constants the kind precedes the value, somewhat like a ! BOZ constant alphabet = ascii_ \"abcdefghijklmnopqrstuvwxyz\" write ( * , * ) alphabet hello_world = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) ! an encoding option is required on OPEN for non-default I/O if ( ucs4 /= - 1 ) then open ( output_unit , encoding = 'UTF-8' ) write ( * , * ) trim ( hello_world ) else write ( * , * ) 'cannot use utf-8' endif call create_date_string ( string ) write ( * , * ) trim ( string ) write ( * , * ) 'NOT_ASCII:' , not_ascii write ( * , * ) 'LEN NOT_ASCII:' , len ( not_ascii ) write ( * , * ) 'STORAGE_SIZE:' , storage_size ( not_ascii ) corrected = utf8_to_utf32 ( not_ascii ) write ( * , * ) 'CORRECTED:' , corrected write ( * , * ) 'LEN CORRECTED:' , len ( corrected ) write ( * , * ) 'STORAGE_SIZE:' , storage_size ( corrected ) do i = 1 , len ( corrected ) write ( * , '(\"z''\",z0,\"''\")' ) corrected ( i : i ) enddo contains ! The following produces a Japanese date stamp. subroutine create_date_string ( string ) intrinsic date_and_time , selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = 1 , kind = ucs4 ), parameter :: & nen = char ( int ( z '5e74' ), ucs4 ), & ! year gatsu = char ( int ( z '6708' ), ucs4 ), & ! month nichi = char ( int ( z '65e5' ), ucs4 ) ! day character ( len = * , kind = ucs4 ) string integer values ( 8 ) call date_and_time ( values = values ) write ( string , 101 ) values ( 1 ), nen , values ( 2 ), gatsu , values ( 3 ), nichi 101 format ( * ( i0 , a )) end subroutine create_date_string function utf8_to_utf32 ( string ) result ( corrected ) character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = 255 , kind = ucs4 ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) string rewind ( lun ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) open ( output_unit , encoding = 'UTF-8' ) end function utf8_to_utf32 end program demo_selected_char_kind","tags":"","url":"program/demo_selected_char_kind.html"},{"title":"asciiset – M_time","text":"Uses iso_fortran_env M_utf8 Variables Type Attributes Name Initial character(len=:), allocatable :: aline integer, parameter :: ascii = selected_char_kind(\"ascii\") integer, parameter :: default = selected_char_kind(\"default\") character(kind=ucs4, len=1), allocatable :: glyph (:) integer :: i integer :: nerr integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(kind=ucs4, len=:), allocatable :: uline Source Code program asciiset use iso_fortran_env , only : stdout => output_unit use M_utf8 , only : utf8_to_ucs4 , utf8_to_ucs4_via_io !utf8_to_ucs4,        ucs4_to_utf8 !utf8_to_codepoints,  codepoints_to_utf8 !utf8_to_ucs4_via_io, ucs4_to_utf8_via_io !ascii_to_ucs4,       ucs4_to_ascii implicit none intrinsic selected_char_kind integer , parameter :: default = selected_char_kind ( \"default\" ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len = :), allocatable :: aline character ( len = :, kind = ucs4 ), allocatable :: uline character ( len = 1 , kind = ucs4 ), allocatable :: glyph (:) integer :: i integer :: nerr ! Do the extended character set values change from ADE 128 to 255 ! depending on the file encoding? By the standard, I think they ! should all become a character indicating the character is not ! valid(?). Check on screen and when redirected to file. Doing latin ! or latin1 or latin2 conversion would make sense as well. write ( stdout , '(a)' ) 'default encoding default kind:' write ( stdout , '(10(g0,1x,g0,1x))' )( char ( i ), i = 0 , 255 ) write ( stdout , '(a)' ) 'default encoding kind=ascii:' write ( stdout , '(10(g0,1x,g0,1x))' )( char ( i , kind = ascii ), i = 0 , 255 ) write ( stdout , '(a)' ) 'explicitly default encoding default kind:' open ( stdout , encoding = 'DEFAULT' ) write ( stdout , '(10(g0,1x,g0,1x))' )( char ( i ), i = 0 , 255 ) write ( stdout , '(a)' ) 'default encoding kind ucs4:' open ( stdout , encoding = 'UTF-8' ) write ( stdout , '(10(g0,1x,g0,1x))' )( char ( i ), i = 0 , 255 ) write ( stdout , '(10(g0,1x,g0,1x))' )( char ( i , kind = ucs4 ), i = 0 , 255 ) aline = repeat ( ' ' , 256 ) write ( aline , '(256a1)' ) ( char ( i ), i = 0 , 255 ) write ( stdout , '(a)' ) 'utf8_to_ucs4_via_io:' write ( stdout , '(10(g0,1x,g0,1x))' ) utf8_to_ucs4_via_io ( aline ) write ( stdout , '(a)' ) 'utf8_to_ucs4:' write ( stdout , '(10(g0,1x,g0,1x))' ) utf8_to_ucs4 ( aline ) end program asciiset","tags":"","url":"program/asciiset.html"},{"title":"backslash_escape – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(kind=ucs4, len=:), allocatable :: str integer, parameter :: ucs4 = selected_char_kind('ISO_10646') Source Code program backslash_escape use , intrinsic :: iso_fortran_env , only : output_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( kind = ucs4 , len = :), allocatable :: str ! EXTENSION: str = ucs4_ 'Unicode character: \\u263B' open ( output_unit , encoding = 'utf-8' ) print '(a)' , str print '(a)' , ucs4_ 'Unicode character: \\U0000263B' end program backslash_escape","tags":"","url":"program/backslash_escape.html"},{"title":"bom_exe – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(kind=ucs4, len=*), parameter :: U_bom = char(int(z'FEFF'), kind=ucs4) integer, parameter :: ucs4 = selected_char_kind('ISO_10646') Source Code program bom_exe ! ! create a Fortran source file starting with a utf-8 BOM to see if your ! compiler will compile it or fail because a character is not in the ! Fortran character set outside of a comment or literal string ! use iso_fortran_env , only : stdout => output_unit implicit none intrinsic selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* , kind = ucs4 ), parameter :: U_bom = char ( int ( z 'FEFF' ), kind = ucs4 ) open ( stdout , encoding = 'UTF-8' ) write ( stdout , '(a)' , advance = 'no' ) U_bom write ( stdout , '(a)' ) & ucs4_ 'program testit ! Unicode BOM encoded to utf-8 bytes by Fortran' ,& ucs4_ '   write(*,*)\"File starts with BOM from UCS-4 write!\"' ,& ucs4_ 'end program testit' end program bom_exe","tags":"","url":"program/bom_exe.html"},{"title":"supported – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial integer, parameter :: ascii = selected_char_kind(\"ascii\") integer, parameter :: default = selected_char_kind(\"default\") integer :: i integer :: iostat integer, parameter :: ucs4 = selected_char_kind('ISO_10646') Source Code program supported ! @(#) report if ISO_10646 is supported use iso_fortran_env , only : output_unit , character_kinds implicit none intrinsic selected_char_kind integer :: i integer :: iostat integer , parameter :: default = selected_char_kind ( \"default\" ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) write ( * , * ) 'Supported character kinds' , character_kinds write ( * , * ) 'ASCII     ' , merge ( 'Supported    ' , 'Not Supported' , ascii /= - 1 ), 'KIND=' , ascii write ( * , * ) 'ISO_10646 ' , merge ( 'Supported    ' , 'Not Supported' , ucs4 /= - 1 ), 'KIND=' , ucs4 write ( * , * ) 'DEFAULT   ' , merge ( 'Supported    ' , 'Not Supported' , default /= - 1 ), 'KIND=' , default if ( default . eq . ascii ) then write ( * , * ) 'ASCII is the same as the default on this processor' endif open ( output_unit , encoding = 'utf-8' , iostat = iostat ) if ( iostat . ne . 0 ) then write ( * , * ) 'utf-8 encoding not supported' else write ( * , * ) '7-bit ASCII' write ( * , '(16(i3,1x,a,1x))' )( i , char ( i , kind = ucs4 ), i = 0 , 127 ) write ( * , * ) 'remaining 8-bit ASCII' write ( * , '(16(i3,1x,a,1x))' )( i , char ( i , kind = ucs4 ), i = 128 , 255 ) endif end program supported","tags":"","url":"program/supported.html"},{"title":"demo_selected_char_kind – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial integer, parameter :: ascii = selected_char_kind(\"ascii\") integer, parameter :: default = selected_char_kind(\"default\") integer :: i integer :: iostat integer, parameter :: ucs4 = selected_char_kind('ISO_10646') Source Code program demo_selected_char_kind ! @(#) report if ISO_10646 is supported use iso_fortran_env implicit none intrinsic selected_char_kind integer :: i integer :: iostat integer , parameter :: default = selected_char_kind ( \"default\" ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) write ( * , * ) write ( * , * ) 'print 1-byte values (from 0 to 255) as characters:' write ( * , * ) ' only 0 to 127 is defined in ASCII, 128-255' write ( * , * ) ' often used for extended ASCII such as latin1 or latin2 encoding, or extended' write ( * , * ) ' characters such as box characters. If your default output is utf-8 values above' write ( * , * ) ' 127 should be a question mark or a shaded box' !  ENCODING= might not be supported open ( output_unit , encoding = 'utf-8' , iostat = iostat ) if ( iostat . ne . 0 ) then write ( * , * ) 'utf-8 encoding not supported' else write ( * , '(10(i3,1x,a,1x))' )( i , char ( i , kind = ucs4 ), i = 0 , 255 ) endif write ( * , * ) write ( * , * ) 'printing the bytes directly' write ( * , * ) 'with encoding=\"ASCII\"' open ( output_unit , encoding = 'ascii' , iostat = iostat ) write ( * , * ) 'ADE:' write ( * , '(10(i3,1x,a,1x))' )( i , i , i = 0 , 255 ) write ( * , * ) 'CHAR():' write ( * , '(10(i3,1x,a,1x))' )( i , char ( i ), i = 0 , 255 ) write ( * , * ) 'ACHAR():' write ( * , '(10(i3,1x,a,1x))' )( i , achar ( i ), i = 0 , 255 ) write ( * , * ) 'UCS-4 with encoding=\"UTF-8\"' open ( output_unit , encoding = 'utf-8' , iostat = iostat ) write ( * , '(10(i3,1x,a,1x))' )( i , char ( i , kind = ucs4 ), i = 0 , 255 ) write ( * , * ) 'with encoding=\"UTF-8\"' open ( output_unit , encoding = 'utf-8' , iostat = iostat ) write ( * , '(10(i3,1x,a,1x))' )( i , i , i = 0 , 255 ) write ( * , * ) 'Smiling face with open mouth' , char ( int ( z '1F603' ), kind = ucs4 ) ! 😃 write ( * , * ) 'Smiling face with open mouth' , char ([ int ( z 'F0' ), int ( z '9F' ), int ( z '98' ), int ( z '83' )], kind = ascii ) ! 😃 end program demo_selected_char_kind","tags":"","url":"program/demo_selected_char_kind~2.html"},{"title":"euro – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(len=1) :: euro0 = '€' character(len=*), parameter :: euro00 = '€' character(kind=ucs4, len=1) :: euro1 = '€' character(kind=ucs4, len=1) :: euro2 = ucs4_'€' character(kind=ucs4, len=1) :: euro3 = char(int(z'20AC'), kind=ucs4) character(len=*), parameter :: g5 = '(*(t3,g0,t9,g0,t16,g0,t22,g0))' integer, parameter :: ucs4 = selected_char_kind('ISO_10646') Source Code program euro use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stdin => input_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: g5 = '(*(t3,g0,t9,g0,t16,g0,t22,g0))' character ( len = 1 ) :: euro0 = '€' character ( len =* ), parameter :: euro00 = '€' character ( len = 1 , kind = ucs4 ) :: euro1 = '€' character ( len = 1 , kind = ucs4 ) :: euro2 = ucs4_ '€' character ( len = 1 , kind = ucs4 ) :: euro3 = char ( int ( z '20AC' ), kind = ucs4 ) write ( stdout , g5 ) 'OUTPUT  LEN    BYTES    KIND' open ( stdout , encoding = 'utf-8' ) write ( stdout , g5 ) euro0 , len ( euro0 ), storage_size ( euro0 ) / 8 , kind ( euro0 ) write ( stdout , g5 ) euro00 , len ( euro00 ), storage_size ( euro00 ) / 8 , kind ( euro00 ) write ( stdout , g5 ) euro1 , len ( euro1 ), storage_size ( euro1 ) / 8 , kind ( euro1 ) write ( stdout , g5 ) euro2 , len ( euro2 ), storage_size ( euro2 ) / 8 , kind ( euro2 ) write ( stdout , g5 ) euro3 , len ( euro3 ), storage_size ( euro3 ) / 8 , kind ( euro3 ) end program euro","tags":"","url":"program/euro.html"},{"title":"bom_exe – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(len=*), parameter :: A_bom = char(int(z'EF'))//char(int(z'BB'))//char(int(z'BF')) Source Code program bom_exe ! ! create a Fortran source file starting with a utf-8 BOM to see if your ! compiler will compile it or fail because a character is not in the ! Fortran character set outside of a comment or literal string ! use iso_fortran_env , only : stdout => output_unit implicit none character ( len =* ), parameter :: & & A_bom = char ( int ( z 'EF' )) // char ( int ( z 'BB' )) // char ( int ( z 'BF' )) write ( stdout , '(a)' , advance = 'no' ) A_bom write ( stdout , '(a)' ) & 'program testit ! Unicode BOM as utf-8 bytes' ,& '   write(*,*)\"File starts with BOM from \"\"bytes\"\" write!\"' ,& 'end program testit' end program bom_exe","tags":"","url":"program/bom_exe~2.html"},{"title":"multi_line – M_time","text":"Uses iso_fortran_env M_utf8 Variables Type Attributes Name Initial character(len=:), allocatable :: aline integer, parameter :: ascii = selected_char_kind(\"ascii\") integer :: i integer :: j integer :: longest character(kind=ucs4, len=3) :: u3 integer, parameter :: ucs4 = selected_char_kind(\"ISO_10646\") character(kind=ucs4, len=:), allocatable :: uline character(len=255), parameter :: upagain (3) = [character(len=255)::\"七転び八起き。\", \"転んでもまた立ち上がる。\", \"くじけずに前を向いて歩いていこう。\"] character(kind=ucs4, len=4) :: ustr (size(upagain)) Source Code program multi_line use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) integer :: i , j , longest character ( len = 3 , kind = ucs4 ) :: u3 character ( len = 255 ), parameter :: upagain ( 3 ) = [ character ( len = 255 ) :: & \"七転び八起き。\" , & \"転んでもまた立ち上がる。\" , & \"くじけずに前を向いて歩いていこう。\" ] character ( len = 4 * len ( upagain ), kind = ucs4 ) :: ustr ( size ( upagain )) character ( len = :), allocatable :: aline character ( len = :, kind = ucs4 ), allocatable :: uline ! ! Romanization: !    Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation !    \"Fall seven times, stand up eight. !    Even if you fall down, you will get up again. !    Don't be discouraged, just keep walking forward.\" ! open ( output_unit , encoding = 'UTF-8' ) ! convert pseudo-utf-8 ascii to actual Fortran ucs4 unicode longest = 0 ! get longest trimmed line do i = 1 , size ( upagain ) ustr ( i ) = utf8_to_ucs4 ( upagain ( i )) longest = max ( longest , len_trim ( ustr ( i ))) write ( * , * ) 'LEN=' , len_trim ( ustr ( i )) enddo write ( output_unit , * ) 'longest=' , longest write ( output_unit , * ) write ( output_unit , * )( trim ( ustr ( i )), i = 1 , size ( ustr )) write ( output_unit , * ) write ( output_unit , '(A)' ) ( trim ( ustr ( i )), i = 1 , size ( ustr )) write ( output_unit , '(*(z8.8))' ) (( ustr ( i )( j : j ), j = 1 , len_trim ( ustr ( i ))), i = 1 , size ( ustr )) write ( output_unit , * ) aline = '& &00004E0300008EE2000030730000516B00008D770000304D0000300200008EE20000309300003067& &000030820000307E0000305F00007ACB0000306100004E0A0000304C0000308B000030020000304F& &00003058000030510000305A0000306B0000524D0000309200005411000030440000306600006B69& &000030440000306600003044000030530000304600003002' allocate ( character ( len = len ( aline ) / 8 , kind = ucs4 ) :: uline ) !   read(aline,'(z288)') uline read ( aline , '(*(z8.8))' ) ( uline ( i : i ), i = 1 , len ( uline )) write ( output_unit , * ) uline end program multi_line","tags":"","url":"program/multi_line~2.html"},{"title":"crow_and_fox – M_time","text":"Uses M_unicode Variables Type Attributes Name Initial integer :: i type(unicode_type), allocatable :: poem (:) Source Code program crow_and_fox use M_unicode , only : unicode_type , ut => unicode_type , character , len ! “The Crow and the Fox” by Jean de la Fontaine type ( unicode_type ), allocatable :: poem (:) integer :: i poem = [& ut ( 'Maître Corbeau, sur un arbre perché,' ), & ut ( 'Tenait en son bec un fromage.' ), & ut ( 'Maître Renard, par l’odeur alléché,' ), & ut ( 'Lui tint à peu près ce langage :' ), & ut ( '«Hé ! bonjour, Monsieur du Corbeau.' ), & ut ( 'Que vous êtes joli ! que vous me semblez beau !' ), & ut ( 'Sans mentir, si votre ramage' ), & ut ( 'Se rapporte à votre plumage,' ), & ut ( 'Vous êtes le Phénix des hôtes de ces bois.»' ), & ut ( 'A ces mots le Corbeau ne se sent pas de joie ;' ), & ut ( 'Et pour montrer sa belle voix,' ), & ut ( 'Il ouvre un large bec, laisse tomber sa proie.' ), & ut ( 'Le Renard s’en saisit, et dit : «Mon bon Monsieur,' ), & ut ( 'Apprenez que tout flatteur' ), & ut ( 'Vit aux dépens de celui qui l’écoute :' ), & ut ( 'Cette leçon vaut bien un fromage, sans doute.»' ), & ut ( 'Le Corbeau, honteux et confus,' ), & ut ( 'Jura, mais un peu tard, qu’on ne l’y prendrait plus.' ), & ut ( ' -- Jean de la Fontaine' )] write ( * , '(g0)' )( character ( poem ( i )), i = 1 , size ( poem )) write ( * , '(a)' ) write ( * , '(*(a))' )( poem ( i )% bytes (), new_line ( 'a' ), i = 1 , size ( poem )) write ( * , '(a)' ) write ( * , '(*(g0))' )( character ( poem ( i )), len ( poem ( i )), ' ' , len ( poem ( i )% character ()), new_line ( 'a' ), i = 1 , size ( poem )) end program crow_and_fox","tags":"","url":"program/crow_and_fox.html"},{"title":"unifile_to_ftn – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(len=80) :: count character(len=*), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character(len=*), parameter :: g = '(*(g0))' integer :: i integer :: iostat integer :: j integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(kind=ucs4, len=4096) :: uline Source Code program unifile_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string as char(3f) calls use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stdin => input_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' character ( len = 80 ) :: count integer :: i , j , iostat character ( len = 4096 , kind = ucs4 ) :: uline open ( stdin , encoding = 'UTF-8' ) open ( stdout , encoding = 'UTF-8' ) write ( stdout , g ) 'program testit' write ( stdout , g ) 'use, intrinsic :: iso_fortran_env, only : output_unit' write ( stdout , g ) \"integer, parameter :: ucs4 = selected_char_kind ('ISO_10646')\" write ( stdout , g ) \"   open (output_unit, encoding='utf-8')\" do j = 1 , huge ( 0 ) - 1 read ( stdin , '(a)' , iostat = iostat ) uline if ( iostat . ne . 0 ) exit write ( count , g ) \"variable_\" , j , \"= &\" write ( stdout , g ) 'block' write ( stdout , g ) '! Unicode code points for ' , trim ( uline ) write ( stdout , g ) 'character(len=*,kind=ucs4),parameter :: ' // trim ( count ) write ( stdout , form )( uline ( i : i ), i = 1 , len_trim ( uline )) write ( stdout , g ) \"   write(output_unit,'(a)' )variable_\" , j write ( stdout , g ) 'endblock' enddo write ( stdout , g ) \"end program testit\" end program unifile_to_ftn","tags":"","url":"program/unifile_to_ftn.html"},{"title":"test_utf8 – M_time","text":"Uses iso_fortran_env M_utf8 Variables Type Attributes Name Initial integer, allocatable :: codepoints (:) character(kind=ucs4, len=:), allocatable :: corrected integer :: err integer :: i character(kind=ucs4, len=1) :: letter character(len=*), parameter :: not_ascii = \"ľščťžýáßĄĘ®™√🙂\" character(len=100) :: s integer, parameter :: ucs4 = selected_char_kind('ISO_10646')","tags":"","url":"program/test_utf8.html"},{"title":"testit – M_time","text":"Uses iso_fortran_env M_utf8 Variables Type Attributes Name Initial character(len=:), allocatable :: astr integer :: err integer, parameter :: ucs4 = selected_char_kind(\"ISO_10646\") character(kind=ucs4, len=:), allocatable :: ustr Source Code program testit use iso_fortran_env , only : stdout => output_unit use M_utf8 , only : ucs4_to_utf8 implicit none integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = :, kind = ucs4 ), allocatable :: ustr character ( len = :), allocatable :: astr integer :: err open ( stdout , encoding = 'UTF-8' ) ! standard method ustr = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) write ( stdout , * ) ustr write ( stdout , * ) merge ( 'PASSED' , 'FAILED' , storage_size ( ustr ) /= storage_size ( 'Hello World and Ni Hao -- 你好' ) ) astr = ucs4_to_utf8 ( ustr , err ) write ( stdout , * ) merge ( 'PASSED' , 'FAILED' , astr == 'Hello World and Ni Hao -- 你好' ) write ( stdout , * ) ustr write ( stdout , * ) astr end program testit","tags":"","url":"program/testit.html"},{"title":"uni_to_ftn – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial integer :: iostat integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(kind=ucs4, len=1024) :: uline character(kind=ucs4, len=:), allocatable :: ustr Source Code program uni_to_ftn ! simplistically copy a utf8 formatted sequential file from stdin to stdout, prefixing lines with number of glyphs use , intrinsic :: iso_fortran_env , only : output_unit , input_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len = 1024 , kind = ucs4 ) :: uline ! arbitrarily assume maximum line length. Stream I/O could be used instead character ( len = :, kind = ucs4 ), allocatable :: ustr integer :: iostat open ( output_unit , encoding = 'UTF-8' ) open ( input_unit , encoding = 'UTF-8' ) do read ( input_unit , '(a)' , iostat = iostat ) uline if ( iostat . ne . 0 ) exit ustr = trim ( uline ) ! assign and trim() works on 4-byte characters write ( output_unit , '(i9.9,\":\",a)' ) len ( ustr ), ustr ! len()  works on 4-byte characters enddo end program uni_to_ftn","tags":"","url":"program/uni_to_ftn.html"},{"title":"shouldit – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(kind=ascii, len=*), parameter :: A = 'ľščťžýáßĄĘ®™√🙂' character(kind=ascii, len=512) :: ALINE character(kind=ucs4, len=*), parameter :: B = char(int(z'13E'), kind=ucs4)//char(int(z'161'), kind=ucs4)//char(int(z'10D'), kind=ucs4)//char(int(z'165'), kind=ucs4)//char(int(z'17E'), kind=ucs4)//char(int(z'FD'), kind=ucs4)//char(int(z'E1'), kind=ucs4)//char(int(z'DF'), kind=ucs4)//char(int(z'104'), kind=ucs4)//char(int(z'118'), kind=ucs4)//char(int(z'AE'), kind=ucs4)//char(int(z'2122'), kind=ucs4)//char(int(z'221A'), kind=ucs4)//char(int(z'1F642'), kind=ucs4) character(kind=ucs4, len=512) :: ULINE integer, parameter :: ascii = selected_char_kind('ASCII') integer, parameter :: ucs4 = selected_char_kind('ISO_10646') Source Code program shouldit use iso_fortran_env , only : output_unit , int64 implicit none intrinsic selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) integer , parameter :: ascii = selected_char_kind ( 'ASCII' ) ! can something in quotes only be encoded as ASCII? !NO!character(len=*,kind=ucs4),parameter :: A=ucs4_'ľščťžýáßĄĘ®™√🙂' !NO!character(len=*,kind=ucs4),parameter :: A='ľščťžýáßĄĘ®™√🙂' character ( len =* , kind = ascii ), parameter :: A = 'ľščťžýáßĄĘ®™√🙂' character ( len = 512 , kind = ucs4 ) :: ULINE character ( len = 512 , kind = ascii ) :: ALINE character ( len =* , kind = ucs4 ), parameter :: B = & char ( int ( z '13E' ), kind = ucs4 ) // & char ( int ( z '161' ), kind = ucs4 ) // & char ( int ( z '10D' ), kind = ucs4 ) // & char ( int ( z '165' ), kind = ucs4 ) // & char ( int ( z '17E' ), kind = ucs4 ) // & char ( int ( z 'FD' ), kind = ucs4 ) // & char ( int ( z 'E1' ), kind = ucs4 ) // & char ( int ( z 'DF' ), kind = ucs4 ) // & char ( int ( z '104' ), kind = ucs4 ) // & char ( int ( z '118' ), kind = ucs4 ) // & char ( int ( z 'AE' ), kind = ucs4 ) // & char ( int ( z '2122' ), kind = ucs4 ) // & char ( int ( z '221A' ), kind = ucs4 ) // & char ( int ( z '1F642' ), kind = ucs4 ) !character(len=1,kind=ucs4),parameter :: C(*)=& !char(int([z'13E',z'161',z'10D',z'165',z'17E',z'FD',z'E1',z'DF',z'104',z'118',z'AE',z'2122',z'221A',z'1F642']),kind=ucs4) open ( output_unit , encoding = 'UTF-8' ) write ( * , * ) 'this is not really UTF-8, it a stream of bytes that has the right values' write ( * , * ) A , len ( A ), storage_size ( A ), A ( 10 : 14 ) write ( * , * ) 'Fortran actually understands this, so slice and intrinsics work correctly' write ( * , * ) B , len ( B ), storage_size ( B ), B ( 10 : 14 ) write ( * , * ) 'The data between the quotes is ASCII so this does not work' write ( * , * ) ucs4_ 'ľ' , ucs4_ 'š' , ucs4_ 'č' , ucs4_ 'ť' , ucs4_ 'ž' , & ucs4_ 'ý' , ucs4_ 'á' , ucs4_ 'ß' , ucs4_ 'Ą' , ucs4_ 'Ę' , & ucs4_ '®' , ucs4_ '™' , ucs4_ '√' , ucs4_ '🙂' write ( * , * ) 'might work but not defined by the standard that I can tell' write ( ULINE , '(A)' ) A write ( * , * ) 'ULINE:' , trim ( ULINE ) write ( * , * ) 'A:' , A write ( * , * ) 'might work but not defined by the standard that I can tell' write ( ALINE , '(A)' ) A write ( * , * ) 'ALINE:' , trim ( ALINE ) write ( * , * ) 'biggest code:' write ( * , * ) 'FFFFFFFF:' , int ( z 'FFFFFFFF' , kind = int64 ) end program shouldit","tags":"","url":"program/shouldit.html"},{"title":"assignment – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(len=:), allocatable :: a1 character(len=:), allocatable :: a2 character(len=:), allocatable :: aline integer, parameter :: ascii = selected_char_kind(\"ascii\") character(len=1), allocatable :: ch (:) character(len=1), allocatable :: ch2 (:) integer, parameter :: default = selected_char_kind(\"default\") character(kind=ucs4, len=1), allocatable :: glyph (:) integer :: i integer :: iostat integer :: nerr character(len=1) :: paws character(kind=ucs4, len=1) :: smiley = char(int(z'1F603'), kind=ucs4) character(kind=ucs4, len=:), allocatable :: u1 character(kind=ucs4, len=:), allocatable :: u2 integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(kind=ucs4, len=:), allocatable :: uline Source Code program assignment use iso_fortran_env , only : stdout => output_unit , stdin => input_unit implicit none intrinsic selected_char_kind integer , parameter :: default = selected_char_kind ( \"default\" ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len = :), allocatable :: aline , a1 , a2 character ( len = :, kind = ucs4 ), allocatable :: uline , u1 , u2 character ( len = 1 ), allocatable :: ch (:), ch2 (:) character ( len = 1 , kind = ucs4 ), allocatable :: glyph (:) integer :: i integer :: iostat integer :: nerr character ( len = 1 ) :: paws character ( len = 1 , kind = ucs4 ) :: smiley = char ( int ( z '1F603' ), kind = ucs4 ) ! 😃 Smiling face with open mouth open ( stdout , encoding = 'DEFAULT' ) open ( stdout , encoding = 'UTF-8' ) ! ! only characters defined in the other encoding are copied on an assign write ( stdout , '(A)' ) repeat ( ' ' , 80 ) write ( stdout , '(A)' ) 'assign RHS ucs4 to LHS ascii' uline = char ( int ( z '261B' ), ucs4 ) // ucs4_ 'UCS-4 string' // char ( int ( z '261A' ), ucs4 ) write ( stdout , '(a)' ) trim ( uline ) aline = uline ! only the ASCII 7-bit characters are copied write ( stdout , '(a)' ) trim ( aline ) // ' assigned to ASCII' write ( stdout , '(A)' ) repeat ( ' ' , 80 ) write ( stdout , '(A)' ) 'assign LHS ascii to RHS ucs4' aline = ascii_ 'ASCII string' write ( stdout , '(a)' ) trim ( aline ) uline = aline ! all ASCII 7-bit characters can be represented in UCS-4 write ( stdout , '(a)' ) trim ( uline ) // ucs4_ ' assigned to UCS4' write ( stdout , '(A)' ) 'round trip for all ASCII bytes' write ( stdout , '(A)' ) repeat ( ucs4_ '=' , 80 ) ch = [( char ( i ), i = 0 , 255 )] open ( stdout , encoding = 'DEFAULT' ) write ( stdout , '(10(g0,1x,g0,1x))' )( ch ( i ), i = 0 , 255 ) open ( stdout , encoding = 'UTF-8' ) write ( stdout , '(10(g0,1x,g0,1x))' )( ch ( i ), i = 0 , 255 ) read ( stdin , '(a)' , iostat = iostat ) paws write ( stdout , '(A)' ) repeat ( ucs4_ '=' , 80 ) glyph = ch write ( stdout , '(10(g0,1x,g0,1x))' )( glyph ( i ), i = 0 , 255 ) read ( stdin , '(a)' , iostat = iostat ) paws write ( stdout , '(A)' ) repeat ( ucs4_ '=' , 80 ) ch2 = glyph write ( stdout , '(10(g0,1x,g0,1x))' )( ch2 ( i ), i = 0 , 255 ) read ( stdin , '(a)' , iostat = iostat ) paws write ( stdout , '(A)' ) repeat ( ucs4_ '=' , 80 ) write ( stdout , '(a,L0)' ) 'roundrobin returned all values unchanged?' , all ( ch . eq . ch2 ) end program assignment","tags":"","url":"program/assignment.html"},{"title":"assign_exe – M_time","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=:), allocatable :: aline integer, allocatable :: codes (:) character(len=*), parameter :: g = '(*(g0))' character(len=:), allocatable :: glyphs character(len=*), parameter :: smiley = '😃' type( unicode_type ) :: substring type( unicode_type ) :: uline type( unicode_type ) :: uline1 type( unicode_type ) :: uline2 type( unicode_type ) :: uline3 Source Code program assign_exe use M_unicode , only : len , len_trim , repeat , trim , adjustr , adjustl use M_unicode , only : character use M_unicode , only : assignment ( = ), unicode_type character ( len =* ), parameter :: g = '(*(g0))' character ( len = :), allocatable :: aline type ( unicode_type ) :: uline , substring , uline1 , uline2 , uline3 character ( len =* ), parameter :: smiley = '😃' integer , allocatable :: codes (:) character ( len = :), allocatable :: glyphs aline = \"Доки не впріти, доти не вміти.\" write ( * , g ) '123456789012345678901234567890' write ( * , g ) aline write ( * , g ) 'length in bytes is: ' , len ( aline ) uline = aline write ( * , g ) 'length in glyphs is: ' , len ( uline ) write ( * , g ) 'string is: ' , character ( uline ) write ( * , g ) 'third word is: ' , character ( uline , 9 , 14 ) ! substring substring = character ( uline , 17 , 29 ) write ( * , g ) 'string is: ' , character ( substring ) uline = repeat ( smiley , 30 ) write ( * , g ) character ( uline ) write ( * , g ) len_trim ( uline ) uline = aline // '      ' write ( * , g ) len_trim ( uline ) uline = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] write ( * , g ) 'spaces:' , character ( uline ), len ( uline ), len_trim ( uline ) uline = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] uline = trim ( uline ) write ( * , g ) 'trim:' , '[' , character ( uline ), ']' uline = '    this  is just a    string        ' write ( * , g ) 'adjustr:' , '[' , character ( uline ), '] ==> [' , character ( adjustr ( uline )), ']' uline = '    this  is just a    string        ' write ( * , g ) 'adjustl:' , '[' , character ( uline ), '] ==> [' , character ( adjustl ( uline )), ']' !write(*,g)uline%codes !write(*,g)uline end program assign_exe","tags":"","url":"program/assign_exe.html"},{"title":"count_glyphs – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0))' integer :: i character(len=255) :: iomsg integer :: iostat integer :: length integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(kind=ucs4, len=1024) :: uline Source Code program count_glyphs ! @(#) read a utf-8 file and write it out with lines prefixed with glyph counts of the line use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stdin => input_unit implicit none intrinsic selected_char_kind intrinsic is_iostat_end intrinsic len_trim !------ ! NOTE: we will be using the kind name \"ucs4\" for Unicode variables integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) !------ character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: i integer :: iostat !------ ! NOTE: this character variable is the Unicode kind, not ASCII character ( len = 1024 , kind = ucs4 ) :: uline ! specifies maximum line length of 1024 glyphs ! which would be 4*1024 bytes !------ character ( len = 255 ) :: iomsg !------ ! NOTE: you can change the encoding used for a file dynamically, even on pre-assigned files open ( stdin , encoding = 'UTF-8' ) open ( stdout , encoding = 'UTF-8' ) !------ do read ( stdin , '(a)' , iostat = iostat , iomsg = iomsg ) uline if ( iostat . eq . 0 ) then !------ ! NOTE: LEN_TRIM() works with UCS-4 just as with ASCII length = len_trim ( uline ) !------ !------ ! NOTE: String substrings work just like with ASCII as well write ( stdout , '(i9,\": \",a)' ) length , uline (: length ) !------ elseif ( is_iostat_end ( iostat )) then exit else !------ ! NOTE: ! does the ASCII message have to be converted to UCS-4? ! This will be discussed in detail later, but for now ! remember you can change the encoding of a file dynamically open ( stdout , encoding = 'DEFAULT' ) !------ write ( stdout , g ) '<ERROR>' , trim ( iomsg ) exit endif enddo end program count_glyphs","tags":"","url":"program/count_glyphs~2.html"},{"title":"uni_to_ftn – M_time","text":"Uses iso_fortran_env M_utf8 Variables Type Attributes Name Initial character(len=:), allocatable :: aline character(len=:), allocatable :: command_line character(len=*), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character(len=*), parameter :: g = '(*(g0))' integer :: i integer :: length integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(kind=ucs4, len=:), allocatable :: ustr Source Code program uni_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string as char(3f) calls use , intrinsic :: iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: i character ( len = :), allocatable :: aline character ( len = :), allocatable :: command_line character ( len = :, kind = ucs4 ), allocatable :: ustr open ( output_unit , encoding = 'UTF-8' ) call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = adjustl ( command_line ( length + 1 :)) ustr = utf8_to_ucs4 ( command_line ) write ( * , g ) 'program testit' write ( * , g ) 'use, intrinsic :: iso_fortran_env, only : output_unit' write ( * , g ) \"integer, parameter :: ucs4 = selected_char_kind ('ISO_10646')\" write ( * , g ) '! OUTPUT:' , command_line write ( * , g ) 'character(len=*,kind=ucs4),parameter :: variable = &' write ( * , form )( ustr ( i : i ), i = 1 , len ( ustr )) write ( * , g ) \"   open (output_unit, encoding='utf-8')\" write ( * , g ) \"   write(output_unit,'(a)' )variable\" write ( * , g ) \"end program testit\" end program uni_to_ftn","tags":"","url":"program/uni_to_ftn~2.html"},{"title":"test_M_unicode – M_time","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial logical, parameter :: F = .false. logical, parameter :: T = .true. integer, parameter :: ascii = selected_char_kind(\"ascii\") character(len=:), allocatable :: astr integer :: err character(len=*), parameter :: g0 = '(*(g0))' character(len=*), parameter :: gx = '(*(g0,1x))' integer :: i type( unicode_type ) :: lhs type( unicode_type ) :: rhs type( unicode_type ) :: smiley type( unicode_type ) :: string type( unicode_type ) :: substring integer :: total character(len=*), parameter :: upagain = \"七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。\" type( unicode_type ) :: ut_str Subroutines subroutine check (label, test) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label logical, intent(in) :: test subroutine checkit (label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline character(len=*), intent(in) :: answer character(len=*), intent(in) :: expected subroutine checkits (label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline character(len=*), intent(in) :: answer (:) character(len=*), intent(in) :: expected (:) subroutine checkits_l (label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline logical, intent(in) :: answer (:) logical, intent(in) :: expected (:) Source Code program test_M_unicode use iso_fortran_env , only : output_unit use M_unicode , only : adjustl , adjustr , trim , index use M_unicode , only : character use M_unicode , only : assignment ( = ), unicode_type , operator ( // ) use M_unicode , only : operator ( <= ), lle use M_unicode , only : operator ( < ), llt use M_unicode , only : operator ( /= ), lne use M_unicode , only : operator ( == ), leq use M_unicode , only : operator ( > ), lgt use M_unicode , only : operator ( >= ), lge implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) character ( len =* ), parameter :: g0 = '(*(g0))' character ( len =* ), parameter :: gx = '(*(g0,1x))' logical , parameter :: T = . true . logical , parameter :: F = . false . ! character ( len =* ), parameter :: upagain = \"七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。\" ! Romanization: ! Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! \"Fall seven times, stand up eight. Even if you fall down, you will get up again. Don't be discouraged, just keep walking forward.\" ! character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str type ( unicode_type ) :: smiley integer :: total integer :: err integer :: i type ( unicode_type ) :: lhs , rhs type ( unicode_type ) :: string , substring smiley = '😃' total = 0 write ( * , g0 ) 'encoding can be altered on an open file' open ( output_unit , encoding = 'UTF-8' ) write ( * , g0 ) astr = 'Hello World and Ni Hao -- 你好' ut_str = astr call checkits ( 'convert to ASCII bytes' , astr , ut_str % bytes (), transfer ( 'Hello World and Ni Hao -- 你好' ,[ 'A' ])) astr = \"  this is a string    \" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'this is a string      ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '      this is a string' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '  this is a string' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 18 ) call check ( 'len' , ut_str % len (). eq . 22 ) astr = \"  \" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '  ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '  ' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 0 ) call check ( 'len' , ut_str % len (). eq . 2 ) astr = \"\" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 0 ) call check ( 'len' , ut_str % len (). eq . 0 ) astr = \"ALLFULL\" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'ALLFULL' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), 'ALLFULL' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), 'ALLFULL' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 7 ) call check ( 'len' , ut_str % len (). eq . 7 ) ut_str = [ 32 , 32 , int ( z '1F603' ), 32 , 32 , 32 ] astr = character ( ut_str ) call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '😃     ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '     😃' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '  😃' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 3 ) call check ( 'len' , ut_str % len (). eq . 6 ) if ( total . ne . 0 ) then write ( * , g0 ) total , 'failures' stop 1 endif ut_str = smiley // ' and ' // smiley // 'and' // smiley // smiley // 'is it' astr = '😃 and 😃and😃😃is it' call checkit ( 'concatenation' , astr , character ( ut_str ), '😃 and 😃and😃😃is it' ) lhs = 'this is the left' rhs = 'this is the right' call checkits_l ( 'LLE' , ' ' , [ lle ( lhs , rhs ), lhs <= rhs , lle ( rhs , lhs ), rhs <= lhs ] , [ T , T , F , F ] ) call checkits_l ( 'LLT' , ' ' , [ llt ( lhs , rhs ), lhs < rhs , llt ( rhs , lhs ), rhs < lhs ] , [ T , T , F , F ] ) call checkits_l ( 'LNE' , ' ' , [ lne ( lhs , rhs ), lhs /= rhs , lne ( rhs , lhs ), rhs /= lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LEQ' , ' ' , [ leq ( lhs , rhs ), lhs == rhs , leq ( rhs , lhs ), rhs == lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LGT' , ' ' , [ lgt ( lhs , rhs ), lhs > rhs , lgt ( rhs , lhs ), rhs > lhs ] , [ F , F , T , T ] ) call checkits_l ( 'LGE' , ' ' , [ lge ( lhs , rhs ), lhs >= rhs , lge ( rhs , lhs ), rhs >= lhs ] , [ F , F , T , T ] ) lhs = 'abc' rhs = 'abc ' call checkits_l ( 'LLE' , ' ' , [ lle ( lhs , rhs ), lhs <= rhs , lle ( rhs , lhs ), rhs <= lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LLT' , ' ' , [ llt ( lhs , rhs ), lhs < rhs , llt ( rhs , lhs ), rhs < lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LNE' , ' ' , [ lne ( lhs , rhs ), lhs /= rhs , lne ( rhs , lhs ), rhs /= lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LEQ' , ' ' , [ leq ( lhs , rhs ), lhs == rhs , leq ( rhs , lhs ), rhs == lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LGT' , ' ' , [ lgt ( lhs , rhs ), lhs > rhs , lgt ( rhs , lhs ), rhs > lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LGE' , ' ' , [ lge ( lhs , rhs ), lhs >= rhs , lge ( rhs , lhs ), rhs >= lhs ] , [ T , T , T , T ] ) string = \" can you find me here? \" substring = \"find me\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 10 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 10 ) string = \" can you find me here? \" substring = \"not there\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 0 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 0 ) string = \"short\" substring = \"shortnot\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 0 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 0 ) string = upagain write ( * , g0 ) 'original bytes  :' , upagain write ( * , g0 ) 'bytes reversed  :' , ( upagain ( i : i ), i = len ( upagain ), 1 , - 1 ) write ( * , g0 ) 'original string :' , string % character () write ( * , g0 ) 'string reversed :' , string % character ( string % len (), 1 , - 1 ) contains subroutine checkit ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer character ( len =* ), intent ( in ) :: expected write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , answer . eq . expected ), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( answer . ne . expected ) total = total + 1 end subroutine checkit subroutine checkits ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer (:) character ( len =* ), intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eq . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . ne . expected )) total = total + 1 end subroutine checkits subroutine checkits_l ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline logical , intent ( in ) :: answer (:) logical , intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eqv . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . neqv . expected )) total = total + 1 end subroutine checkits_l subroutine check ( label , test ) character ( len =* ), intent ( in ) :: label logical , intent ( in ) :: test write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label if (. not . test ) total = total + 1 end subroutine check end program test_M_unicode","tags":"","url":"program/test_m_unicode.html"},{"title":"testit – M_time","text":"Uses iso_fortran_env M_utf8 Variables Type Attributes Name Initial character(kind=ascii, len=:), allocatable :: aline character(len=*), parameter :: all = '(*(g0))' integer, parameter :: ascii = selected_char_kind(\"ascii\") character(kind=ucs4, len=1) :: glyph integer :: i character(kind=ucs4, len=:), allocatable :: str integer, parameter :: ucs4 = selected_char_kind(\"ISO_10646\") character(kind=ucs4, len=:), allocatable :: uline Source Code program testit use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 , ucs4_to_utf8_via_io , utf8_to_ucs4_via_io implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = :, kind = ucs4 ), allocatable :: str character ( len = 1 , kind = ucs4 ) :: glyph character ( len =* ), parameter :: all = '(*(g0))' character ( len = :, kind = ascii ), allocatable :: aline character ( len = :, kind = ucs4 ), allocatable :: uline integer :: i open ( output_unit , encoding = 'UTF-8' ) ! standard method str = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) write ( * , * ) str ! converting pseudo-utf8 to ucs4 str = utf8_to_ucs4 ( 'Hello World and Ni Hao -- 你好' ) write ( * , * ) str print all print all , 'intrinsics work with ucs4:' print all , 'slice glyph 27:' , str ( 27 : 27 ) print all , 'length        :' , len ( str ) print all , 'bytes         :' , storage_size ( str ) / 8 glyph = str ( 27 : 27 ) print all , 'index         :' , index ( str , glyph ) write ( * , '(a,i0,\",z''\",z0,\"''\")' ) 'ichar         :' , ichar ( glyph ), glyph glyph = char ( int ( z '597D' ), kind = ucs4 ) print all , 'char          :' , glyph print all , 'repeat        :' , repeat ( str ( 27 : 28 ), 3 ) ! SHOULD WRITE INTO ASCII CREATE RAW UTF8 OR WHAT? print all print all , 'internal write into ascii' aline = repeat ( ' ' , len ( str ) * 4 ) write ( aline , all ) str aline = trim ( aline ) print all , 'length        :' , len ( aline ) print all , 'bytes         :' , storage_size ( aline ) / 8 print all , aline ! SHOULD WRITE INTO UCS4 DO ANYTHING DIFFERENT? print all print all , 'internal write into ucs4' uline = repeat ( ' ' , len ( str )) write ( uline , all ) str uline = trim ( uline ) print all , 'length        :' , len ( uline ) print all , 'bytes         :' , storage_size ( uline ) / 8 print all , uline print all print all , 'raw utf8' print all , 'length        :' , len ( 'Hello World and Ni Hao -- 你好' ) print all , 'bytes         :' , storage_size ( 'Hello World and Ni Hao -- 你好' ) / 8 ! WHAT SHOULD ASSIGN DO? print all print all , 'assign' aline = uline print all , 'length        :' , len ( aline ) print all , 'bytes         :' , storage_size ( aline ) / 8 print all , aline print all print all , 'to be or not to be' ! Ikiru ka shinu ka ! \"to live or die\" str = utf8_to_ucs4 ( '生きるか死ぬか' ) print all , 'ucs4 string:' , str print all , 'reverse:    ' ,( str ( i : i ), i = len ( str ), 1 , - 1 ) print all print all , 'ucs4 to utf8' str = utf8_to_ucs4_via_io ( '生きるか死ぬか' ) aline = ucs4_to_utf8_via_io ( str ) print all , merge ( 'PASSED' , 'FAILED' , aline == '生きるか死ぬか' ) end program testit","tags":"","url":"program/testit~2.html"},{"title":"note – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(kind=ucs4, len=*), parameter :: pointer = char(int(z'1FBC1'), kind=ucs4)//char(int(z'1FBC2'), kind=ucs4)//char(int(z'1FBC3'), kind=ucs4) integer, parameter :: ucs4 = selected_char_kind('ISO_10646') Source Code program note use iso_fortran_env , only : output_unit implicit none intrinsic selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* , kind = ucs4 ), parameter :: pointer = char ( int ( z '1FBC1' ), kind = ucs4 ) // & char ( int ( z '1FBC2' ), kind = ucs4 ) // & char ( int ( z '1FBC3' ), kind = ucs4 ) open ( output_unit , encoding = 'UTF-8' ) write ( * , * ) pointer end program note","tags":"","url":"program/note.html"},{"title":"uni_to_ftn – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(len=:), allocatable :: aline character(len=:), allocatable :: command_line character(len=*), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character(len=*), parameter :: g = '(*(g0))' integer :: i integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(kind=ucs4, len=:), allocatable :: ustr Functions function getargs () result(command_line) Arguments None Return Value character(len=:), allocatable function ucs4_to_utf8 (ucs4_string) result(corrected) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ucs4_string Return Value character(len=:), allocatable function utf8_to_ucs4 (string) result(corrected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=ucs4, len=:), allocatable Source Code program uni_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string use , intrinsic :: iso_fortran_env , only : output_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' integer :: i character ( len = :), allocatable :: aline character ( len = :), allocatable :: command_line character ( len = :, kind = ucs4 ), allocatable :: ustr command_line = getargs () ! get string containing all command arguments as CHARACTER bytes ustr = utf8_to_ucs4 ( command_line ) ! convert bytes to internal Fortran Unicode representation ! write the command line out as a Fortran variable expression using the CHAR() function open ( output_unit , encoding = 'UTF-8' ) write ( * , g ) '! ENCODING:' , command_line write ( * , g ) 'character(len=*,kind=ucs4),parameter :: variable= &' write ( * , form )( ustr ( i : i ), i = 1 , len ( ustr )) contains function getargs () result ( command_line ) integer :: length character ( len = :), allocatable :: command_line call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = adjustl ( command_line ( length + 1 :)) end function getargs function utf8_to_ucs4 ( string ) result ( corrected ) character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = ( len ( string )), kind = ucs4 ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) string rewind ( lun ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function utf8_to_ucs4 function ucs4_to_utf8 ( ucs4_string ) result ( corrected ) character ( len =* , kind = ucs4 ), intent ( in ) :: ucs4_string character ( len = :), allocatable :: corrected character ( len = ( len ( ucs4_string ) * 4 )) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) ucs4_string rewind ( lun ) open ( unit = lun , encoding = 'default' ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function ucs4_to_utf8 end program uni_to_ftn","tags":"","url":"program/uni_to_ftn~3.html"},{"title":"read_filename – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(len=:), allocatable :: afilename integer :: lun integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(kind=ucs4, len=:), allocatable :: ufilename Functions function ucs4_to_utf8 (ucs4_string) result(ascii_string) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ucs4_string Return Value character(len=:), allocatable Source Code program read_filename ! @(#) convert ucs-4 filename to utc-8 for OPEN() statement use , intrinsic :: iso_fortran_env , only : output_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len = :), allocatable :: afilename character ( len = :, kind = ucs4 ), allocatable :: ufilename integer :: lun ! we have a UCS-4 filename from somewhere ... ufilename = & ! ENCODING:môj_obľúbený_súbor \"my_favorite_file\" char ( int ( z '6D' ), kind = ucs4 ) // char ( int ( z 'F4' ), kind = ucs4 ) // char ( int ( z '6A' ), kind = ucs4 ) // & char ( int ( z '5F' ), kind = ucs4 ) // char ( int ( z '6F' ), kind = ucs4 ) // char ( int ( z '62' ), kind = ucs4 ) // & char ( int ( z '13E' ), kind = ucs4 ) // char ( int ( z 'FA' ), kind = ucs4 ) // char ( int ( z '62' ), kind = ucs4 ) // & char ( int ( z '65' ), kind = ucs4 ) // char ( int ( z '6E' ), kind = ucs4 ) // char ( int ( z 'FD' ), kind = ucs4 ) // & char ( int ( z '5F' ), kind = ucs4 ) // char ( int ( z '73' ), kind = ucs4 ) // char ( int ( z 'FA' ), kind = ucs4 ) // & char ( int ( z '62' ), kind = ucs4 ) // char ( int ( z '6F' ), kind = ucs4 ) // char ( int ( z '72' ), kind = ucs4 ) afilename = ucs4_to_utf8 ( ufilename ) open ( newunit = lun , file = afilename , encoding = 'utf-8' ) !CLOSE(unit=lun, status='delete') contains function ucs4_to_utf8 ( ucs4_string ) result ( ascii_string ) character ( len =* , kind = ucs4 ), intent ( in ) :: ucs4_string character ( len = :), allocatable :: ascii_string character ( len = ( len ( ucs4_string ) * 4 )) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) ucs4_string rewind ( lun ) open ( unit = lun , encoding = 'default' ) read ( lun , '(A)' ) line close ( lun ) ascii_string = trim ( line ) end function ucs4_to_utf8 end program read_filename","tags":"","url":"program/read_filename.html"},{"title":"concatenate.f90 – M_time","text":"Source Code program concatenate use iso_fortran_env , only : stdout => output_unit , stdin => input_unit implicit none intrinsic selected_char_kind integer , parameter :: default = selected_char_kind ( \"default\" ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: g = '(*(g0))' character ( len = :), allocatable :: aline , a1 , a2 character ( len = :, kind = ucs4 ), allocatable :: uline , u1 , u2 character ( len = 1 ), allocatable :: ch (:), ch2 (:) character ( len = 1 , kind = ucs4 ), allocatable :: glyph (:) integer :: i integer :: iostat integer :: nerr character ( len = 1 ) :: paws character ( len = 1 , kind = ucs4 ) :: smiley = char ( int ( z '1F603' ), kind = ucs4 ) ! 😃 Smiling face with open mouth open ( stdout , encoding = 'DEFAULT' ) open ( stdout , encoding = 'UTF-8' ) ! ! Concatenation: ! write ( stdout , '(A)' ) repeat ( '=' , 80 ) write ( stdout , '(a)' ) 'strings of different kinds cannot be concatenated.' !uline='ascii string'// smiley // 'ascii string' ! NO. Kinds must match write ( stdout , '(a)' ) 'Of course constants can have their KIND specified.' uline = ucs4_ 'first UCS4 string' // smiley // ucs4_ 'another UCS4 string ' write ( stdout , '(A)' ) uline ! write ( stdout , '(A)' ) repeat ( '=' , 80 ) write ( stdout , '(a)' ) 'you can use simple assigns to do conversions' ! so if I have a UCS4 string u1 = smiley // ucs4_ 'UCS4 strings' // smiley // ucs4_ 'appended together' // smiley ! and an ASCII string a1 = 'ascii strings' // 'appended together' ! the ASCII string can be converted to UCS4 with an assign u2 = a1 ! use allocation to convert ASCII to UCS4 ! now with a copy of everthing as UCS4 the append will work uline = u1 // u2 ! now append together the two strings which are now of the same kind write ( stdout , '(a)' ) uline ! write ( stdout , '(A)' ) repeat ( '=' , 80 ) write ( stdout , '(a)' ) 'we can make functions to convert to and from ASCII and UCS4' ! using the same conversions as used by an assign. uline = smiley // ascii_to_ucs4 ( 'ascii string' ) // smiley // ucs4_ 'unicode string' // smiley write ( stdout , '(a)' ) uline ! write ( stdout , '(A)' ) 'unrepresentable characters:' write ( stdout , '(a)' ) 'what about characters that have no equivalent in the other kind?' write ( stdout , '(A)' ) 'conversion by assignment' aline = uline write ( stdout , g ) aline , ' ' , len ( aline ), ' ' , len ( uline ) write ( stdout , '(a)' ) 'conversion by ACHAR/ICHAR:' aline = ucs4_to_ascii ( uline ) ! is \"smiley\" replaced with a character used for errors? write ( stdout , g ) aline , ' ' , len ( aline ), ' ' , len ( uline ) write ( stdout , '(a)' ) 'which character replaces the unrepresentable characters is processor-dependent' write ( stdout , '(a)' ) 'and might be unprintable' aline = smiley write ( stdout , '(a,i0,a)' ) 'ADE:' , ichar ( aline ), ' CHARACTER:' , aline write ( stdout , '(A)' ) repeat ( '=' , 80 ) contains function ascii_to_ucs4 ( astr ) result ( ustr ) ! @(#) make the same conversion as an assignment statement from ASCII to UCS4 character ( len =* , kind = ascii ), intent ( in ) :: astr character ( len = len ( astr ), kind = ucs4 ) :: ustr integer :: i do i = 1 , len ( astr ) ustr ( i : i ) = achar ( iachar ( astr ( i : i )), kind = ucs4 ) enddo end function ascii_to_ucs4 function ucs4_to_ascii ( ustr ) result ( astr ) ! @(#) make the same conversion as an assignment statement from UCS4 o ASCII character ( len =* , kind = ucs4 ), intent ( in ) :: ustr character ( len = len ( ustr ), kind = ascii ) :: astr integer :: i do i = 1 , len ( ustr ) astr ( i : i ) = achar ( iachar ( ustr ( i : i )), kind = ascii ) enddo end function ucs4_to_ascii end program concatenate","tags":"","url":"sourcefile/concatenate.f90.html"},{"title":"internal_io.f90 – M_time","text":"Source Code program internal_io use iso_fortran_env , only : stdout => output_unit implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = 1 , kind = ucs4 ) :: glyph character ( len =* ), parameter :: all = '(*(g0))' character ( len = :, kind = ascii ), allocatable :: aline character ( len = :, kind = ascii ), allocatable :: astr character ( len = :, kind = ucs4 ), allocatable :: uline character ( len = :, kind = ucs4 ), allocatable :: ustr integer :: i open ( stdout , encoding = 'UTF-8' ) print all , 'unicode UCS-4 string' ustr = ucs4_ 'Hello World and Ni Hao -- ' // char ( int ( z '4F60' ), ucs4 ) // char ( int ( z '597D' ), ucs4 ) write ( * , * ) ustr print all , 'length  :' , len ( ustr ) print all , 'bytes   :' , storage_size ( ustr ) / 8 print all , 'ASCII bytes' astr = 'Hello World and Ni Hao -- 你好' write ( * , * ) astr print all , 'length  :' , len ( astr ) print all , 'bytes   :' , storage_size ( astr ) / 8 ! SHOULD WRITE INTO ASCII CREATE RAW UTF8 OR WHAT? print all , 'UCS4 characters written to ASCII internal file' aline = repeat ( ' ' , len ( ustr )) write ( aline , all ) ustr aline = trim ( aline ) print all , 'length        :' , len ( aline ) print all , 'bytes         :' , storage_size ( aline ) / 8 print all , aline ! SHOULD WRITE INTO UCS4 DO ANYTHING DIFFERENT? print all print all , 'UCS4 characters written to UCS4 internal file' uline = repeat ( ' ' , len ( ustr )) write ( uline , all ) ustr uline = trim ( uline ) print all , 'length        :' , len ( uline ) print all , 'bytes         :' , storage_size ( uline ) / 8 print all , uline ! SHOULD WRITE INTO ASCII CREATE RAW UTF8 OR WHAT? print all , 'ASCII characters into ASCII internal file' aline = repeat ( ' ' , len ( astr )) write ( aline , all ) astr aline = trim ( aline ) print all , 'length        :' , len ( aline ) print all , 'bytes         :' , storage_size ( aline ) / 8 print all , aline ! SHOULD WRITE INTO UCS4 DO ANYTHING DIFFERENT? print all print all , 'ASCII characters into UCS4 internal file' uline = repeat ( ' ' , len ( astr )) write ( uline , all ) astr uline = trim ( uline ) print all , 'length        :' , len ( uline ) print all , 'bytes         :' , storage_size ( uline ) / 8 print all , uline write ( stdout , all )( ichar ( uline ( i : i )), \",\" , i = 1 , len ( uline )) print all , 'And back again' write ( stdout , all ) 'before:' , astr write ( stdout , all )( ichar ( astr ( i : i )), \",\" , i = 1 , len ( astr )) read ( uline , '(a)' ) astr write ( stdout , all ) 'after:' , astr write ( stdout , all )( ichar ( astr ( i : i )), \",\" , i = 1 , len ( astr )) end program internal_io","tags":"","url":"sourcefile/internal_io.f90.html"},{"title":"count_glyphs.f90 – M_time","text":"Source Code program count_glyphs ! @(#) read a utf-8 file and write it out with lines prefixed with glyph count of the line use , intrinsic :: iso_fortran_env , only : output_unit , input_unit implicit none intrinsic selected_char_kind intrinsic is_iostat_end intrinsic len_trim integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: i integer :: iostat character ( len = 4096 , kind = ucs4 ) :: uline ! specifies maximum line length of 4096 glyphs not bytes character ( len = 255 ) :: iomsg open ( input_unit , encoding = 'UTF-8' ) open ( output_unit , encoding = 'UTF-8' ) do read ( input_unit , '(a)' , iostat = iostat , iomsg = iomsg ) uline if ( iostat . eq . 0 ) then length = len_trim ( uline ) write ( output_unit , '(i9,\": \",a)' ) length , uline (: length ) elseif ( is_iostat_end ( iostat )) then exit else ! does the message have to be converted to ucs-4? write ( output_unit , g ) '<ERROR>' , trim ( iomsg ) exit endif enddo end program count_glyphs","tags":"","url":"sourcefile/count_glyphs.f90.html"},{"title":"test_for_iso_10646.f90 – M_time","text":"Source Code program test_for_iso_10646 use iso_fortran_env , only : output_unit implicit none intrinsic selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) open ( output_unit , encoding = 'utf-8' ) write ( * , * ) 'Smiling face with open mouth' , char ( int ( z '1F603' ), kind = ucs4 ) ! 😃 end program test_for_iso_10646","tags":"","url":"sourcefile/test_for_iso_10646.f90.html"},{"title":"test_M_utf8.f90 – M_time","text":"Source Code program test_M_utf8 use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 , ucs4_to_utf8 implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) character ( len =* ), parameter :: g0 = '(*(g0))' character ( len =* ), parameter :: gx = '(*(g0,1x))' ! character ( len =* ), parameter :: upagain = \"七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。\" ! Romanization: ! Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! \"Fall seven times, stand up eight. Even if you fall down, you will get up again. Don't be discouraged, just keep walking forward.\" ! character ( len = 1 , kind = ucs4 ) :: stop character ( len = :, kind = ucs4 ), allocatable :: ustr character ( len = :), allocatable :: astr integer :: total integer :: err ! OUTPUT:七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。 character ( len =* , kind = ucs4 ), parameter :: boz = & char ( int ( z '4E03' ), kind = ucs4 ) // char ( int ( z '8EE2' ), kind = ucs4 ) // char ( int ( z '3073' ), kind = ucs4 ) // & char ( int ( z '516B' ), kind = ucs4 ) // char ( int ( z '8D77' ), kind = ucs4 ) // char ( int ( z '304D' ), kind = ucs4 ) // & char ( int ( z '3002' ), kind = ucs4 ) // char ( int ( z '8EE2' ), kind = ucs4 ) // char ( int ( z '3093' ), kind = ucs4 ) // & char ( int ( z '3067' ), kind = ucs4 ) // char ( int ( z '3082' ), kind = ucs4 ) // char ( int ( z '307E' ), kind = ucs4 ) // & char ( int ( z '305F' ), kind = ucs4 ) // char ( int ( z '7ACB' ), kind = ucs4 ) // char ( int ( z '3061' ), kind = ucs4 ) // & char ( int ( z '4E0A' ), kind = ucs4 ) // char ( int ( z '304C' ), kind = ucs4 ) // char ( int ( z '308B' ), kind = ucs4 ) // & char ( int ( z '3002' ), kind = ucs4 ) // char ( int ( z '304F' ), kind = ucs4 ) // char ( int ( z '3058' ), kind = ucs4 ) // & char ( int ( z '3051' ), kind = ucs4 ) // char ( int ( z '305A' ), kind = ucs4 ) // char ( int ( z '306B' ), kind = ucs4 ) // & char ( int ( z '524D' ), kind = ucs4 ) // char ( int ( z '3092' ), kind = ucs4 ) // char ( int ( z '5411' ), kind = ucs4 ) // & char ( int ( z '3044' ), kind = ucs4 ) // char ( int ( z '3066' ), kind = ucs4 ) // char ( int ( z '6B69' ), kind = ucs4 ) // & char ( int ( z '3044' ), kind = ucs4 ) // char ( int ( z '3066' ), kind = ucs4 ) // char ( int ( z '3044' ), kind = ucs4 ) // & char ( int ( z '3053' ), kind = ucs4 ) // char ( int ( z '3046' ), kind = ucs4 ) // char ( int ( z '3002' ), kind = ucs4 ) total = 0 write ( * , g0 ) 'utf8_to_ucs4' ustr = utf8_to_ucs4 ( upagain ) write ( * , g0 ) 'if file is not open for utf-8 encoding automatic conversion does not occur' write ( * , g0 ) 'utf8:' , upagain ! these are the bytes to represent the utf-8 characters write ( * , g0 ) 'ucs4:' , ustr ! this is 4-byte unicode that needs converted. Does it print as noise or all \"?\"? write ( * , g0 ) write ( * , g0 ) 'encoding can be altered on an open file' open ( output_unit , encoding = 'UTF-8' ) write ( * , g0 ) 'utf8:' , upagain write ( * , g0 ) 'ucs4:' , ustr ! so this should get \"automatically\" printed properly now write ( * , g0 ) stop = ustr ( 7 : 7 ) call checkit ( 'check len() is 36 :' , len ( ustr ) == 36 ) call checkit ( 'check index       :' , index ( ustr , stop , kind = ucs4 , back = . false .) == 7 ) call checkit ( 'check index       :' , index ( ustr , stop , back = . true ., kind = ucs4 ) == len ( ustr ) ) call checkit ( 'storage_size      :' , storage_size ( ustr ) == len ( ustr ) * 4 * 8 ) write ( * , g0 ) '## ucs4_to_utf8' write ( * , g0 ) write ( * , g0 ) 'boz=' , boz write ( * , g0 ) 'converted by external routine:' , ucs4_to_utf8 ( boz ) ! it is converted by the routine write ( * , g0 ) 'converted because file is encoded to utf-8:' , boz ! converted by standard Fortran ! standard method. Note ASCII one-byte characters become 4-byte characters, but multi-byte characters are not recognized ustr = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) astr = ucs4_to_utf8 ( ustr , err ) call checkit ( 'convert to ASCII bytes representing utf8' , astr == 'Hello World and Ni Hao -- 你好' ) if ( total . ne . 0 ) then write ( * , g0 ) total , 'failures' stop 1 endif contains subroutine checkit ( label , test ) character ( len =* ), intent ( in ) :: label logical , intent ( in ) :: test write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label if (. not . test ) total = total + 1 end subroutine checkit end program test_M_utf8","tags":"","url":"sourcefile/test_m_utf8.f90.html"},{"title":"multi_line.f90 – M_time","text":"Source Code program multi_line use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) integer :: i , j , longest character ( len = 3 , kind = ucs4 ) :: line character ( len = 255 ), parameter :: upagain ( 3 ) = [ character ( len = 255 ) :: & \"七転び八起き。\" , & \"転んでもまた立ち上がる。\" , & \"くじけずに前を向いて歩いていこう。\" ] ! ! Romanization: ! Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! \"Fall seven times, stand up eight. Even if you fall down, you will get up again. Don't be discouraged, just keep walking forward.\" ! character ( len = 4 * len ( upagain ), kind = ucs4 ) :: ustr ( size ( upagain )) open ( output_unit , encoding = 'UTF-8' ) ! convert pseudo-utf-8 ascii to actual Fortran ucs4 unicode longest = 0 ! get longest trimmed line do i = 1 , size ( upagain ) ustr ( i ) = utf8_to_ucs4 ( upagain ( i )) longest = max ( longest , len_trim ( ustr ( i ))) enddo write ( output_unit , * ) write ( output_unit , * ) 'longest=' , longest write ( output_unit , * )( trim ( ustr ( i )), i = 1 , size ( ustr )) write ( output_unit , * ) ! does not work too well if not a fixed-space font, but even when fixed-spaced having problems in mintty anyway, at least do i = 1 , longest ! not lining up write ( output_unit , '(*(A))' ) ( ustr ( j )( i : i ), j = size ( upagain ), 1 , - 1 ) ! numbers for T seems to be for ASCII bytes !write(output_unit,'(T1,A,T5,A,T9,A)') (ustr(j)(i:i),j=1,size(upagain)) !line=ustr(3)(i:i)//ustr(2)(i:i)//ustr(1)(i:i) !write(*,*)line enddo do i = 1 , longest ! not lining up write ( output_unit , '(*(A))' ) ( ustr ( j )( i : i ), j = 1 , size ( upagain )) enddo end program multi_line","tags":"","url":"sourcefile/multi_line.f90.html"},{"title":"supported.f90 – M_time","text":"Source Code program demo_selected_char_kind use iso_fortran_env implicit none intrinsic date_and_time , selected_char_kind ! set some aliases for common character kinds ! as the numbers can vary from platform to platform integer , parameter :: default = selected_char_kind ( \"default\" ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) integer , parameter :: utf8 = selected_char_kind ( 'utf-8' ) ! assuming ASCII and UCS4 are supported (ie. not equal to -1) ! define some string variables character ( len = 26 , kind = ascii ) :: alphabet character ( len = 30 , kind = ucs4 ) :: hello_world character ( len = 30 , kind = ucs4 ) :: string character ( len =* ), parameter :: not_ascii = \"ľščťžýáßĄĘ®™√🙂\" character ( len = :, kind = ucs4 ), allocatable :: corrected integer :: i write ( * , * ) 'ASCII     ' ,& & merge ( 'Supported    ' , 'Not Supported' , ascii /= - 1 ) write ( * , * ) 'ISO_10646 ' ,& & merge ( 'Supported    ' , 'Not Supported' , ucs4 /= - 1 ) write ( * , * ) 'UTF-8     ' ,& & merge ( 'Supported    ' , 'Not Supported' , utf8 /= - 1 ) if ( default . eq . ascii ) then write ( * , * ) 'ASCII is the default on this processor' endif ! for constants the kind precedes the value, somewhat like a ! BOZ constant alphabet = ascii_ \"abcdefghijklmnopqrstuvwxyz\" write ( * , * ) alphabet hello_world = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) ! an encoding option is required on OPEN for non-default I/O if ( ucs4 /= - 1 ) then open ( output_unit , encoding = 'UTF-8' ) write ( * , * ) trim ( hello_world ) else write ( * , * ) 'cannot use utf-8' endif call create_date_string ( string ) write ( * , * ) trim ( string ) write ( * , * ) 'NOT_ASCII:' , not_ascii write ( * , * ) 'LEN NOT_ASCII:' , len ( not_ascii ) write ( * , * ) 'STORAGE_SIZE:' , storage_size ( not_ascii ) corrected = utf8_to_utf32 ( not_ascii ) write ( * , * ) 'CORRECTED:' , corrected write ( * , * ) 'LEN CORRECTED:' , len ( corrected ) write ( * , * ) 'STORAGE_SIZE:' , storage_size ( corrected ) do i = 1 , len ( corrected ) write ( * , '(\"z''\",z0,\"''\")' ) corrected ( i : i ) enddo contains ! The following produces a Japanese date stamp. subroutine create_date_string ( string ) intrinsic date_and_time , selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = 1 , kind = ucs4 ), parameter :: & nen = char ( int ( z '5e74' ), ucs4 ), & ! year gatsu = char ( int ( z '6708' ), ucs4 ), & ! month nichi = char ( int ( z '65e5' ), ucs4 ) ! day character ( len = * , kind = ucs4 ) string integer values ( 8 ) call date_and_time ( values = values ) write ( string , 101 ) values ( 1 ), nen , values ( 2 ), gatsu , values ( 3 ), nichi 101 format ( * ( i0 , a )) end subroutine create_date_string function utf8_to_utf32 ( string ) result ( corrected ) character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = 255 , kind = ucs4 ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) string rewind ( lun ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) open ( output_unit , encoding = 'UTF-8' ) end function utf8_to_utf32 end program demo_selected_char_kind","tags":"","url":"sourcefile/supported.f90.html"},{"title":"asciiset.f90 – M_time","text":"Source Code program asciiset use iso_fortran_env , only : stdout => output_unit use M_utf8 , only : utf8_to_ucs4 , utf8_to_ucs4_via_io !utf8_to_ucs4,        ucs4_to_utf8 !utf8_to_codepoints,  codepoints_to_utf8 !utf8_to_ucs4_via_io, ucs4_to_utf8_via_io !ascii_to_ucs4,       ucs4_to_ascii implicit none intrinsic selected_char_kind integer , parameter :: default = selected_char_kind ( \"default\" ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len = :), allocatable :: aline character ( len = :, kind = ucs4 ), allocatable :: uline character ( len = 1 , kind = ucs4 ), allocatable :: glyph (:) integer :: i integer :: nerr ! Do the extended character set values change from ADE 128 to 255 ! depending on the file encoding? By the standard, I think they ! should all become a character indicating the character is not ! valid(?). Check on screen and when redirected to file. Doing latin ! or latin1 or latin2 conversion would make sense as well. write ( stdout , '(a)' ) 'default encoding default kind:' write ( stdout , '(10(g0,1x,g0,1x))' )( char ( i ), i = 0 , 255 ) write ( stdout , '(a)' ) 'default encoding kind=ascii:' write ( stdout , '(10(g0,1x,g0,1x))' )( char ( i , kind = ascii ), i = 0 , 255 ) write ( stdout , '(a)' ) 'explicitly default encoding default kind:' open ( stdout , encoding = 'DEFAULT' ) write ( stdout , '(10(g0,1x,g0,1x))' )( char ( i ), i = 0 , 255 ) write ( stdout , '(a)' ) 'default encoding kind ucs4:' open ( stdout , encoding = 'UTF-8' ) write ( stdout , '(10(g0,1x,g0,1x))' )( char ( i ), i = 0 , 255 ) write ( stdout , '(10(g0,1x,g0,1x))' )( char ( i , kind = ucs4 ), i = 0 , 255 ) aline = repeat ( ' ' , 256 ) write ( aline , '(256a1)' ) ( char ( i ), i = 0 , 255 ) write ( stdout , '(a)' ) 'utf8_to_ucs4_via_io:' write ( stdout , '(10(g0,1x,g0,1x))' ) utf8_to_ucs4_via_io ( aline ) write ( stdout , '(a)' ) 'utf8_to_ucs4:' write ( stdout , '(10(g0,1x,g0,1x))' ) utf8_to_ucs4 ( aline ) end program asciiset","tags":"","url":"sourcefile/asciiset.f90.html"},{"title":"backslash_escape.f90 – M_time","text":"Source Code program backslash_escape use , intrinsic :: iso_fortran_env , only : output_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( kind = ucs4 , len = :), allocatable :: str ! EXTENSION: str = ucs4_ 'Unicode character: \\u263B' open ( output_unit , encoding = 'utf-8' ) print '(a)' , str print '(a)' , ucs4_ 'Unicode character: \\U0000263B' end program backslash_escape","tags":"","url":"sourcefile/backslash_escape.f90.html"},{"title":"bom_ucs4.f90 – M_time","text":"Source Code program bom_exe ! ! create a Fortran source file starting with a utf-8 BOM to see if your ! compiler will compile it or fail because a character is not in the ! Fortran character set outside of a comment or literal string ! use iso_fortran_env , only : stdout => output_unit implicit none intrinsic selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* , kind = ucs4 ), parameter :: U_bom = char ( int ( z 'FEFF' ), kind = ucs4 ) open ( stdout , encoding = 'UTF-8' ) write ( stdout , '(a)' , advance = 'no' ) U_bom write ( stdout , '(a)' ) & ucs4_ 'program testit ! Unicode BOM encoded to utf-8 bytes by Fortran' ,& ucs4_ '   write(*,*)\"File starts with BOM from UCS-4 write!\"' ,& ucs4_ 'end program testit' end program bom_exe","tags":"","url":"sourcefile/bom_ucs4.f90.html"},{"title":"supported.f90 – M_time","text":"Source Code program supported ! @(#) report if ISO_10646 is supported use iso_fortran_env , only : output_unit , character_kinds implicit none intrinsic selected_char_kind integer :: i integer :: iostat integer , parameter :: default = selected_char_kind ( \"default\" ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) write ( * , * ) 'Supported character kinds' , character_kinds write ( * , * ) 'ASCII     ' , merge ( 'Supported    ' , 'Not Supported' , ascii /= - 1 ), 'KIND=' , ascii write ( * , * ) 'ISO_10646 ' , merge ( 'Supported    ' , 'Not Supported' , ucs4 /= - 1 ), 'KIND=' , ucs4 write ( * , * ) 'DEFAULT   ' , merge ( 'Supported    ' , 'Not Supported' , default /= - 1 ), 'KIND=' , default if ( default . eq . ascii ) then write ( * , * ) 'ASCII is the same as the default on this processor' endif open ( output_unit , encoding = 'utf-8' , iostat = iostat ) if ( iostat . ne . 0 ) then write ( * , * ) 'utf-8 encoding not supported' else write ( * , * ) '7-bit ASCII' write ( * , '(16(i3,1x,a,1x))' )( i , char ( i , kind = ucs4 ), i = 0 , 127 ) write ( * , * ) 'remaining 8-bit ASCII' write ( * , '(16(i3,1x,a,1x))' )( i , char ( i , kind = ucs4 ), i = 128 , 255 ) endif end program supported","tags":"","url":"sourcefile/supported.f90~2.html"},{"title":"ascii_round_trip.f90 – M_time","text":"Source Code program demo_selected_char_kind ! @(#) report if ISO_10646 is supported use iso_fortran_env implicit none intrinsic selected_char_kind integer :: i integer :: iostat integer , parameter :: default = selected_char_kind ( \"default\" ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) write ( * , * ) write ( * , * ) 'print 1-byte values (from 0 to 255) as characters:' write ( * , * ) ' only 0 to 127 is defined in ASCII, 128-255' write ( * , * ) ' often used for extended ASCII such as latin1 or latin2 encoding, or extended' write ( * , * ) ' characters such as box characters. If your default output is utf-8 values above' write ( * , * ) ' 127 should be a question mark or a shaded box' !  ENCODING= might not be supported open ( output_unit , encoding = 'utf-8' , iostat = iostat ) if ( iostat . ne . 0 ) then write ( * , * ) 'utf-8 encoding not supported' else write ( * , '(10(i3,1x,a,1x))' )( i , char ( i , kind = ucs4 ), i = 0 , 255 ) endif write ( * , * ) write ( * , * ) 'printing the bytes directly' write ( * , * ) 'with encoding=\"ASCII\"' open ( output_unit , encoding = 'ascii' , iostat = iostat ) write ( * , * ) 'ADE:' write ( * , '(10(i3,1x,a,1x))' )( i , i , i = 0 , 255 ) write ( * , * ) 'CHAR():' write ( * , '(10(i3,1x,a,1x))' )( i , char ( i ), i = 0 , 255 ) write ( * , * ) 'ACHAR():' write ( * , '(10(i3,1x,a,1x))' )( i , achar ( i ), i = 0 , 255 ) write ( * , * ) 'UCS-4 with encoding=\"UTF-8\"' open ( output_unit , encoding = 'utf-8' , iostat = iostat ) write ( * , '(10(i3,1x,a,1x))' )( i , char ( i , kind = ucs4 ), i = 0 , 255 ) write ( * , * ) 'with encoding=\"UTF-8\"' open ( output_unit , encoding = 'utf-8' , iostat = iostat ) write ( * , '(10(i3,1x,a,1x))' )( i , i , i = 0 , 255 ) write ( * , * ) 'Smiling face with open mouth' , char ( int ( z '1F603' ), kind = ucs4 ) ! 😃 write ( * , * ) 'Smiling face with open mouth' , char ([ int ( z 'F0' ), int ( z '9F' ), int ( z '98' ), int ( z '83' )], kind = ascii ) ! 😃 end program demo_selected_char_kind","tags":"","url":"sourcefile/ascii_round_trip.f90.html"},{"title":"euro.f90 – M_time","text":"Source Code program euro use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stdin => input_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: g5 = '(*(t3,g0,t9,g0,t16,g0,t22,g0))' character ( len = 1 ) :: euro0 = '€' character ( len =* ), parameter :: euro00 = '€' character ( len = 1 , kind = ucs4 ) :: euro1 = '€' character ( len = 1 , kind = ucs4 ) :: euro2 = ucs4_ '€' character ( len = 1 , kind = ucs4 ) :: euro3 = char ( int ( z '20AC' ), kind = ucs4 ) write ( stdout , g5 ) 'OUTPUT  LEN    BYTES    KIND' open ( stdout , encoding = 'utf-8' ) write ( stdout , g5 ) euro0 , len ( euro0 ), storage_size ( euro0 ) / 8 , kind ( euro0 ) write ( stdout , g5 ) euro00 , len ( euro00 ), storage_size ( euro00 ) / 8 , kind ( euro00 ) write ( stdout , g5 ) euro1 , len ( euro1 ), storage_size ( euro1 ) / 8 , kind ( euro1 ) write ( stdout , g5 ) euro2 , len ( euro2 ), storage_size ( euro2 ) / 8 , kind ( euro2 ) write ( stdout , g5 ) euro3 , len ( euro3 ), storage_size ( euro3 ) / 8 , kind ( euro3 ) end program euro","tags":"","url":"sourcefile/euro.f90.html"},{"title":"bom_bytes.f90 – M_time","text":"Source Code program bom_exe ! ! create a Fortran source file starting with a utf-8 BOM to see if your ! compiler will compile it or fail because a character is not in the ! Fortran character set outside of a comment or literal string ! use iso_fortran_env , only : stdout => output_unit implicit none character ( len =* ), parameter :: & & A_bom = char ( int ( z 'EF' )) // char ( int ( z 'BB' )) // char ( int ( z 'BF' )) write ( stdout , '(a)' , advance = 'no' ) A_bom write ( stdout , '(a)' ) & 'program testit ! Unicode BOM as utf-8 bytes' ,& '   write(*,*)\"File starts with BOM from \"\"bytes\"\" write!\"' ,& 'end program testit' end program bom_exe","tags":"","url":"sourcefile/bom_bytes.f90.html"},{"title":"boz.f90 – M_time","text":"Source Code program multi_line use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) integer :: i , j , longest character ( len = 3 , kind = ucs4 ) :: u3 character ( len = 255 ), parameter :: upagain ( 3 ) = [ character ( len = 255 ) :: & \"七転び八起き。\" , & \"転んでもまた立ち上がる。\" , & \"くじけずに前を向いて歩いていこう。\" ] character ( len = 4 * len ( upagain ), kind = ucs4 ) :: ustr ( size ( upagain )) character ( len = :), allocatable :: aline character ( len = :, kind = ucs4 ), allocatable :: uline ! ! Romanization: !    Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation !    \"Fall seven times, stand up eight. !    Even if you fall down, you will get up again. !    Don't be discouraged, just keep walking forward.\" ! open ( output_unit , encoding = 'UTF-8' ) ! convert pseudo-utf-8 ascii to actual Fortran ucs4 unicode longest = 0 ! get longest trimmed line do i = 1 , size ( upagain ) ustr ( i ) = utf8_to_ucs4 ( upagain ( i )) longest = max ( longest , len_trim ( ustr ( i ))) write ( * , * ) 'LEN=' , len_trim ( ustr ( i )) enddo write ( output_unit , * ) 'longest=' , longest write ( output_unit , * ) write ( output_unit , * )( trim ( ustr ( i )), i = 1 , size ( ustr )) write ( output_unit , * ) write ( output_unit , '(A)' ) ( trim ( ustr ( i )), i = 1 , size ( ustr )) write ( output_unit , '(*(z8.8))' ) (( ustr ( i )( j : j ), j = 1 , len_trim ( ustr ( i ))), i = 1 , size ( ustr )) write ( output_unit , * ) aline = '& &00004E0300008EE2000030730000516B00008D770000304D0000300200008EE20000309300003067& &000030820000307E0000305F00007ACB0000306100004E0A0000304C0000308B000030020000304F& &00003058000030510000305A0000306B0000524D0000309200005411000030440000306600006B69& &000030440000306600003044000030530000304600003002' allocate ( character ( len = len ( aline ) / 8 , kind = ucs4 ) :: uline ) !   read(aline,'(z288)') uline read ( aline , '(*(z8.8))' ) ( uline ( i : i ), i = 1 , len ( uline )) write ( output_unit , * ) uline end program multi_line","tags":"","url":"sourcefile/boz.f90.html"},{"title":"M_unicode.f90 – M_time","text":"Source Code module M_unicode ! Unicode-related procedures not requiring compiler support of ISO-10646 ! first presented in https://fortran-lang.discourse.group/t/how-to-use-utf-8-in-gfortran/9949 ! including enhancements and latin support from Francois Jacq, 2025-08 ! use iso_fortran_env , only : error_unit , stderr => error_unit implicit none private public :: utf8_to_codepoints , codepoints_to_utf8 public :: isolatin_to_unicode , unicode_to_isolatin public :: utf8_to_isolatin , isolatin_to_utf8 private :: a2s , s2a public :: unicode_type public :: assignment ( = ) interface utf8_to_codepoints module procedure utf8_to_codepoints_str , utf8_to_codepoints_chars end interface utf8_to_codepoints interface codepoints_to_utf8 module procedure codepoints_to_utf8_str , codepoints_to_utf8_chars end interface codepoints_to_utf8 ! Assign a character sequence to a string. interface assignment ( = ) module procedure :: assign_str_char module procedure :: assign_str_codes end interface assignment ( = ) interface character module procedure :: char_str module procedure :: char_str_range module procedure :: char_str_range_step end interface character public :: character interface adjustl ; module procedure :: adjustl_str ; end interface adjustl interface adjustr ; module procedure :: adjustr_str ; end interface adjustr interface len ; module procedure :: len_str ; end interface len interface len_trim ; module procedure :: len_trim_str ; end interface len_trim interface repeat ; module procedure :: repeat_str ; end interface repeat interface trim ; module procedure :: trim_str ; end interface trim public :: adjustl public :: adjustr public :: len public :: len_trim public :: repeat public :: trim interface index ; module procedure :: index_str_str , index_str_char , index_char_str ; end interface index public :: index interface lle ; module procedure :: lle_str_str , lle_str_char , lle_char_str ; end interface lle interface llt ; module procedure :: llt_str_str , llt_str_char , llt_char_str ; end interface llt interface lne ; module procedure :: lne_char_str , lne_str_char , lne_str_str ; end interface lne interface leq ; module procedure :: leq_char_str , leq_str_char , leq_str_str ; end interface leq interface lgt ; module procedure :: lgt_str_str , lgt_str_char , lgt_char_str ; end interface lgt interface lge ; module procedure :: lge_str_str , lge_str_char , lge_char_str ; end interface lge interface operator ( <= ); module procedure :: lle_str_str , lle_str_char , lle_char_str ; end interface operator ( <= ) interface operator ( < ); module procedure :: llt_str_str , llt_str_char , llt_char_str ; end interface operator ( < ) interface operator ( /= ); module procedure :: lne_char_str , lne_str_char , lne_str_str ; end interface operator ( /= ) interface operator ( == ); module procedure :: leq_char_str , leq_str_char , leq_str_str ; end interface operator ( == ) interface operator ( > ); module procedure :: lgt_str_str , lgt_str_char , lgt_char_str ; end interface operator ( > ) interface operator ( >= ); module procedure :: lge_str_str , lge_str_char , lge_char_str ; end interface operator ( >= ) interface operator ( // ); module procedure :: concat_str_str , concat_str_char , concat_char_str ; end interface operator ( // ) public :: lle public :: llt public :: lne public :: leq public :: lgt public :: lge public :: operator ( <= ) public :: operator ( < ) public :: operator ( /= ) public :: operator ( == ) public :: operator ( > ) public :: operator ( >= ) public :: operator ( // ) type :: unicode_type ! Unicode string type holding an arbitrary sequence of integer codes. !sequence ! not used for storage association; a kludge to prevent extending this type. private integer , allocatable :: codes (:) contains ! METHODS: procedure :: character => oop_character procedure :: bytes => oop_bytes procedure :: adjustl => oop_adjustl procedure :: adjustr => oop_adjustr procedure :: trim => oop_trim procedure :: len => oop_len procedure :: len_trim => oop_len_trim procedure :: index => oop_index !DECLARATION OF OVERLOADED OPERATORS FOR TYPE(UNICODE_TYPE) procedure , private :: eq => oop_eq !   generic           :: operator(==) => eq !   procedure,private :: ge => oop_ge !   generic           :: operator(>=) => oop_ge !   procedure,private :: lt => oop_lt !   generic           :: operator(<)  => oop_lt !   procedure,private :: gt => oop_gt !   generic           :: operator(>)  => oop_gt !   procedure,private :: le => oop_le !   generic           :: operator(<=) => oop_le !   procedure,private :: ne => oop_ne !   generic           :: operator(/=) => oop_ne !   procedure,private :: string_append_value !   generic           :: operator(//) => string_append_value end type unicode_type ! Constructor for new string instances interface unicode_type elemental module function new_str ( string ) result ( new ) character ( len =* ), intent ( in ), optional :: string type ( unicode_type ) :: new end function new_str module function new_codes ( codes ) result ( new ) integer , intent ( in ) :: codes (:) type ( unicode_type ) :: new end function new_codes end interface unicode_type ! space U+0020 32 Common Basic Latin Separator, Most common (normal ! ASCII space) ! ! no-break space U+00A0 160 Common Latin-1 Supplement Separator, ! Non-breaking space: identical to U+0020, but not a point at which a line ! may be broken. ! ! en quad U+2000 8192 General Punctuation Separator, Width of one en. U+2002 ! is canonically equivalent to this character; U+2002 is preferred. ! ! em quad U+2001 8193   Common General Punctuation Separator, ! Also known as \"mutton quad\". Width of one em. U+2003 is ! canonically equivalent to this character; U+2003 is preferred. ! ! en space U+2002 8194   Common General Punctuation Separator, ! space Also known as \"nut\". Width of one en. U+2000 En Quad is ! canonically equivalent to this character; U+2002 is preferred. ! ! em space U+2003 8195  Common General Punctuation Separator, ! space Also known as \"mutton\". Width of one em. U+2001 Em Quad is ! canonically equivalent to this character; U+2003 is preferred. ! ! three-per-em space U+2004 8196 Common General Punctuation Separator, ! Also known as \"thick space\". One third of an em wide. ! ! four-per-em space U+2005 8197 Common General Punctuation Separator, ! space Also known as \"mid space\". One fourth of an em wide. ! ! six-per-em space U+2006 8198 Common General Punctuation Separator, ! space One sixth of an em wide. In computer typography, sometimes equated ! to U+2009. ! ! figure space U+2007 8199 Common General Punctuation Separator, In fonts ! with monospaced digits, equal to the width of one digit. ! ! punctuation space U+2008 8200 Common General Punctuation Separator, ! As wide as the narrow punctuation in a font, i.e. the advance width of ! the period or comma. ! ! thin space U+2009 8201 Common General Punctuation Separator, one-fifth ! (sometimes one-sixth) of an em wide.  Recommended for use as a thousands ! separator for measures made with SI units. Unlike U+2002 to U+2008, ! its width may get adjusted in typesetting. ! ! hair space U+200A 8202 Common General Punctuation Separator, space ! Thinner than a thin space. ! ! narrow no-break space U+202F 8239 Common General Punctuation Separator, ! Similar in function to U+00A0 ! ! No-Break Space. When used with Mongolian, its width is usually one third ! of the normal space; in other context, its width sometimes resembles ! that of the Thin Space (U+2009). ! ! medium mathematical space U+205F 8287   Common General Punctuation ! Separator, space MMSP. Used in mathematical formulae. Four-eighteenths ! of an em. In mathematical typography, the widths of spaces are usually ! given in integral multiples of an eighteenth of an em, and 4/18 em ! may be used in several situations, for example between the a and the + ! and between the + and the b in the expression a + b. ! ! ideographic space U+3000 12288 　 Yes No Common CJK Symbols and ! Punctuation Separator, As wide as a CJK character cell (fullwidth). Used, ! for example, in tai tou. integer , parameter :: G_SPACE = 32 integer , parameter :: G_SPACES ( * ) = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine codepoints_to_utf8_chars ( unicode , utf8 , nerr ) integer , intent ( in ) :: unicode (:) character , allocatable , intent ( out ) :: utf8 (:) integer , intent ( out ) :: nerr character ( len = 256 ) :: nerrmsg integer :: i , n_unicode , n_utf8 , cp character , allocatable :: temp_utf8 (:) n_unicode = size ( unicode ) allocate ( temp_utf8 ( 4 * n_unicode )) n_utf8 = 0 nerr = 0 do i = 1 , n_unicode cp = unicode ( i ) select case ( cp ) case ( 0 : 127 ) ! 1 byte : 0xxxxxxx n_utf8 = n_utf8 + 1 temp_utf8 ( n_utf8 ) = char ( cp ) case ( 128 : 2047 ) ! 2 bytes : 110xxxxx 10xxxxxx n_utf8 = n_utf8 + 2 temp_utf8 ( n_utf8 - 1 ) = char ( ior ( 192 , ishft ( cp , - 6 ))) temp_utf8 ( n_utf8 ) = char ( ior ( 128 , iand ( cp , 63 ))) case ( 2048 : 65535 ) ! 3 bytes : 1110xxxx 10xxxxxx 10xxxxxx if ( cp >= 55296 . and . cp <= 57343 ) then nerr = nerr + 1 n_utf8 = n_utf8 + 1 temp_utf8 ( n_utf8 ) = '?' cycle endif n_utf8 = n_utf8 + 3 temp_utf8 ( n_utf8 - 2 ) = char ( ior ( 224 , ishft ( cp , - 12 ))) temp_utf8 ( n_utf8 - 1 ) = char ( ior ( 128 , iand ( ishft ( cp , - 6 ), 63 ))) temp_utf8 ( n_utf8 ) = char ( ior ( 128 , iand ( cp , 63 ))) case ( 65536 : 1114111 ) ! 4 bytes : 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx n_utf8 = n_utf8 + 4 temp_utf8 ( n_utf8 - 3 ) = char ( ior ( 240 , ishft ( cp , - 18 ))) temp_utf8 ( n_utf8 - 2 ) = char ( ior ( 128 , iand ( ishft ( cp , - 12 ), 63 ))) temp_utf8 ( n_utf8 - 1 ) = char ( ior ( 128 , iand ( ishft ( cp , - 6 ), 63 ))) temp_utf8 ( n_utf8 ) = char ( ior ( 128 , iand ( cp , 63 ))) case default nerr = nerr + 1 n_utf8 = n_utf8 + 1 temp_utf8 ( n_utf8 ) = '?' end select enddo allocate ( utf8 ( n_utf8 )) utf8 = temp_utf8 ( 1 : n_utf8 ) end subroutine codepoints_to_utf8_chars !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine utf8_to_codepoints_chars ( utf8 , unicode , nerr ) ! in fact, this routine is also able to decode an ISOLATIN string character , intent ( in ) :: utf8 (:) integer , allocatable , intent ( out ) :: unicode (:) integer , intent ( out ) :: nerr integer :: n_out integer :: i , len8 , b1 , b2 , b3 , b4 integer :: cp , nbytes , nerr0 integer , allocatable :: temp (:) nerr = 0 len8 = size ( utf8 ) i = 1 n_out = 0 allocate ( temp ( len8 )) ! big enough to store all unicode values do while ( i <= len8 ) nerr0 = nerr b1 = ichar ( utf8 ( i )) if ( b1 < 0 ) b1 = b1 + 256 nbytes = 1 select case ( b1 ) case ( 0 : 127 ) cp = b1 case ( 192 : 223 ) if ( i + 1 > len8 ) then nbytes = len8 - i + 1 nerr = nerr + 1 cp = ICHAR ( '?' ) else nbytes = 2 b2 = ichar ( utf8 ( i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 if ( iand ( b2 , 192 ) /= 128 ) then nerr = nerr + 1 cp = ICHAR ( '?' ) else cp = iand ( b1 , 31 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) endif endif case ( 224 : 239 ) if ( i + 2 > len8 ) then nbytes = len8 - i + 1 nerr = nerr + 1 cp = ICHAR ( '?' ) else nbytes = 3 b2 = ichar ( utf8 ( i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 b3 = ichar ( utf8 ( i + 2 )); if ( b3 < 0 ) b3 = b3 + 256 if ( iand ( b2 , 192 ) /= 128 . or . iand ( b3 , 192 ) /= 128 ) then nerr = nerr + 1 cp = ICHAR ( '?' ) else cp = iand ( b1 , 15 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) cp = ishft ( cp , 6 ) + iand ( b3 , 63 ) endif endif case ( 240 : 247 ) if ( i + 3 > len8 ) then nbytes = len8 - i + 1 nerr = nerr + 1 cp = ICHAR ( '?' ) else nbytes = 4 b2 = ichar ( utf8 ( i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 b3 = ichar ( utf8 ( i + 2 )); if ( b3 < 0 ) b3 = b3 + 256 b4 = ichar ( utf8 ( i + 3 )); if ( b4 < 0 ) b4 = b4 + 256 if ( iand ( b2 , 192 ) /= 128 . or . iand ( b3 , 192 ) /= 128 . or . iand ( b4 , 192 ) /= 128 ) then nerr = nerr + 1 cp = ICHAR ( '?' ) else cp = iand ( b1 , 7 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) cp = ishft ( cp , 6 ) + iand ( b3 , 63 ) cp = ishft ( cp , 6 ) + iand ( b4 , 63 ) endif endif case default nerr = nerr + 1 cp = ICHAR ( '?' ) end select if ( nerr0 /= nerr ) then ! This is an invalid UTF-8 start byte. We apply the heuristic ! and interpret it as an ISO-8859-15 character. select case ( b1 ) case ( 164 ); cp = 8364 ! Euro case ( 166 ); cp = 352 ! S caron case ( 168 ); cp = 353 ! s caron case ( 180 ); cp = 381 ! Z caron case ( 184 ); cp = 382 ! z caron case ( 188 ); cp = 338 ! OE case ( 189 ); cp = 339 ! oe case ( 190 ); cp = 376 ! Y trema case default cp = b1 ! For all other chars, the codepoint is the byte value end select nbytes = 1 endif n_out = n_out + 1 temp ( n_out ) = cp i = i + nbytes enddo allocate ( unicode ( n_out )) unicode = temp ( 1 : n_out ) end subroutine utf8_to_codepoints_chars !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine isolatin_to_unicode ( isolatin , unicode , nerr ) character , intent ( in ) :: isolatin (:) integer , allocatable , intent ( out ) :: unicode (:) integer , intent ( out ) :: nerr integer :: i , n , char_code nerr = 0 n = size ( isolatin ) allocate ( unicode ( n )) do i = 1 , n char_code = ichar ( isolatin ( i )) ! Only 8 characters do not correspond to unicode select case ( char_code ) case ( 164 ); unicode ( i ) = 8364 ! Symbol Euro case ( 166 ); unicode ( i ) = 352 ! S caron case ( 168 ); unicode ( i ) = 353 ! s caron case ( 180 ); unicode ( i ) = 381 ! Z caron case ( 184 ); unicode ( i ) = 382 ! z caron case ( 188 ); unicode ( i ) = 338 ! OE majuscule case ( 189 ); unicode ( i ) = 339 ! oe minuscule case ( 190 ); unicode ( i ) = 376 ! Y trema case default unicode ( i ) = char_code end select enddo end subroutine isolatin_to_unicode !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine unicode_to_isolatin ( unicode , isolatin , nerr ) integer , intent ( in ) :: unicode (:) character , allocatable , intent ( out ) :: isolatin (:) integer , intent ( out ) :: nerr integer :: i , n , cp integer :: replacement_count nerr = 0 n = size ( unicode ) allocate ( isolatin ( n )) do i = 1 , n cp = unicode ( i ) select case ( cp ) ! 8 special characters case ( 8364 ); isolatin ( i ) = char ( 164 ) ! Euro case ( 352 ); isolatin ( i ) = char ( 166 ) ! S caron case ( 353 ); isolatin ( i ) = char ( 168 ) ! s caron case ( 381 ); isolatin ( i ) = char ( 180 ) ! Z caron case ( 382 ); isolatin ( i ) = char ( 184 ) ! z caron case ( 338 ); isolatin ( i ) = char ( 188 ) ! OE majuscule case ( 339 ); isolatin ( i ) = char ( 189 ) ! oe minuscule case ( 376 ); isolatin ( i ) = char ( 190 ) ! Y trema case ( 0 : 163 , 165 , 167 , 169 : 179 , 181 : 183 , 185 : 187 , 191 : 255 ) isolatin ( i ) = char ( cp ) case default nerr = nerr + 1 isolatin ( i ) = '?' ! replacement character end select enddo end subroutine unicode_to_isolatin !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine isolatin_to_utf8 ( isolatin , utf8 , nerr ) character , intent ( in ) :: isolatin (:) character , allocatable , intent ( out ) :: utf8 (:) integer , intent ( out ) :: nerr integer , allocatable :: unicode (:) call isolatin_to_unicode ( isolatin , unicode , nerr ) call codepoints_to_utf8 ( unicode , utf8 , nerr ) end subroutine isolatin_to_utf8 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine utf8_to_isolatin ( utf8 , isolatin , nerr ) character , intent ( in ) :: utf8 (:) character , allocatable , intent ( out ) :: isolatin (:) integer , intent ( out ) :: nerr integer , allocatable :: unicode (:) call utf8_to_codepoints ( utf8 , unicode , nerr ) call unicode_to_isolatin ( unicode , isolatin , nerr ) end subroutine utf8_to_isolatin !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure function a2s ( array ) result ( string ) ! @(#) M_strs a2s(3fp) function to copy char array to string character ( len = 1 ), intent ( in ) :: array (:) character ( len = SIZE ( array )) :: string integer :: i forall ( i = 1 : size ( array )) string ( i : i ) = array ( i ) !  string=transfer(array,string) end function a2s !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure function s2a ( string ) RESULT ( array ) ! @(#) M_strs s2a(3fp) function to copy string(1 Clen(string)) to char array character ( len =* ), intent ( in ) :: string character ( len = 1 ) :: array ( len ( string )) integer :: i forall ( i = 1 : len ( string )) array ( i ) = string ( i : i ) !  array=transfer(string,array) end function s2a !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine codepoints_to_utf8_str ( unicode , utf8 , nerr ) integer , intent ( in ) :: unicode (:) character ( len = :), allocatable , intent ( out ) :: utf8 integer , intent ( out ) :: nerr character , allocatable :: utf8_chars (:) nerr = 0 call codepoints_to_utf8_chars ( unicode , utf8_chars , nerr ) utf8 = a2s ( utf8_chars ) end subroutine codepoints_to_utf8_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine utf8_to_codepoints_str ( utf8 , unicode , nerr ) ! in fact, this routine is also able to decode an ISOLATIN string character ( len =* ), intent ( in ) :: utf8 integer , allocatable , intent ( out ) :: unicode (:) integer , intent ( out ) :: nerr character , allocatable :: temp (:) temp = s2a ( utf8 ) call utf8_to_codepoints_chars ( temp , unicode , nerr ) end subroutine utf8_to_codepoints_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Constructor for new string instances from a scalar character value. elemental module function new_str ( string ) result ( new ) character ( len =* ), intent ( in ), optional :: string type ( unicode_type ) :: new integer :: nerr if ( present ( string )) then call utf8_to_codepoints_str ( string , new % codes , nerr ) endif end function new_str ! Constructor for new string instance from a vector integer value. module function new_codes ( codes ) result ( new ) integer , intent ( in ) :: codes (:) type ( unicode_type ) :: new new % codes = codes end function new_codes !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Assign a character sequence to a string. elemental subroutine assign_str_char ( lhs , rhs ) type ( unicode_type ), intent ( inout ) :: lhs character ( len =* ), intent ( in ) :: rhs integer :: nerr call utf8_to_codepoints_str ( rhs , lhs % codes , nerr ) end subroutine assign_str_char ! Assign a character sequence to a string. subroutine assign_str_codes ( lhs , rhs ) type ( unicode_type ), intent ( inout ) :: lhs integer , intent ( in ) :: rhs (:) integer :: nerr lhs % codes = rhs end subroutine assign_str_codes !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Returns the length of the character sequence represented by the string. elemental function len_str ( string ) result ( length ) type ( unicode_type ), intent ( in ) :: string integer :: length if ( allocated ( string % codes )) then length = size ( string % codes ) else length = 0 endif end function len_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Return the character sequence represented by the string. pure function char_str ( string ) result ( aline ) type ( unicode_type ), intent ( in ) :: string character ( len = :), allocatable :: aline integer :: nerr call codepoints_to_utf8_str ( string % codes , aline , nerr ) end function char_str pure function char_str_range ( string , first , last ) result ( aline ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ) :: first integer , intent ( in ) :: last !character(len=last-first+1)    :: aline character ( len = :), allocatable :: aline integer :: nerr call codepoints_to_utf8_str ( string % codes ( first : last ), aline , nerr ) end function char_str_range pure function char_str_range_step ( string , first , last , step ) result ( aline ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ) :: first integer , intent ( in ) :: last integer , intent ( in ) :: step !character(len=last-first+1)    :: aline character ( len = :), allocatable :: aline integer :: nerr call codepoints_to_utf8_str ( string % codes ( first : last : step ), aline , nerr ) end function char_str_range_step !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Repeats the character sequence held by the string by the number of specified copies. ! This method is elemental and returns a scalar character value. elemental function repeat_str ( string , ncopies ) result ( repeated_str ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ) :: ncopies type ( unicode_type ) :: repeated_str integer :: i repeated_str % codes = [( string % codes , i = 1 , ncopies )] end function repeat_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Returns length of character sequence without trailing spaces represented by the string. ! elemental function len_trim_str ( string ) result ( length ) type ( unicode_type ), intent ( in ) :: string integer :: length do length = size ( string % codes ), 1 , - 1 if ( any ( string % codes ( length ). eq . G_SPACES )) cycle exit enddo end function len_trim_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! This method is elemental and returns a scalar character value. elemental function trim_str ( string ) result ( trimmed_str ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ) :: trimmed_str integer :: last last = len_trim_str ( string ) trimmed_str % codes = string % codes (: last ) end function trim_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! right-justify string by moving trailing spaces to beginning of string so length is retained even if spaces are of varied width elemental function adjustr_str ( string ) result ( adjusted ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ) :: adjusted integer :: last integer :: i last = len_trim_str ( string ) adjusted % codes = cshift ( string % codes , - ( size ( adjusted % codes ) - last - 1 )) end function adjustr_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !left-justify string by  moving leading spaces to end of string so length is retained even if spaces are of varied width elemental function adjustl_str ( string ) result ( adjusted ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ) :: adjusted integer :: first integer :: i do first = 1 , size ( string % codes ), 1 if ( any ( string % codes ( first ). eq . G_SPACES )) cycle exit enddo adjusted % codes = cshift ( string % codes , first - 1 ) end function adjustl_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Concatenate two character sequences, LHS, RHS or both can be represented by a byte string or unicode_type. ! elemental function concat_str_str ( lhs , rhs ) result ( lhsrhs ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs type ( unicode_type ) :: lhsrhs lhsrhs % codes = [ lhs % codes , rhs % codes ] end function concat_str_str elemental function concat_str_char ( lhs , rhs ) result ( lhsrhs ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs type ( unicode_type ) :: lhsrhs lhsrhs = unicode_type ( rhs ) lhsrhs % codes = [ lhs % codes , lhsrhs % codes ] end function concat_str_char elemental function concat_char_str ( lhs , rhs ) result ( lhsrhs ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs type ( unicode_type ) :: lhsrhs lhsrhs = unicode_type ( lhs ) lhsrhs % codes = [ lhsrhs % codes , rhs % codes ] end function concat_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Compare two character sequences for non-equality; LHS, RHS or both sequences can be a unicode string or character variable. ! elemental function lne_str_str ( lhs , rhs ) result ( is_equal ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_equal integer :: icount if ( lhs % len_trim (). eq . rhs % len_trim ()) then icount = lhs % len_trim () is_equal = . not . all ( lhs % codes (: icount ) . eq . rhs % codes (: icount ) ) else is_equal = . true . endif end function lne_str_str elemental function lne_str_char ( lhs , rhs ) result ( is_equal ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_equal is_equal = lne_str_str ( lhs , unicode_type ( rhs )) end function lne_str_char elemental function lne_char_str ( lhs , rhs ) result ( is_equal ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_equal is_equal = lne_str_str ( unicode_type ( lhs ), rhs ) end function lne_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Compare two character sequences for equality; LHS, RHS or both sequences can be a unicode string or character variable. ! elemental function leq_str_str ( lhs , rhs ) result ( is_equal ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_equal integer :: icount if ( lhs % len_trim (). eq . rhs % len_trim ()) then icount = lhs % len_trim () is_equal = all ( lhs % codes (: icount ) . eq . rhs % codes (: icount ) ) else is_equal = . false . endif end function leq_str_str elemental function leq_str_char ( lhs , rhs ) result ( is_equal ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_equal is_equal = leq_str_str ( lhs , unicode_type ( rhs )) end function leq_str_char elemental function leq_char_str ( lhs , rhs ) result ( is_equal ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_equal is_equal = leq_str_str ( unicode_type ( lhs ), rhs ) end function leq_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Lexically compare two character sequences for being greater or equal elemental function lge_str_str ( lhs , rhs ) result ( is_lge ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lge integer :: i integer :: llen integer :: rlen llen = len_trim ( lhs ) rlen = len_trim ( rhs ) FOUND : block do i = 1 , min ( llen , rlen ) select case ( lhs % codes ( i ) - rhs % codes ( i )) case ( 0 ); cycle case ( 1 :); is_lge = . true .; exit FOUND case (: - 1 ); is_lge = . false .; exit FOUND end select enddo ! all equal, decide based on difference in length select case ( llen - rlen ) case ( 0 ); is_lge = . true . case ( 1 :); is_lge = . true . case (: - 1 ); is_lge = . false . end select endblock FOUND end function lge_str_str elemental function lge_str_char ( lhs , rhs ) result ( is_lge ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lge is_lge = lge_str_str ( lhs , unicode_type ( rhs )) end function lge_str_char elemental function lge_char_str ( lhs , rhs ) result ( is_lge ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lge is_lge = lge_str_str ( unicode_type ( lhs ), rhs ) end function lge_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Lexically compare two character sequences for being less than or equal elemental function lle_str_str ( lhs , rhs ) result ( is_lle ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lle integer :: i integer :: llen integer :: rlen llen = len_trim ( lhs ) rlen = len_trim ( rhs ) FOUND : block do i = 1 , min ( llen , rlen ) select case ( lhs % codes ( i ) - rhs % codes ( i ) ) case ( 0 ); cycle case ( 1 :); is_lle = . false .; exit FOUND case (: - 1 ); is_lle = . true .; exit FOUND end select enddo ! all equal, decide based on difference in length select case ( llen - rlen ) case (: - 1 ); is_lle = . true . case ( 0 ); is_lle = . true . case ( 1 :); is_lle = . false . end select endblock FOUND end function lle_str_str elemental function lle_str_char ( lhs , rhs ) result ( is_lle ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lle is_lle = lle_str_str ( lhs , unicode_type ( rhs )) end function lle_str_char elemental function lle_char_str ( lhs , rhs ) result ( is_lle ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lle is_lle = lle_str_str ( unicode_type ( lhs ), rhs ) end function lle_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Lexically compare two character sequences for being less than elemental function llt_str_str ( lhs , rhs ) result ( is_llt ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_llt integer :: i integer :: llen integer :: rlen llen = len_trim ( lhs ) rlen = len_trim ( rhs ) FOUND : block do i = 1 , min ( llen , rlen ) select case ( lhs % codes ( i ) - rhs % codes ( i )) case ( 0 ); cycle ; case ( 1 :); is_llt = . false .; exit FOUND case (: - 1 ); is_llt = . true .; exit FOUND end select enddo ! all equal, decide based on difference in length select case ( llen - rlen ) case ( 0 ); is_llt = . false . case ( 1 :); is_llt = . false . case (: - 1 ); is_llt = . true . end select endblock FOUND end function llt_str_str elemental function llt_str_char ( lhs , rhs ) result ( is_llt ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_llt is_llt = llt_str_str ( lhs , unicode_type ( rhs )) end function llt_str_char elemental function llt_char_str ( lhs , rhs ) result ( is_llt ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_llt is_llt = llt_str_str ( unicode_type ( lhs ), rhs ) end function llt_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Lexically compare two character sequences for being greater than elemental function lgt_str_str ( lhs , rhs ) result ( is_lgt ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lgt integer :: i integer :: llen integer :: rlen llen = len_trim ( lhs ) rlen = len_trim ( rhs ) FOUND : block do i = 1 , min ( llen , rlen ) select case ( lhs % codes ( i ) - rhs % codes ( i )) case ( 0 ); cycle ; case ( 1 :); is_lgt = . true .; exit FOUND case (: - 1 ); is_lgt = . false .; exit FOUND end select enddo ! all equal, decide based on difference in length select case ( llen - rlen ) case ( 0 ); is_lgt = . false . case ( 1 :); is_lgt = . true . case (: - 1 ); is_lgt = . false . end select endblock FOUND end function lgt_str_str elemental function lgt_str_char ( lhs , rhs ) result ( is_lgt ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt_str_str ( lhs , unicode_type ( rhs )) end function lgt_str_char elemental function lgt_char_str ( lhs , rhs ) result ( is_lgt ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt_str_str ( unicode_type ( lhs ), rhs ) end function lgt_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! find location of substring within string elemental function index_str_str ( string , substring ) result ( foundat ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: substring integer :: foundat integer :: i integer :: strlen integer :: sublen strlen = string % len () sublen = substring % len () foundat = 0 do i = 1 , strlen - sublen + 1 if ( all ( string % codes ( i : i + sublen - 1 ) . eq . substring % codes ) ) then foundat = i exit endif enddo end function index_str_str elemental function index_str_char ( string , substring ) result ( foundat ) type ( unicode_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring integer :: foundat foundat = index_str_str ( string , unicode_type ( substring )) end function index_str_char elemental function index_char_str ( string , substring ) result ( foundat ) character ( len =* ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: substring integer :: foundat foundat = index_str_str ( unicode_type ( string ), substring ) end function index_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_adjustl ( self ) result ( string_out ) ! ident_12=\"@(#) M_strs oop_adjustl(3f) adjust string to left\" class ( unicode_type ), intent ( in ) :: self type ( unicode_type ) :: string_out string_out = adjustl_str ( self ) end function oop_adjustl !=================================================================================================================================== function oop_adjustr ( self ) result ( string_out ) ! ident_13=\"@(#) M_strs oop_adjustr(3f) adjust string to right\" class ( unicode_type ), intent ( in ) :: self type ( unicode_type ) :: string_out string_out = adjustr_str ( self ) end function oop_adjustr !=================================================================================================================================== function oop_character ( self , first , last , step ) result ( bytes_out ) class ( unicode_type ), intent ( in ) :: self character ( len = :), allocatable :: bytes_out integer , intent ( in ), optional :: first , last , step integer :: start , end , inc type ( unicode_type ) :: temp integer :: i if ( present ( step )) then ; inc = step ; else ; inc = 1 ; endif if ( present ( first )) then ; start = first ; else ; start = 1 ; endif if ( present ( last )) then ; end = last ; else ; end = len ( self ); endif temp = self % codes ( start : end : inc ) bytes_out = char_str ( temp ) end function oop_character !=================================================================================================================================== pure function oop_trim ( self ) result ( string_out ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ) :: string_out string_out = trim ( self ) end function oop_trim !=================================================================================================================================== pure function oop_bytes ( self ) result ( bytes_out ) class ( unicode_type ), intent ( in ) :: self character ( len = :), allocatable :: bytes_out (:) bytes_out = s2a ( char_str ( self )) end function oop_bytes !=================================================================================================================================== pure function oop_len_trim ( self ) result ( len_trim_out ) class ( unicode_type ), intent ( in ) :: self integer :: len_trim_out len_trim_out = len_trim ( self ) end function oop_len_trim !=================================================================================================================================== pure function oop_len ( self ) result ( len_out ) class ( unicode_type ), intent ( in ) :: self integer :: len_out len_out = len ( self ) end function oop_len !=================================================================================================================================== impure function oop_index ( self , substring ) result ( index_out ) class ( unicode_type ), intent ( in ) :: self class ( * ), intent ( in ) :: substring integer :: index_out select type ( substring ) type is ( character ( len =* )) index_out = index ( self , unicode_type ( substring )) type is ( unicode_type ) index_out = index ( self , substring ) class default stop '<ERROR>*oop_index* unknown type' end select end function oop_index !=================================================================================================================================== impure function oop_eq ( self , string ) result ( is_eq ) class ( unicode_type ), intent ( in ) :: self class ( * ), intent ( in ) :: string logical :: is_eq select type ( string ) type is ( character ( len =* )) is_eq = leq_str_char ( self , string ) type is ( unicode_type ) is_eq = leq_str_str ( self , string ) class default stop '<ERROR>*oop_eq* unknown type' end select end function oop_eq !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_unicode","tags":"","url":"sourcefile/m_unicode.f90.html"},{"title":"fox_and_crow.f90 – M_time","text":"Source Code program crow_and_fox use M_unicode , only : unicode_type , ut => unicode_type , character , len ! “The Crow and the Fox” by Jean de la Fontaine type ( unicode_type ), allocatable :: poem (:) integer :: i poem = [& ut ( 'Maître Corbeau, sur un arbre perché,' ), & ut ( 'Tenait en son bec un fromage.' ), & ut ( 'Maître Renard, par l’odeur alléché,' ), & ut ( 'Lui tint à peu près ce langage :' ), & ut ( '«Hé ! bonjour, Monsieur du Corbeau.' ), & ut ( 'Que vous êtes joli ! que vous me semblez beau !' ), & ut ( 'Sans mentir, si votre ramage' ), & ut ( 'Se rapporte à votre plumage,' ), & ut ( 'Vous êtes le Phénix des hôtes de ces bois.»' ), & ut ( 'A ces mots le Corbeau ne se sent pas de joie ;' ), & ut ( 'Et pour montrer sa belle voix,' ), & ut ( 'Il ouvre un large bec, laisse tomber sa proie.' ), & ut ( 'Le Renard s’en saisit, et dit : «Mon bon Monsieur,' ), & ut ( 'Apprenez que tout flatteur' ), & ut ( 'Vit aux dépens de celui qui l’écoute :' ), & ut ( 'Cette leçon vaut bien un fromage, sans doute.»' ), & ut ( 'Le Corbeau, honteux et confus,' ), & ut ( 'Jura, mais un peu tard, qu’on ne l’y prendrait plus.' ), & ut ( ' -- Jean de la Fontaine' )] write ( * , '(g0)' )( character ( poem ( i )), i = 1 , size ( poem )) write ( * , '(a)' ) write ( * , '(*(a))' )( poem ( i )% bytes (), new_line ( 'a' ), i = 1 , size ( poem )) write ( * , '(a)' ) write ( * , '(*(g0))' )( character ( poem ( i )), len ( poem ( i )), ' ' , len ( poem ( i )% character ()), new_line ( 'a' ), i = 1 , size ( poem )) end program crow_and_fox","tags":"","url":"sourcefile/fox_and_crow.f90.html"},{"title":"unifile_to_ftn.f90 – M_time","text":"Source Code program unifile_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string as char(3f) calls use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stdin => input_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' character ( len = 80 ) :: count integer :: i , j , iostat character ( len = 4096 , kind = ucs4 ) :: uline open ( stdin , encoding = 'UTF-8' ) open ( stdout , encoding = 'UTF-8' ) write ( stdout , g ) 'program testit' write ( stdout , g ) 'use, intrinsic :: iso_fortran_env, only : output_unit' write ( stdout , g ) \"integer, parameter :: ucs4 = selected_char_kind ('ISO_10646')\" write ( stdout , g ) \"   open (output_unit, encoding='utf-8')\" do j = 1 , huge ( 0 ) - 1 read ( stdin , '(a)' , iostat = iostat ) uline if ( iostat . ne . 0 ) exit write ( count , g ) \"variable_\" , j , \"= &\" write ( stdout , g ) 'block' write ( stdout , g ) '! Unicode code points for ' , trim ( uline ) write ( stdout , g ) 'character(len=*,kind=ucs4),parameter :: ' // trim ( count ) write ( stdout , form )( uline ( i : i ), i = 1 , len_trim ( uline )) write ( stdout , g ) \"   write(output_unit,'(a)' )variable_\" , j write ( stdout , g ) 'endblock' enddo write ( stdout , g ) \"end program testit\" end program unifile_to_ftn","tags":"","url":"sourcefile/unifile_to_ftn.f90.html"},{"title":"codepoints.f90 – M_time","text":"Source Code program test_utf8 use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 , utf8_to_codepoints , utf8_to_ucs4_via_io implicit none character ( len = 100 ) :: s integer , allocatable :: codepoints (:) integer :: i , err intrinsic selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: not_ascii = \"ľščťžýáßĄĘ®™√🙂\" character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = 1 , kind = ucs4 ) :: letter s = \"Héllo 🌍\" ! UTF-8 input string call utf8_to_codepoints ( s , codepoints , err ) if ( err /= 0 ) then print * , \"Decode error:\" , err else print * , \"Code points:\" do i = 1 , size ( codepoints ) write ( * , '(\"U+\",Z8.8)' ) codepoints ( i ) enddo endif !Code points: !U+00000048 !U+000000E9 !U+0000006C !U+0000006C !U+0000006F !U+0001F30D open ( output_unit , encoding = 'UTF-8' ) write ( * , * ) call utf8_to_codepoints ( not_ascii , codepoints , err ) write ( * , * ) 'SIZE:' , size ( codepoints ), merge ( 'PASSED' , 'FAILED' , size ( codepoints ) == 14 ) write ( * , '(*(a))' ) char ( codepoints , kind = ucs4 ) write ( * , '(\"UNICODE NOTATION:\",T20,*(\"U+\",z6.6:,\" \"))' ) codepoints write ( * , '(\"HTML:\",T20,*(\"&#x\",z0,\";\":))' ) codepoints write ( * , '(\"C/PYTHON:\",T20,*(\"\\U\",z8.8:))' ) codepoints write ( * , * ) write ( * , * ) 'properly converted to ucs4' corrected = utf8_to_ucs4 ( not_ascii ) write ( * , * ) 'CORRECTED:' , corrected write ( * , * ) 'LEN CORRECTED:' , len ( corrected ) write ( * , * ) 'STORAGE_SIZE:' , storage_size ( corrected ) write ( * , * ) 'so now slicing, intrinsics, ... work!!' letter = corrected ( 14 : 14 ) write ( * , * ) '14th character' , letter write ( * , * ) 'index position' , index ( corrected , letter ) write ( * , * ) write ( * , * ) 'properly converted to ucs4 via I/O' corrected = utf8_to_ucs4_via_io ( not_ascii ) write ( * , * ) 'CORRECTED:' , corrected write ( * , * ) 'LEN CORRECTED:' , len ( corrected ) write ( * , * ) 'STORAGE_SIZE:' , storage_size ( corrected ) write ( * , * ) 'so now slicing, intrinsics, ... work!!' letter = corrected ( 14 : 14 ) write ( * , * ) '14th character' , letter write ( * , * ) 'index position' , index ( corrected , letter ) write ( * , * ) write ( * , * ) 'variable= &' write ( * , '((\"  char(int(z''\",z0,\"''),kind=ucs4)\",:,\", &\"))' )( corrected ( i : i ), i = 1 , len ( corrected )) end program","tags":"","url":"sourcefile/codepoints.f90.html"},{"title":"utf8_to_ucs4.f90 – M_time","text":"Source Code program testit use iso_fortran_env , only : stdout => output_unit use M_utf8 , only : ucs4_to_utf8 implicit none integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = :, kind = ucs4 ), allocatable :: ustr character ( len = :), allocatable :: astr integer :: err open ( stdout , encoding = 'UTF-8' ) ! standard method ustr = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) write ( stdout , * ) ustr write ( stdout , * ) merge ( 'PASSED' , 'FAILED' , storage_size ( ustr ) /= storage_size ( 'Hello World and Ni Hao -- 你好' ) ) astr = ucs4_to_utf8 ( ustr , err ) write ( stdout , * ) merge ( 'PASSED' , 'FAILED' , astr == 'Hello World and Ni Hao -- 你好' ) write ( stdout , * ) ustr write ( stdout , * ) astr end program testit","tags":"","url":"sourcefile/utf8_to_ucs4.f90.html"},{"title":"main.f90 – M_time","text":"Source Code program uni_to_ftn ! simplistically copy a utf8 formatted sequential file from stdin to stdout, prefixing lines with number of glyphs use , intrinsic :: iso_fortran_env , only : output_unit , input_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len = 1024 , kind = ucs4 ) :: uline ! arbitrarily assume maximum line length. Stream I/O could be used instead character ( len = :, kind = ucs4 ), allocatable :: ustr integer :: iostat open ( output_unit , encoding = 'UTF-8' ) open ( input_unit , encoding = 'UTF-8' ) do read ( input_unit , '(a)' , iostat = iostat ) uline if ( iostat . ne . 0 ) exit ustr = trim ( uline ) ! assign and trim() works on 4-byte characters write ( output_unit , '(i9.9,\":\",a)' ) len ( ustr ), ustr ! len()  works on 4-byte characters enddo end program uni_to_ftn","tags":"","url":"sourcefile/main.f90.html"},{"title":"question.f90 – M_time","text":"Source Code program shouldit use iso_fortran_env , only : output_unit , int64 implicit none intrinsic selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) integer , parameter :: ascii = selected_char_kind ( 'ASCII' ) ! can something in quotes only be encoded as ASCII? !NO!character(len=*,kind=ucs4),parameter :: A=ucs4_'ľščťžýáßĄĘ®™√🙂' !NO!character(len=*,kind=ucs4),parameter :: A='ľščťžýáßĄĘ®™√🙂' character ( len =* , kind = ascii ), parameter :: A = 'ľščťžýáßĄĘ®™√🙂' character ( len = 512 , kind = ucs4 ) :: ULINE character ( len = 512 , kind = ascii ) :: ALINE character ( len =* , kind = ucs4 ), parameter :: B = & char ( int ( z '13E' ), kind = ucs4 ) // & char ( int ( z '161' ), kind = ucs4 ) // & char ( int ( z '10D' ), kind = ucs4 ) // & char ( int ( z '165' ), kind = ucs4 ) // & char ( int ( z '17E' ), kind = ucs4 ) // & char ( int ( z 'FD' ), kind = ucs4 ) // & char ( int ( z 'E1' ), kind = ucs4 ) // & char ( int ( z 'DF' ), kind = ucs4 ) // & char ( int ( z '104' ), kind = ucs4 ) // & char ( int ( z '118' ), kind = ucs4 ) // & char ( int ( z 'AE' ), kind = ucs4 ) // & char ( int ( z '2122' ), kind = ucs4 ) // & char ( int ( z '221A' ), kind = ucs4 ) // & char ( int ( z '1F642' ), kind = ucs4 ) !character(len=1,kind=ucs4),parameter :: C(*)=& !char(int([z'13E',z'161',z'10D',z'165',z'17E',z'FD',z'E1',z'DF',z'104',z'118',z'AE',z'2122',z'221A',z'1F642']),kind=ucs4) open ( output_unit , encoding = 'UTF-8' ) write ( * , * ) 'this is not really UTF-8, it a stream of bytes that has the right values' write ( * , * ) A , len ( A ), storage_size ( A ), A ( 10 : 14 ) write ( * , * ) 'Fortran actually understands this, so slice and intrinsics work correctly' write ( * , * ) B , len ( B ), storage_size ( B ), B ( 10 : 14 ) write ( * , * ) 'The data between the quotes is ASCII so this does not work' write ( * , * ) ucs4_ 'ľ' , ucs4_ 'š' , ucs4_ 'č' , ucs4_ 'ť' , ucs4_ 'ž' , & ucs4_ 'ý' , ucs4_ 'á' , ucs4_ 'ß' , ucs4_ 'Ą' , ucs4_ 'Ę' , & ucs4_ '®' , ucs4_ '™' , ucs4_ '√' , ucs4_ '🙂' write ( * , * ) 'might work but not defined by the standard that I can tell' write ( ULINE , '(A)' ) A write ( * , * ) 'ULINE:' , trim ( ULINE ) write ( * , * ) 'A:' , A write ( * , * ) 'might work but not defined by the standard that I can tell' write ( ALINE , '(A)' ) A write ( * , * ) 'ALINE:' , trim ( ALINE ) write ( * , * ) 'biggest code:' write ( * , * ) 'FFFFFFFF:' , int ( z 'FFFFFFFF' , kind = int64 ) end program shouldit","tags":"","url":"sourcefile/question.f90.html"},{"title":"M_utf8.f90 – M_time","text":"Source Code module M_utf8 use iso_fortran_env , only : error_unit , stderr => error_unit use M_unicode , only : utf8_to_codepoints , codepoints_to_utf8 ! Unicode-related procedures requiring Fortran support of ISO-10646. implicit none private public :: utf8_to_ucs4 , ucs4_to_utf8 public :: utf8_to_ucs4_via_io , ucs4_to_utf8_via_io public :: ascii_to_ucs4 , ucs4_to_ascii public :: extended_ascii_to_ucs4 , ucs4_to_extended_ascii ! imported from M_unicode public :: utf8_to_codepoints , codepoints_to_utf8 integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) ! The compiler must support UCS-4 characters integer , parameter :: ascii = selected_char_kind ( 'ascii' ) ! maybe should use default, as ASCII is technically 128, not 256 chars integer , parameter :: default = selected_char_kind ( 'default' ) contains function utf8_to_ucs4 ( string ) result ( corrected ) ! return a string of kind ucs4 from bytes representing utf8 glyphs character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected integer , allocatable :: codepoints (:) integer :: i , n integer :: err call utf8_to_codepoints ( string , codepoints , err ) n = size ( codepoints ) allocate ( character ( len = n , kind = ucs4 ) :: corrected ) if (. not . allocated ( codepoints )) then corrected = '' return endif do i = 1 , n corrected ( i : i ) = char ( codepoints ( i ), kind = ucs4 ) enddo end function utf8_to_ucs4 function ucs4_to_utf8 ( ucs4_string , err ) result ( string ) ! return bytes representing utf8 glyphs from a string of kind ucs4 character ( len =* , kind = ucs4 ), intent ( in ) :: ucs4_string ! stores the UCS-4 string. integer , intent ( out ), optional :: err character ( len = :), allocatable :: string integer :: codepoints ( len ( ucs4_string )) integer :: i integer :: nerr codepoints = [( ichar ( ucs4_string ( i : i )), i = 1 , len ( ucs4_string ))] call codepoints_to_utf8 ( codepoints , string , nerr ) if ( present ( err )) then err = nerr elseif ( nerr . ne . 0 ) then stop '<ERROR>*ucs4_to_utf8*' endif end function ucs4_to_utf8 function utf8_to_ucs4_via_io ( string ) result ( corrected ) character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = ( len ( string )), kind = ucs4 ) :: line character ( len = 255 ) :: iomsg integer :: i integer :: lun integer :: iostat open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) do i = 1 , len ( string ) write ( lun , '(A)' , iostat = iostat , iomsg = iomsg , advance = 'no' ) string ( i : i ) if ( iostat . ne . 0 ) then ! not definite: after an error the position may be undefined write ( lun , '(A)' , iostat = iostat , iomsg = iomsg , advance = 'no' ) '?' write ( stderr , '(A)' ) trim ( iomsg ) endif enddo write ( lun , '(A)' , advance = 'yes' ) rewind ( lun ) read ( lun , '(A)' , iostat = iostat ) line close ( lun ) corrected = trim ( line ) end function utf8_to_ucs4_via_io function ucs4_to_utf8_via_io ( ucs4_string ) result ( corrected ) character ( len =* , kind = ucs4 ), intent ( in ) :: ucs4_string character ( len = :, kind = ascii ), allocatable :: corrected character ( len = ( len ( ucs4_string ) * 4 ), kind = ascii ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) ucs4_string rewind ( lun ) open ( unit = lun , encoding = 'default' ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function ucs4_to_utf8_via_io function ascii_to_ucs4 ( astr ) result ( ustr ) ! @(#) make the same conversion as an assignment statement from ASCII to UCS4 character ( len =* , kind = ascii ), intent ( in ) :: astr character ( len = len ( astr ), kind = ucs4 ) :: ustr integer :: i do i = 1 , len ( astr ) ustr ( i : i ) = achar ( iachar ( astr ( i : i )), kind = ucs4 ) enddo end function ascii_to_ucs4 function ucs4_to_ascii ( ustr ) result ( astr ) ! @(#) make the same conversion as an assignment statement from UCS4 to ASCII character ( len =* , kind = ucs4 ), intent ( in ) :: ustr character ( len = len ( ustr ), kind = ascii ) :: astr integer :: i do i = 1 , len ( ustr ) astr ( i : i ) = achar ( iachar ( ustr ( i : i )), kind = ascii ) enddo end function ucs4_to_ascii function extended_ascii_to_ucs4 ( astr ) result ( ustr ) ! @(#) make the conversion extended_ascii to UCS4 character ( len =* , kind = default ), intent ( in ) :: astr character ( len = len ( astr ), kind = ucs4 ) :: ustr integer :: i do i = 1 , len ( astr ) ustr ( i : i ) = char ( ichar ( astr ( i : i )), kind = ucs4 ) enddo end function extended_ascii_to_ucs4 function ucs4_to_extended_ascii ( ustr ) result ( astr ) ! @(#) make the conversion from UCS4 to extended_ascii character ( len =* , kind = ucs4 ), intent ( in ) :: ustr character ( len = len ( ustr ), kind = default ) :: astr integer :: i do i = 1 , len ( ustr ) astr ( i : i ) = char ( ichar ( ustr ( i : i )), kind = default ) enddo end function ucs4_to_extended_ascii end module M_utf8","tags":"","url":"sourcefile/m_utf8.f90.html"},{"title":"assignment.f90 – M_time","text":"Source Code program assignment use iso_fortran_env , only : stdout => output_unit , stdin => input_unit implicit none intrinsic selected_char_kind integer , parameter :: default = selected_char_kind ( \"default\" ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len = :), allocatable :: aline , a1 , a2 character ( len = :, kind = ucs4 ), allocatable :: uline , u1 , u2 character ( len = 1 ), allocatable :: ch (:), ch2 (:) character ( len = 1 , kind = ucs4 ), allocatable :: glyph (:) integer :: i integer :: iostat integer :: nerr character ( len = 1 ) :: paws character ( len = 1 , kind = ucs4 ) :: smiley = char ( int ( z '1F603' ), kind = ucs4 ) ! 😃 Smiling face with open mouth open ( stdout , encoding = 'DEFAULT' ) open ( stdout , encoding = 'UTF-8' ) ! ! only characters defined in the other encoding are copied on an assign write ( stdout , '(A)' ) repeat ( ' ' , 80 ) write ( stdout , '(A)' ) 'assign RHS ucs4 to LHS ascii' uline = char ( int ( z '261B' ), ucs4 ) // ucs4_ 'UCS-4 string' // char ( int ( z '261A' ), ucs4 ) write ( stdout , '(a)' ) trim ( uline ) aline = uline ! only the ASCII 7-bit characters are copied write ( stdout , '(a)' ) trim ( aline ) // ' assigned to ASCII' write ( stdout , '(A)' ) repeat ( ' ' , 80 ) write ( stdout , '(A)' ) 'assign LHS ascii to RHS ucs4' aline = ascii_ 'ASCII string' write ( stdout , '(a)' ) trim ( aline ) uline = aline ! all ASCII 7-bit characters can be represented in UCS-4 write ( stdout , '(a)' ) trim ( uline ) // ucs4_ ' assigned to UCS4' write ( stdout , '(A)' ) 'round trip for all ASCII bytes' write ( stdout , '(A)' ) repeat ( ucs4_ '=' , 80 ) ch = [( char ( i ), i = 0 , 255 )] open ( stdout , encoding = 'DEFAULT' ) write ( stdout , '(10(g0,1x,g0,1x))' )( ch ( i ), i = 0 , 255 ) open ( stdout , encoding = 'UTF-8' ) write ( stdout , '(10(g0,1x,g0,1x))' )( ch ( i ), i = 0 , 255 ) read ( stdin , '(a)' , iostat = iostat ) paws write ( stdout , '(A)' ) repeat ( ucs4_ '=' , 80 ) glyph = ch write ( stdout , '(10(g0,1x,g0,1x))' )( glyph ( i ), i = 0 , 255 ) read ( stdin , '(a)' , iostat = iostat ) paws write ( stdout , '(A)' ) repeat ( ucs4_ '=' , 80 ) ch2 = glyph write ( stdout , '(10(g0,1x,g0,1x))' )( ch2 ( i ), i = 0 , 255 ) read ( stdin , '(a)' , iostat = iostat ) paws write ( stdout , '(A)' ) repeat ( ucs4_ '=' , 80 ) write ( stdout , '(a,L0)' ) 'roundrobin returned all values unchanged?' , all ( ch . eq . ch2 ) end program assignment","tags":"","url":"sourcefile/assignment.f90.html"},{"title":"assign.f90 – M_time","text":"Source Code program assign_exe use M_unicode , only : len , len_trim , repeat , trim , adjustr , adjustl use M_unicode , only : character use M_unicode , only : assignment ( = ), unicode_type character ( len =* ), parameter :: g = '(*(g0))' character ( len = :), allocatable :: aline type ( unicode_type ) :: uline , substring , uline1 , uline2 , uline3 character ( len =* ), parameter :: smiley = '😃' integer , allocatable :: codes (:) character ( len = :), allocatable :: glyphs aline = \"Доки не впріти, доти не вміти.\" write ( * , g ) '123456789012345678901234567890' write ( * , g ) aline write ( * , g ) 'length in bytes is: ' , len ( aline ) uline = aline write ( * , g ) 'length in glyphs is: ' , len ( uline ) write ( * , g ) 'string is: ' , character ( uline ) write ( * , g ) 'third word is: ' , character ( uline , 9 , 14 ) ! substring substring = character ( uline , 17 , 29 ) write ( * , g ) 'string is: ' , character ( substring ) uline = repeat ( smiley , 30 ) write ( * , g ) character ( uline ) write ( * , g ) len_trim ( uline ) uline = aline // '      ' write ( * , g ) len_trim ( uline ) uline = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] write ( * , g ) 'spaces:' , character ( uline ), len ( uline ), len_trim ( uline ) uline = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] uline = trim ( uline ) write ( * , g ) 'trim:' , '[' , character ( uline ), ']' uline = '    this  is just a    string        ' write ( * , g ) 'adjustr:' , '[' , character ( uline ), '] ==> [' , character ( adjustr ( uline )), ']' uline = '    this  is just a    string        ' write ( * , g ) 'adjustl:' , '[' , character ( uline ), '] ==> [' , character ( adjustl ( uline )), ']' !write(*,g)uline%codes !write(*,g)uline end program assign_exe","tags":"","url":"sourcefile/assign.f90.html"},{"title":"count_glyphs.f90 – M_time","text":"Source Code program count_glyphs ! @(#) read a utf-8 file and write it out with lines prefixed with glyph counts of the line use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stdin => input_unit implicit none intrinsic selected_char_kind intrinsic is_iostat_end intrinsic len_trim !------ ! NOTE: we will be using the kind name \"ucs4\" for Unicode variables integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) !------ character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: i integer :: iostat !------ ! NOTE: this character variable is the Unicode kind, not ASCII character ( len = 1024 , kind = ucs4 ) :: uline ! specifies maximum line length of 1024 glyphs ! which would be 4*1024 bytes !------ character ( len = 255 ) :: iomsg !------ ! NOTE: you can change the encoding used for a file dynamically, even on pre-assigned files open ( stdin , encoding = 'UTF-8' ) open ( stdout , encoding = 'UTF-8' ) !------ do read ( stdin , '(a)' , iostat = iostat , iomsg = iomsg ) uline if ( iostat . eq . 0 ) then !------ ! NOTE: LEN_TRIM() works with UCS-4 just as with ASCII length = len_trim ( uline ) !------ !------ ! NOTE: String substrings work just like with ASCII as well write ( stdout , '(i9,\": \",a)' ) length , uline (: length ) !------ elseif ( is_iostat_end ( iostat )) then exit else !------ ! NOTE: ! does the ASCII message have to be converted to UCS-4? ! This will be discussed in detail later, but for now ! remember you can change the encoding of a file dynamically open ( stdout , encoding = 'DEFAULT' ) !------ write ( stdout , g ) '<ERROR>' , trim ( iomsg ) exit endif enddo end program count_glyphs","tags":"","url":"sourcefile/count_glyphs.f90~2.html"},{"title":"uni_to_ftn.f90 – M_time","text":"Source Code program uni_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string as char(3f) calls use , intrinsic :: iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: i character ( len = :), allocatable :: aline character ( len = :), allocatable :: command_line character ( len = :, kind = ucs4 ), allocatable :: ustr open ( output_unit , encoding = 'UTF-8' ) call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = adjustl ( command_line ( length + 1 :)) ustr = utf8_to_ucs4 ( command_line ) write ( * , g ) 'program testit' write ( * , g ) 'use, intrinsic :: iso_fortran_env, only : output_unit' write ( * , g ) \"integer, parameter :: ucs4 = selected_char_kind ('ISO_10646')\" write ( * , g ) '! OUTPUT:' , command_line write ( * , g ) 'character(len=*,kind=ucs4),parameter :: variable = &' write ( * , form )( ustr ( i : i ), i = 1 , len ( ustr )) write ( * , g ) \"   open (output_unit, encoding='utf-8')\" write ( * , g ) \"   write(output_unit,'(a)' )variable\" write ( * , g ) \"end program testit\" end program uni_to_ftn","tags":"","url":"sourcefile/uni_to_ftn.f90.html"},{"title":"test_M_unicode.f90 – M_time","text":"Source Code program test_M_unicode use iso_fortran_env , only : output_unit use M_unicode , only : adjustl , adjustr , trim , index use M_unicode , only : character use M_unicode , only : assignment ( = ), unicode_type , operator ( // ) use M_unicode , only : operator ( <= ), lle use M_unicode , only : operator ( < ), llt use M_unicode , only : operator ( /= ), lne use M_unicode , only : operator ( == ), leq use M_unicode , only : operator ( > ), lgt use M_unicode , only : operator ( >= ), lge implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) character ( len =* ), parameter :: g0 = '(*(g0))' character ( len =* ), parameter :: gx = '(*(g0,1x))' logical , parameter :: T = . true . logical , parameter :: F = . false . ! character ( len =* ), parameter :: upagain = \"七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。\" ! Romanization: ! Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! \"Fall seven times, stand up eight. Even if you fall down, you will get up again. Don't be discouraged, just keep walking forward.\" ! character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str type ( unicode_type ) :: smiley integer :: total integer :: err integer :: i type ( unicode_type ) :: lhs , rhs type ( unicode_type ) :: string , substring smiley = '😃' total = 0 write ( * , g0 ) 'encoding can be altered on an open file' open ( output_unit , encoding = 'UTF-8' ) write ( * , g0 ) astr = 'Hello World and Ni Hao -- 你好' ut_str = astr call checkits ( 'convert to ASCII bytes' , astr , ut_str % bytes (), transfer ( 'Hello World and Ni Hao -- 你好' ,[ 'A' ])) astr = \"  this is a string    \" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'this is a string      ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '      this is a string' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '  this is a string' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 18 ) call check ( 'len' , ut_str % len (). eq . 22 ) astr = \"  \" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '  ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '  ' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 0 ) call check ( 'len' , ut_str % len (). eq . 2 ) astr = \"\" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 0 ) call check ( 'len' , ut_str % len (). eq . 0 ) astr = \"ALLFULL\" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'ALLFULL' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), 'ALLFULL' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), 'ALLFULL' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 7 ) call check ( 'len' , ut_str % len (). eq . 7 ) ut_str = [ 32 , 32 , int ( z '1F603' ), 32 , 32 , 32 ] astr = character ( ut_str ) call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '😃     ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '     😃' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '  😃' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 3 ) call check ( 'len' , ut_str % len (). eq . 6 ) if ( total . ne . 0 ) then write ( * , g0 ) total , 'failures' stop 1 endif ut_str = smiley // ' and ' // smiley // 'and' // smiley // smiley // 'is it' astr = '😃 and 😃and😃😃is it' call checkit ( 'concatenation' , astr , character ( ut_str ), '😃 and 😃and😃😃is it' ) lhs = 'this is the left' rhs = 'this is the right' call checkits_l ( 'LLE' , ' ' , [ lle ( lhs , rhs ), lhs <= rhs , lle ( rhs , lhs ), rhs <= lhs ] , [ T , T , F , F ] ) call checkits_l ( 'LLT' , ' ' , [ llt ( lhs , rhs ), lhs < rhs , llt ( rhs , lhs ), rhs < lhs ] , [ T , T , F , F ] ) call checkits_l ( 'LNE' , ' ' , [ lne ( lhs , rhs ), lhs /= rhs , lne ( rhs , lhs ), rhs /= lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LEQ' , ' ' , [ leq ( lhs , rhs ), lhs == rhs , leq ( rhs , lhs ), rhs == lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LGT' , ' ' , [ lgt ( lhs , rhs ), lhs > rhs , lgt ( rhs , lhs ), rhs > lhs ] , [ F , F , T , T ] ) call checkits_l ( 'LGE' , ' ' , [ lge ( lhs , rhs ), lhs >= rhs , lge ( rhs , lhs ), rhs >= lhs ] , [ F , F , T , T ] ) lhs = 'abc' rhs = 'abc ' call checkits_l ( 'LLE' , ' ' , [ lle ( lhs , rhs ), lhs <= rhs , lle ( rhs , lhs ), rhs <= lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LLT' , ' ' , [ llt ( lhs , rhs ), lhs < rhs , llt ( rhs , lhs ), rhs < lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LNE' , ' ' , [ lne ( lhs , rhs ), lhs /= rhs , lne ( rhs , lhs ), rhs /= lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LEQ' , ' ' , [ leq ( lhs , rhs ), lhs == rhs , leq ( rhs , lhs ), rhs == lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LGT' , ' ' , [ lgt ( lhs , rhs ), lhs > rhs , lgt ( rhs , lhs ), rhs > lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LGE' , ' ' , [ lge ( lhs , rhs ), lhs >= rhs , lge ( rhs , lhs ), rhs >= lhs ] , [ T , T , T , T ] ) string = \" can you find me here? \" substring = \"find me\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 10 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 10 ) string = \" can you find me here? \" substring = \"not there\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 0 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 0 ) string = \"short\" substring = \"shortnot\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 0 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 0 ) string = upagain write ( * , g0 ) 'original bytes  :' , upagain write ( * , g0 ) 'bytes reversed  :' , ( upagain ( i : i ), i = len ( upagain ), 1 , - 1 ) write ( * , g0 ) 'original string :' , string % character () write ( * , g0 ) 'string reversed :' , string % character ( string % len (), 1 , - 1 ) contains subroutine checkit ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer character ( len =* ), intent ( in ) :: expected write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , answer . eq . expected ), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( answer . ne . expected ) total = total + 1 end subroutine checkit subroutine checkits ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer (:) character ( len =* ), intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eq . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . ne . expected )) total = total + 1 end subroutine checkits subroutine checkits_l ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline logical , intent ( in ) :: answer (:) logical , intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eqv . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . neqv . expected )) total = total + 1 end subroutine checkits_l subroutine check ( label , test ) character ( len =* ), intent ( in ) :: label logical , intent ( in ) :: test write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label if (. not . test ) total = total + 1 end subroutine check end program test_M_unicode","tags":"","url":"sourcefile/test_m_unicode.f90.html"},{"title":"hello.f90 – M_time","text":"Source Code program testit use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 , ucs4_to_utf8_via_io , utf8_to_ucs4_via_io implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = :, kind = ucs4 ), allocatable :: str character ( len = 1 , kind = ucs4 ) :: glyph character ( len =* ), parameter :: all = '(*(g0))' character ( len = :, kind = ascii ), allocatable :: aline character ( len = :, kind = ucs4 ), allocatable :: uline integer :: i open ( output_unit , encoding = 'UTF-8' ) ! standard method str = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) write ( * , * ) str ! converting pseudo-utf8 to ucs4 str = utf8_to_ucs4 ( 'Hello World and Ni Hao -- 你好' ) write ( * , * ) str print all print all , 'intrinsics work with ucs4:' print all , 'slice glyph 27:' , str ( 27 : 27 ) print all , 'length        :' , len ( str ) print all , 'bytes         :' , storage_size ( str ) / 8 glyph = str ( 27 : 27 ) print all , 'index         :' , index ( str , glyph ) write ( * , '(a,i0,\",z''\",z0,\"''\")' ) 'ichar         :' , ichar ( glyph ), glyph glyph = char ( int ( z '597D' ), kind = ucs4 ) print all , 'char          :' , glyph print all , 'repeat        :' , repeat ( str ( 27 : 28 ), 3 ) ! SHOULD WRITE INTO ASCII CREATE RAW UTF8 OR WHAT? print all print all , 'internal write into ascii' aline = repeat ( ' ' , len ( str ) * 4 ) write ( aline , all ) str aline = trim ( aline ) print all , 'length        :' , len ( aline ) print all , 'bytes         :' , storage_size ( aline ) / 8 print all , aline ! SHOULD WRITE INTO UCS4 DO ANYTHING DIFFERENT? print all print all , 'internal write into ucs4' uline = repeat ( ' ' , len ( str )) write ( uline , all ) str uline = trim ( uline ) print all , 'length        :' , len ( uline ) print all , 'bytes         :' , storage_size ( uline ) / 8 print all , uline print all print all , 'raw utf8' print all , 'length        :' , len ( 'Hello World and Ni Hao -- 你好' ) print all , 'bytes         :' , storage_size ( 'Hello World and Ni Hao -- 你好' ) / 8 ! WHAT SHOULD ASSIGN DO? print all print all , 'assign' aline = uline print all , 'length        :' , len ( aline ) print all , 'bytes         :' , storage_size ( aline ) / 8 print all , aline print all print all , 'to be or not to be' ! Ikiru ka shinu ka ! \"to live or die\" str = utf8_to_ucs4 ( '生きるか死ぬか' ) print all , 'ucs4 string:' , str print all , 'reverse:    ' ,( str ( i : i ), i = len ( str ), 1 , - 1 ) print all print all , 'ucs4 to utf8' str = utf8_to_ucs4_via_io ( '生きるか死ぬか' ) aline = ucs4_to_utf8_via_io ( str ) print all , merge ( 'PASSED' , 'FAILED' , aline == '生きるか死ぬか' ) end program testit","tags":"","url":"sourcefile/hello.f90.html"},{"title":"note.f90 – M_time","text":"Source Code program note use iso_fortran_env , only : output_unit implicit none intrinsic selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* , kind = ucs4 ), parameter :: pointer = char ( int ( z '1FBC1' ), kind = ucs4 ) // & char ( int ( z '1FBC2' ), kind = ucs4 ) // & char ( int ( z '1FBC3' ), kind = ucs4 ) open ( output_unit , encoding = 'UTF-8' ) write ( * , * ) pointer end program note","tags":"","url":"sourcefile/note.f90.html"},{"title":"read_commandline.f90 – M_time","text":"Source Code program uni_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string use , intrinsic :: iso_fortran_env , only : output_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' integer :: i character ( len = :), allocatable :: aline character ( len = :), allocatable :: command_line character ( len = :, kind = ucs4 ), allocatable :: ustr command_line = getargs () ! get string containing all command arguments as CHARACTER bytes ustr = utf8_to_ucs4 ( command_line ) ! convert bytes to internal Fortran Unicode representation ! write the command line out as a Fortran variable expression using the CHAR() function open ( output_unit , encoding = 'UTF-8' ) write ( * , g ) '! ENCODING:' , command_line write ( * , g ) 'character(len=*,kind=ucs4),parameter :: variable= &' write ( * , form )( ustr ( i : i ), i = 1 , len ( ustr )) contains function getargs () result ( command_line ) integer :: length character ( len = :), allocatable :: command_line call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = adjustl ( command_line ( length + 1 :)) end function getargs function utf8_to_ucs4 ( string ) result ( corrected ) character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = ( len ( string )), kind = ucs4 ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) string rewind ( lun ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function utf8_to_ucs4 function ucs4_to_utf8 ( ucs4_string ) result ( corrected ) character ( len =* , kind = ucs4 ), intent ( in ) :: ucs4_string character ( len = :), allocatable :: corrected character ( len = ( len ( ucs4_string ) * 4 )) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) ucs4_string rewind ( lun ) open ( unit = lun , encoding = 'default' ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function ucs4_to_utf8 end program uni_to_ftn","tags":"","url":"sourcefile/read_commandline.f90.html"},{"title":"read_filename.f90 – M_time","text":"Source Code program read_filename ! @(#) convert ucs-4 filename to utc-8 for OPEN() statement use , intrinsic :: iso_fortran_env , only : output_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len = :), allocatable :: afilename character ( len = :, kind = ucs4 ), allocatable :: ufilename integer :: lun ! we have a UCS-4 filename from somewhere ... ufilename = & ! ENCODING:môj_obľúbený_súbor \"my_favorite_file\" char ( int ( z '6D' ), kind = ucs4 ) // char ( int ( z 'F4' ), kind = ucs4 ) // char ( int ( z '6A' ), kind = ucs4 ) // & char ( int ( z '5F' ), kind = ucs4 ) // char ( int ( z '6F' ), kind = ucs4 ) // char ( int ( z '62' ), kind = ucs4 ) // & char ( int ( z '13E' ), kind = ucs4 ) // char ( int ( z 'FA' ), kind = ucs4 ) // char ( int ( z '62' ), kind = ucs4 ) // & char ( int ( z '65' ), kind = ucs4 ) // char ( int ( z '6E' ), kind = ucs4 ) // char ( int ( z 'FD' ), kind = ucs4 ) // & char ( int ( z '5F' ), kind = ucs4 ) // char ( int ( z '73' ), kind = ucs4 ) // char ( int ( z 'FA' ), kind = ucs4 ) // & char ( int ( z '62' ), kind = ucs4 ) // char ( int ( z '6F' ), kind = ucs4 ) // char ( int ( z '72' ), kind = ucs4 ) afilename = ucs4_to_utf8 ( ufilename ) open ( newunit = lun , file = afilename , encoding = 'utf-8' ) !CLOSE(unit=lun, status='delete') contains function ucs4_to_utf8 ( ucs4_string ) result ( ascii_string ) character ( len =* , kind = ucs4 ), intent ( in ) :: ucs4_string character ( len = :), allocatable :: ascii_string character ( len = ( len ( ucs4_string ) * 4 )) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) ucs4_string rewind ( lun ) open ( unit = lun , encoding = 'default' ) read ( lun , '(A)' ) line close ( lun ) ascii_string = trim ( line ) end function ucs4_to_utf8 end program read_filename","tags":"","url":"sourcefile/read_filename.f90.html"}]}