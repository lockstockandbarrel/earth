var tipuesearch = {"pages":[{"title":" M_time ","text":"M_time M_utf8 A WIP (Work In Progress) Fortran does not inherently provide a direct built-in function to\nconvert an arbitrary UTF-8 encoded string to UCS-4 (ISO_10646) character\nkind. While Fortran 2003 and later standards introduce support for\ndifferent character kinds, including ISO_10646 (UCS-4), the conversion\nfrom a byte-stream representing UTF-8 to the UCS-4 character kind typically\nrequires manual decoding accept when reading and writing from a file with\nencoding set to “UTF-8”. Here are some experiments in helping to facilitate using source codes\ncontaining UTF-8 encoded strings as standard Fortran Unicode characters\ninstead of as ASCII byte streams that contain UTF-8 constant strings. utf8_to_codepoints utf8_to_ucs4 utf8_to_ucs4_via_io ucs4_to_utf8 program testit use iso_fortran_env , only : stdout => output_unit use M_utf8 , only : utf8_to_ucs4 implicit none integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = :, kind = ucs4 ), allocatable :: str open ( stdout , encoding = 'UTF-8' ) ! standard method str = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) write ( stdout , * ) str ! converting pseudo-utf8 to ucs4 str = utf8_to_ucs4 ( 'Hello World and Ni Hao -- 你好' ) write ( stdout , * ) str write ( stdout , * ) len ( str ) write ( stdout , * ) str ( 27 : 27 ) end program testit Fortran Unicode Tutorial Here are some lessons that describe my experiences with Unicode and\nFortran, including discussions of open questions concerning what is\nstandardized, what extensions commonly used compilers provide to address\nsome of the current gaps, and what is known to be non-portable but useful\nbehavior from some compilers regarding undefined behaviors. WIP Notice: this has barely been begin. I am still sorting out what is and is\nnot standard. Once constructed and stable, the lessons will become a tutorial on the Fortran Wiki,\nand this project will contain the related modules and examples, but at this point\nthis is just an incomplete outline so starting the Wiki entries would be premature. Introduction to Fortran Unicode support Lesson I: reading and writing UTF-8 Unicode files Lesson II: creating Unicode strings in ASCII Fortran source files Lesson III: mixing ASCII and UCS4 kinds as regards assignments, passing arguments\n                  to external ASCII libraries, and I/O argument lists Lesson IV: what is and is not supported with internal READ and WRITE statements Lesson V:   processing Unicode file names on OPEN() statements Lesson VI:   reading UTF-8 strings from command lines Lesson VII:  passing Unicode strings to and from C Lesson VIII: related utility programs off the beaten path: Lesson I: UTF-8 source files – just in comments and constants Lesson II: the backslash escape code extension Lesson III: converting between UCS-4 and UTF-8 with procedures Lesson IV: embedding BOM characters at the beginning of files Processing Unicode when ISO-10646 is not supported by a compiler Lesson I: converting UTF-8 codes to and from INTEGER values Lesson II: byte-oriented printing of 4-byte integers Lesson III: issues with terminal emulators, system locale settings, and\n                  other Unicode-related issues Lesson IV: working with ASCII extended encodings; particularly those\n                 commonly referred to as Extended, Latin, Latin1 and Latin2. Dusty Corners Assigns between different character kinds, and an apparent\nlack of an ability to specify encoding=’UTF-8’ when using\ninternal reads and writes like you can with an OPEN(3f)\nstatement are still a little murky; as well as how the T\nfield descriptor works with multi-byte characters. Note that at least with the gfortran(1) compiler conversion\nto UCS4 internal representation works automatically when\nreading and writing from files with encoding=’utf-8’ specified,\nthis is just primarily concerned with UTF-8 string constants occurring\nin the code files themselves. backslash extension The gfortran(1) compiler supports an extension that allows for building\nucs4 strings more easily than using BOZ literals. The following example prints the Unicode symbol ☻ (black smiling face)\nof code point U+263B. The compiled binary must be executed in a terminal\nwith Unicode support, like XTerm or sakura. program main ! code to place in unicode.f90 use , intrinsic :: iso_fortran_env , only : output_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( kind = ucs4 , len = :), allocatable :: str ! GFORTRAN EXTENSION: str = ucs4_ 'Unicode character: \\u263B' open ( output_unit , encoding = 'utf-8' ) print '(a)' , str end program main Build and run the executable with: $ gfortran -fbackslash -o unicode unicode.f90\n$ ./unicode\nUnicode character: ☻ The -fbackslash compiler flag is required for escaped Unicode\ncharacters. Otherwise, the type conversion has to be done manually using\nBOZ literals, for instance: str = ucs4_'Unicode character: ' // char(int(z'263B'), kind=ucs4) Or, simply by using the decimal value of the character code point, without BOZ literal: str = ucs4_'Unicode character: ' // char(9787, kind=ucs2) See Also https://fortran-lang.discourse.group/t/how-to-use-utf-8-in-gfortran/9949 https://fortran-lang.discourse.group/t/how-do-i-file-read-french-special-characters-like-e-etc/6618 https://fortran-lang.discourse.group/t/using-unicode-characters-in-fortran/2764 Other languages, such as the Python encode() and decode() procedures, supply related functionality. # extract discourse as text lynx --dump https://fortran-lang.discourse.group/t/how-to-use-utf-8-in-gfortran/9949\nlynx --dump https://fortran-lang.discourse.group/t/using-unicode-characters-in-fortran/2764 Developer Info John S. Urban","tags":"home","url":"index.html"},{"title":"checkit – M_time","text":"subroutine checkit(label, test) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label logical, intent(in) :: test Source Code subroutine checkit ( label , test ) character ( len =* ), intent ( in ) :: label logical , intent ( in ) :: test write ( * , * ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label if (. not . test ) total = total + 1 end subroutine checkit","tags":"","url":"proc/checkit.html"},{"title":"ucs4_to_utf8 – M_time","text":"public  function ucs4_to_utf8(ucs4_string, err) result(string) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ucs4_string integer, intent(out), optional :: err Return Value character(kind=ascii, len=:), allocatable Source Code function ucs4_to_utf8 ( ucs4_string , err ) result ( string ) ! return bytes representing utf8 glyphs from a string of kind ucs4 character ( len =* , kind = ucs4 ), intent ( in ) :: ucs4_string ! stores the UCS-4 string. integer , intent ( out ), optional :: err character ( len = :, kind = ascii ), allocatable :: string integer :: codepoints ( len ( ucs4_string )) integer :: i codepoints = [( ichar ( ucs4_string ( i : i )), i = 1 , len ( ucs4_string ))] call codepoints_to_utf8 ( codepoints , string , err ) end function ucs4_to_utf8","tags":"","url":"proc/ucs4_to_utf8.html"},{"title":"ucs4_to_utf8_via_io – M_time","text":"public  function ucs4_to_utf8_via_io(ucs4_string) result(corrected) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ucs4_string Return Value character(kind=ascii, len=:), allocatable Source Code function ucs4_to_utf8_via_io ( ucs4_string ) result ( corrected ) character ( len =* , kind = ucs4 ), intent ( in ) :: ucs4_string character ( len = :, kind = ascii ), allocatable :: corrected character ( len = ( len ( ucs4_string ) * 4 ), kind = ascii ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) ucs4_string rewind ( lun ) open ( unit = lun , encoding = 'default' ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function ucs4_to_utf8_via_io","tags":"","url":"proc/ucs4_to_utf8_via_io.html"},{"title":"utf8_to_ucs4 – M_time","text":"public  function utf8_to_ucs4(string) result(corrected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=ucs4, len=:), allocatable Source Code function utf8_to_ucs4 ( string ) result ( corrected ) ! return a string of kind ucs4 from bytes representing utf8 glyphs character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected integer , allocatable :: codepoints (:) integer :: i , n integer :: err call utf8_to_codepoints ( string , codepoints , err ) n = size ( codepoints ) allocate ( character ( len = n , kind = ucs4 ) :: corrected ) do i = 1 , n corrected ( i : i ) = char ( codepoints ( i ), kind = ucs4 ) enddo end function utf8_to_ucs4","tags":"","url":"proc/utf8_to_ucs4.html"},{"title":"utf8_to_ucs4_via_io – M_time","text":"public  function utf8_to_ucs4_via_io(string) result(corrected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=ucs4, len=:), allocatable Source Code function utf8_to_ucs4_via_io ( string ) result ( corrected ) character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = ( len ( string )), kind = ucs4 ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) string rewind ( lun ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function utf8_to_ucs4_via_io","tags":"","url":"proc/utf8_to_ucs4_via_io.html"},{"title":"codepoints_to_utf8 – M_time","text":"public  subroutine codepoints_to_utf8(codepoints, string, err) Uses iso_fortran_env Arguments Type Intent Optional Attributes Name integer, intent(in) :: codepoints (:) character(kind=ascii, len=:), allocatable :: string integer, intent(out), optional :: err Source Code subroutine codepoints_to_utf8 ( codepoints , string , err ) ! ! converting Unicode code points to UTF-8 ! internally without using I/O directly requires manual implementation of ! the UTF-8 encoding rules because there's no direct intrinsic function ! for this conversion. ! !    UTF-8 is a variable-width encoding that uses 1 to 4 bytes to represent !    Unicode characters. ! !    The number of bytes depends on the value of the Unicode code point: !        0x0000  - 0x007F (ASCII): 1 byte (0xxxxxxx). !        0x0080  - 0x07FF: 2 bytes (110xxxxx 10xxxxxx). !        0x0800  - 0xFFFF (Basic Multilingual Plane): 3 bytes (1110xxxx 10xxxxxx 10xxxxxx). !        0x10000 - 0x10FFFF (Supplementary Planes): 4 bytes (11110xxx 10xxxxxx 10xxxxxx 10xxxxxx). ! !    Continuation bytes in multi-byte sequences always start with the !    bit pattern 10xxxxxx. ! ! Conversion Algorithm (Conceptual Example) ! ! Iterate through the 4-byte codepoint integers, each of which identifies a unicode glyph. ! Apply the UTF-8 encoding rules based on the code point's value to ! build a new byte array or a character string with character(len=1) elements, representing the ! UTF-8 sequence. ! ! The Unicode standard doesn't require a BOM for UTF-8, but it may be ! encountered at the start of files. This internal conversion doesn't ! add a BOM. ! ! This procedure does not explicitly handle surrogate pairs, which are ! used in UTF-16 to represent characters outside the Basic Multilingual ! Plane. Since UCS-4 already directly represents code points, surrogates ! are not a direct concern for UCS-4 to UTF-8 conversion, but it's ! good to be aware of them when dealing with other Unicode encodings. ! use iso_fortran_env , only : error_unit integer , intent ( in ) :: codepoints (:) integer , intent ( out ), optional :: err character ( len = :, kind = ascii ), allocatable :: string ! utf8_bytes stores the resulting UTF-8 byte sequence. It's declared ! with kind=ascii and a length determined by the maximum possible ! bytes for the UCS-4 string length (each UCS-4 character can be up ! to 4 bytes in UTF-8). character ( len = size ( codepoints ) * 4 ) :: utf8_bytes ! Max 4 bytes per UCS-4 char integer :: i , j , code_point integer :: num_bytes , utf8_index integer , dimension ( 4 ) :: utf8_code utf8_index = 1 if ( present ( err )) err = 0 do i = 1 , size ( codepoints ) ! iterate through each UCS-4 character. code_point = codepoints ( i ) ! Get the integer value of the UCS-4 char ! The if/elseif statements check the code point value and determine ! the number of bytes required for UTF-8 encoding. ! ! Bitwise operations (ior, ishft, iand) are used to construct the ! individual UTF-8 bytes according to the standard rules. ! if ( code_point < int ( z '80' ) ) then ! 1-byte UTF-8 (ASCII) num_bytes = 1 utf8_code ( 1 ) = code_point else if ( code_point < int ( z '800' ) ) then ! 2-byte UTF-8 num_bytes = 2 utf8_code ( 1 ) = ior ( z 'C0' , ishft ( code_point , - 6 )) utf8_code ( 2 ) = ior ( z '80' , iand ( code_point , z '3F' )) else if ( code_point < int ( z '10000' ) ) then ! 3-byte UTF-8 num_bytes = 3 utf8_code ( 1 ) = ior ( z 'E0' , ishft ( code_point , - 12 )) utf8_code ( 2 ) = ior ( z '80' , iand ( ishft ( code_point , - 6 ), z '3F' )) utf8_code ( 3 ) = ior ( z '80' , iand ( code_point , z '3F' )) else if ( code_point < int ( z '110000' ) ) then ! 4-byte UTF-8 num_bytes = 4 utf8_code ( 1 ) = ior ( z 'F0' , ishft ( code_point , - 18 )) utf8_code ( 2 ) = ior ( z '80' , iand ( ishft ( code_point , - 12 ), z '3F' )) utf8_code ( 3 ) = ior ( z '80' , iand ( ishft ( code_point , - 6 ), z '3F' )) utf8_code ( 4 ) = ior ( z '80' , iand ( code_point , z '3F' )) else ! Handle invalid code points or error conditions as needed write ( error_unit , * ) \"Error: Invalid Unicode code point:\" , code_point if (. not . present ( err )) stop 1 err = err + 1 cycle endif ! Append the UTF-8 bytes to the utf8_bytes string do j = 1 , num_bytes ! The utf8_bytes string is built byte by byte using char with kind=ascii. utf8_bytes ( utf8_index : utf8_index ) = char ( utf8_code ( j ), kind = ascii ) utf8_index = utf8_index + 1 enddo enddo string = trim ( utf8_bytes ( 1 : utf8_index - 1 )) ! the UTF-8 byte sequence end subroutine codepoints_to_utf8","tags":"","url":"proc/codepoints_to_utf8.html"},{"title":"utf8_to_codepoints – M_time","text":"public  subroutine utf8_to_codepoints(utf8, out, err) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: utf8 integer, intent(out), allocatable :: out (:) integer, intent(out) :: err Source Code subroutine utf8_to_codepoints ( utf8 , out , err ) ! convert utf-8 characters to unicode codepoints (ie. integers) without requiring compiler to support unicode character ( len =* ), intent ( in ) :: utf8 integer , allocatable , intent ( out ) :: out (:) ! Unicode code points integer , intent ( out ) :: err integer :: n_out , len8 integer :: i , b1 , b2 , b3 , b4 integer :: cp , nbytes integer :: temp ( len ( utf8 )) ! big enough to hold all of utf8 even if each byte is a glyph err = 0 len8 = len_trim ( utf8 ) i = 1 n_out = 0 do while ( i <= len8 ) b1 = iachar ( utf8 ( i : i )) if ( b1 < 0 ) b1 = b1 + 256 select case ( b1 ) case ( 0 : 127 ) cp = b1 nbytes = 1 case ( 192 : 223 ) if ( i + 1 > len8 ) then err = 1 return else b2 = iachar ( utf8 ( i + 1 : i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 if ( iand ( b2 , 192 ) /= 128 ) then ; err = 2 ; return ; endif cp = iand ( b1 , 31 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) nbytes = 2 endif case ( 224 : 239 ) if ( i + 2 > len8 ) then err = 1 return else b2 = iachar ( utf8 ( i + 1 : i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 b3 = iachar ( utf8 ( i + 2 : i + 2 )); if ( b3 < 0 ) b3 = b3 + 256 if ( iand ( b2 , 192 ) /= 128 . or . iand ( b3 , 192 ) /= 128 ) then err = 2 return else cp = iand ( b1 , 15 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) cp = ishft ( cp , 6 ) + iand ( b3 , 63 ) nbytes = 3 endif endif case ( 240 : 247 ) if ( i + 3 > len8 ) then err = 1 return else b2 = iachar ( utf8 ( i + 1 : i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 b3 = iachar ( utf8 ( i + 2 : i + 2 )); if ( b3 < 0 ) b3 = b3 + 256 b4 = iachar ( utf8 ( i + 3 : i + 3 )); if ( b4 < 0 ) b4 = b4 + 256 if ( iand ( b2 , 192 ) /= 128 . or . iand ( b3 , 192 ) /= 128 . or . iand ( b4 , 192 ) /= 128 ) then err = 2 return endif cp = iand ( b1 , 7 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) cp = ishft ( cp , 6 ) + iand ( b3 , 63 ) cp = ishft ( cp , 6 ) + iand ( b4 , 63 ) nbytes = 4 endif case default err = 3 return end select if ( n_out >= size ( temp )) then err = 4 return endif n_out = n_out + 1 temp ( n_out ) = cp i = i + nbytes enddo allocate ( out ( n_out )) out = temp ( 1 : n_out ) end subroutine utf8_to_codepoints","tags":"","url":"proc/utf8_to_codepoints.html"},{"title":"utf8_to_utf32 – M_time","text":"function utf8_to_utf32(string) result(corrected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=ucs4, len=:), allocatable Variables Type Visibility Attributes Name Initial character(kind=ucs4, len=255), public :: line integer, public :: lun Source Code function utf8_to_utf32 ( string ) result ( corrected ) character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = 255 , kind = ucs4 ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) string rewind ( lun ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) open ( output_unit , encoding = 'UTF-8' ) end function utf8_to_utf32","tags":"","url":"proc/utf8_to_utf32.html"},{"title":"create_date_string – M_time","text":"subroutine create_date_string(string) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*) :: string Variables Type Visibility Attributes Name Initial character(kind=ucs4, len=1), public, parameter :: gatsu = char(int(z'6708'), ucs4) character(kind=ucs4, len=1), public, parameter :: nen = char(int(z'5e74'), ucs4) character(kind=ucs4, len=1), public, parameter :: nichi = char(int(z'65e5'), ucs4) integer, public, parameter :: ucs4 = selected_char_kind(\"ISO_10646\") integer, public :: values (8) Source Code subroutine create_date_string ( string ) intrinsic date_and_time , selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = 1 , kind = ucs4 ), parameter :: & nen = char ( int ( z '5e74' ), ucs4 ), & ! year gatsu = char ( int ( z '6708' ), ucs4 ), & ! month nichi = char ( int ( z '65e5' ), ucs4 ) ! day character ( len = * , kind = ucs4 ) string integer values ( 8 ) call date_and_time ( values = values ) write ( string , 101 ) values ( 1 ), nen , values ( 2 ), gatsu , values ( 3 ), nichi 101 format ( * ( i0 , a )) end subroutine create_date_string","tags":"","url":"proc/create_date_string.html"},{"title":"M_utf8 – M_time","text":"Uses iso_fortran_env Functions public  function ucs4_to_utf8 (ucs4_string, err) result(string) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ucs4_string integer, intent(out), optional :: err Return Value character(kind=ascii, len=:), allocatable public  function ucs4_to_utf8_via_io (ucs4_string) result(corrected) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ucs4_string Return Value character(kind=ascii, len=:), allocatable public  function utf8_to_ucs4 (string) result(corrected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=ucs4, len=:), allocatable public  function utf8_to_ucs4_via_io (string) result(corrected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=ucs4, len=:), allocatable Subroutines public  subroutine codepoints_to_utf8 (codepoints, string, err) Arguments Type Intent Optional Attributes Name integer, intent(in) :: codepoints (:) character(kind=ascii, len=:), allocatable :: string integer, intent(out), optional :: err public  subroutine utf8_to_codepoints (utf8, out, err) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: utf8 integer, intent(out), allocatable :: out (:) integer, intent(out) :: err","tags":"","url":"module/m_utf8.html"},{"title":"unifile_to_ftn – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(len=80) :: count character(len=*), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character(len=*), parameter :: g = '(*(g0))' integer :: i integer :: iostat integer :: j integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(kind=ucs4, len=4096) :: uline Source Code program unifile_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string as char(3f) calls use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stdin => input_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' character ( len = 80 ) :: count integer :: i , j , iostat character ( len = 4096 , kind = ucs4 ) :: uline open ( stdin , encoding = 'UTF-8' ) open ( stdout , encoding = 'UTF-8' ) write ( stdout , g ) 'program testit' write ( stdout , g ) 'use, intrinsic :: iso_fortran_env, only : output_unit' write ( stdout , g ) \"integer, parameter :: ucs4 = selected_char_kind ('ISO_10646')\" write ( stdout , g ) \"   open (output_unit, encoding='utf-8')\" do j = 1 , huge ( 0 ) - 1 read ( stdin , '(a)' , iostat = iostat ) uline if ( iostat . ne . 0 ) exit write ( count , g ) \"variable_\" , j , \"= &\" write ( stdout , g ) 'block' write ( stdout , g ) '! Unicode code points for ' , trim ( uline ) write ( stdout , g ) 'character(len=*,kind=ucs4),parameter :: ' // trim ( count ) write ( stdout , form )( uline ( i : i ), i = 1 , len_trim ( uline )) write ( stdout , g ) \"   write(output_unit,'(a)' )variable_\" , j write ( stdout , g ) 'endblock' enddo write ( stdout , g ) \"end program testit\" end program unifile_to_ftn","tags":"","url":"program/unifile_to_ftn.html"},{"title":"check – M_time","text":"Uses iso_fortran_env M_utf8 Variables Type Attributes Name Initial integer, parameter :: ascii = selected_char_kind(\"ascii\") character(len=:), allocatable :: astr character(kind=ucs4, len=*), parameter :: boz = char(int(z'4E03'), kind=ucs4)//char(int(z'8EE2'), kind=ucs4)//char(int(z'3073'), kind=ucs4)//char(int(z'516B'), kind=ucs4)//char(int(z'8D77'), kind=ucs4)//char(int(z'304D'), kind=ucs4)//char(int(z'3002'), kind=ucs4)//char(int(z'8EE2'), kind=ucs4)//char(int(z'3093'), kind=ucs4)//char(int(z'3067'), kind=ucs4)//char(int(z'3082'), kind=ucs4)//char(int(z'307E'), kind=ucs4)//char(int(z'305F'), kind=ucs4)//char(int(z'7ACB'), kind=ucs4)//char(int(z'3061'), kind=ucs4)//char(int(z'4E0A'), kind=ucs4)//char(int(z'304C'), kind=ucs4)//char(int(z'308B'), kind=ucs4)//char(int(z'3002'), kind=ucs4)//char(int(z'304F'), kind=ucs4)//char(int(z'3058'), kind=ucs4)//char(int(z'3051'), kind=ucs4)//char(int(z'305A'), kind=ucs4)//char(int(z'306B'), kind=ucs4)//char(int(z'524D'), kind=ucs4)//char(int(z'3092'), kind=ucs4)//char(int(z'5411'), kind=ucs4)//char(int(z'3044'), kind=ucs4)//char(int(z'3066'), kind=ucs4)//char(int(z'6B69'), kind=ucs4)//char(int(z'3044'), kind=ucs4)//char(int(z'3066'), kind=ucs4)//char(int(z'3044'), kind=ucs4)//char(int(z'3053'), kind=ucs4)//char(int(z'3046'), kind=ucs4)//char(int(z'3002'), kind=ucs4) integer :: err character(kind=ucs4, len=1) :: stop integer :: total integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(len=*), parameter :: upagain = \"七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。\" character(kind=ucs4, len=:), allocatable :: ustr Subroutines subroutine checkit (label, test) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label logical, intent(in) :: test Source Code program check use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_codepoints , utf8_to_ucs4 , ucs4_to_utf8 , utf8_to_ucs4_via_io , ucs4_to_utf8_via_io implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) ! character ( len =* ), parameter :: upagain = \"七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。\" ! Romanization: ! Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! \"Fall seven times, stand up eight. Even if you fall down, you will get up again. Don't be discouraged, just keep walking forward.\" ! character ( len = 1 , kind = ucs4 ) :: stop character ( len = :, kind = ucs4 ), allocatable :: ustr character ( len = :), allocatable :: astr integer :: total integer :: err ! OUTPUT:七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。 character ( len =* , kind = ucs4 ), parameter :: boz = & char ( int ( z '4E03' ), kind = ucs4 ) // char ( int ( z '8EE2' ), kind = ucs4 ) // char ( int ( z '3073' ), kind = ucs4 ) // & char ( int ( z '516B' ), kind = ucs4 ) // char ( int ( z '8D77' ), kind = ucs4 ) // char ( int ( z '304D' ), kind = ucs4 ) // & char ( int ( z '3002' ), kind = ucs4 ) // char ( int ( z '8EE2' ), kind = ucs4 ) // char ( int ( z '3093' ), kind = ucs4 ) // & char ( int ( z '3067' ), kind = ucs4 ) // char ( int ( z '3082' ), kind = ucs4 ) // char ( int ( z '307E' ), kind = ucs4 ) // & char ( int ( z '305F' ), kind = ucs4 ) // char ( int ( z '7ACB' ), kind = ucs4 ) // char ( int ( z '3061' ), kind = ucs4 ) // & char ( int ( z '4E0A' ), kind = ucs4 ) // char ( int ( z '304C' ), kind = ucs4 ) // char ( int ( z '308B' ), kind = ucs4 ) // & char ( int ( z '3002' ), kind = ucs4 ) // char ( int ( z '304F' ), kind = ucs4 ) // char ( int ( z '3058' ), kind = ucs4 ) // & char ( int ( z '3051' ), kind = ucs4 ) // char ( int ( z '305A' ), kind = ucs4 ) // char ( int ( z '306B' ), kind = ucs4 ) // & char ( int ( z '524D' ), kind = ucs4 ) // char ( int ( z '3092' ), kind = ucs4 ) // char ( int ( z '5411' ), kind = ucs4 ) // & char ( int ( z '3044' ), kind = ucs4 ) // char ( int ( z '3066' ), kind = ucs4 ) // char ( int ( z '6B69' ), kind = ucs4 ) // & char ( int ( z '3044' ), kind = ucs4 ) // char ( int ( z '3066' ), kind = ucs4 ) // char ( int ( z '3044' ), kind = ucs4 ) // & char ( int ( z '3053' ), kind = ucs4 ) // char ( int ( z '3046' ), kind = ucs4 ) // char ( int ( z '3002' ), kind = ucs4 ) total = 0 write ( * , * ) '## utf8_to_ucs4' ustr = utf8_to_ucs4 ( upagain ) write ( * , * ) 'if file is not open for utf-8 encoding automatic conversion does not occur' write ( * , * ) 'utf8:' , upagain ! these are the bytes to represent the utf-8 characters write ( * , * ) 'ucs4:' , ustr ! this is 4-byte unicode that needs converted. Does it print as noise or all \"?\"? write ( * , * ) write ( * , * ) 'encoding can be altered on an open file' open ( output_unit , encoding = 'UTF-8' ) write ( * , * ) 'utf8:' , upagain write ( * , * ) 'ucs4:' , ustr ! so this should get \"automatically\" printed properly now write ( * , * ) stop = ustr ( 7 : 7 ) call checkit ( 'check len() is 36 :' , len ( ustr ) == 36 ) call checkit ( 'check index       :' , index ( ustr , stop , kind = ucs4 , back = . false .) == 7 ) call checkit ( 'check index       :' , index ( ustr , stop , back = . true ., kind = ucs4 ) == len ( ustr ) ) call checkit ( 'storage_size      :' , storage_size ( ustr ) == len ( ustr ) * 4 * 8 ) write ( * , * ) '## ucs4_to_utf8' write ( * , * ) write ( * , * ) 'converted by external routine:' , ucs4_to_utf8 ( boz ) ! it is converted by the routine write ( * , * ) 'converted because file is encoded to utf-8:' , boz ! converted by standard Fortran ! standard method. Note ASCII one-byte characters become 4-byte characters, but multi-byte characters are not recognized ustr = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) astr = ucs4_to_utf8 ( ustr , err ) call checkit ( 'convert to ASCII bytes representing utf8' , astr == 'Hello World and Ni Hao -- 你好' ) if ( total . ne . 0 ) then write ( * , * ) total , 'failures' stop 1 endif contains subroutine checkit ( label , test ) character ( len =* ), intent ( in ) :: label logical , intent ( in ) :: test write ( * , * ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label if (. not . test ) total = total + 1 end subroutine checkit end program check","tags":"","url":"program/check.html"},{"title":"internal_io – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(kind=ascii, len=:), allocatable :: aline character(len=*), parameter :: all = '(*(g0))' integer, parameter :: ascii = selected_char_kind(\"ascii\") character(kind=ascii, len=:), allocatable :: astr character(kind=ucs4, len=1) :: glyph integer :: i integer, parameter :: ucs4 = selected_char_kind(\"ISO_10646\") character(kind=ucs4, len=:), allocatable :: uline character(kind=ucs4, len=:), allocatable :: ustr Source Code program internal_io use iso_fortran_env , only : stdout => output_unit implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = 1 , kind = ucs4 ) :: glyph character ( len =* ), parameter :: all = '(*(g0))' character ( len = :, kind = ascii ), allocatable :: aline character ( len = :, kind = ascii ), allocatable :: astr character ( len = :, kind = ucs4 ), allocatable :: uline character ( len = :, kind = ucs4 ), allocatable :: ustr integer :: i open ( stdout , encoding = 'UTF-8' ) print all , 'unicode UCS-4 string' ustr = ucs4_ 'Hello World and Ni Hao -- ' // char ( int ( z '4F60' ), ucs4 ) // char ( int ( z '597D' ), ucs4 ) write ( * , * ) ustr print all , 'length  :' , len ( ustr ) print all , 'bytes   :' , storage_size ( ustr ) / 8 print all , 'ASCII bytes' astr = 'Hello World and Ni Hao -- 你好' write ( * , * ) astr print all , 'length  :' , len ( astr ) print all , 'bytes   :' , storage_size ( astr ) / 8 ! SHOULD WRITE INTO ASCII CREATE RAW UTF8 OR WHAT? print all , 'UCS4 characters written to ASCII internal file' aline = repeat ( ' ' , len ( ustr )) write ( aline , all ) ustr aline = trim ( aline ) print all , 'length        :' , len ( aline ) print all , 'bytes         :' , storage_size ( aline ) / 8 print all , aline ! SHOULD WRITE INTO UCS4 DO ANYTHING DIFFERENT? print all print all , 'UCS4 characters written to UCS4 internal file' uline = repeat ( ' ' , len ( ustr )) write ( uline , all ) ustr uline = trim ( uline ) print all , 'length        :' , len ( uline ) print all , 'bytes         :' , storage_size ( uline ) / 8 print all , uline ! SHOULD WRITE INTO ASCII CREATE RAW UTF8 OR WHAT? print all , 'ASCII characters into ASCII internal file' aline = repeat ( ' ' , len ( astr )) write ( aline , all ) astr aline = trim ( aline ) print all , 'length        :' , len ( aline ) print all , 'bytes         :' , storage_size ( aline ) / 8 print all , aline ! SHOULD WRITE INTO UCS4 DO ANYTHING DIFFERENT? print all print all , 'ASCII characters into UCS4 internal file' uline = repeat ( ' ' , len ( astr )) write ( uline , all ) astr uline = trim ( uline ) print all , 'length        :' , len ( uline ) print all , 'bytes         :' , storage_size ( uline ) / 8 print all , uline write ( stdout , all )( ichar ( uline ( i : i )), \",\" , i = 1 , len ( uline )) print all , 'And back again' write ( stdout , all ) 'before' , astr write ( stdout , all )( ichar ( astr ( i : i )), \",\" , i = 1 , len ( astr )) read ( uline , '(a)' ) astr write ( stdout , all ) 'after' , astr write ( stdout , all )( ichar ( astr ( i : i )), \",\" , i = 1 , len ( astr )) end program internal_io","tags":"","url":"program/internal_io.html"},{"title":"uni_to_ftn – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial integer :: iostat integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(kind=ucs4, len=1024) :: uline character(kind=ucs4, len=:), allocatable :: ustr Source Code program uni_to_ftn ! simplistically copy a utf8 formatted sequential file from stdin to stdout, prefixing lines with number of glyphs use , intrinsic :: iso_fortran_env , only : output_unit , input_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len = 1024 , kind = ucs4 ) :: uline ! arbitrarily assume maximum line length. Stream I/O could be used instead character ( len = :, kind = ucs4 ), allocatable :: ustr integer :: iostat open ( output_unit , encoding = 'UTF-8' ) open ( input_unit , encoding = 'UTF-8' ) do read ( input_unit , '(a)' , iostat = iostat ) uline if ( iostat . ne . 0 ) exit ustr = trim ( uline ) ! assign and trim() works on 4-byte characters write ( output_unit , '(i9.9,\":\",a)' ) len ( ustr ), ustr ! len()  works on 4-byte characters enddo end program uni_to_ftn","tags":"","url":"program/uni_to_ftn.html"},{"title":"demo_selected_char_kind – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial integer, parameter :: ascii = selected_char_kind(\"ascii\") integer, parameter :: default = selected_char_kind(\"default\") integer :: i integer :: iostat integer, parameter :: ucs4 = selected_char_kind('ISO_10646') Source Code program demo_selected_char_kind ! @(#) report if ISO_10646 is supported use iso_fortran_env implicit none intrinsic selected_char_kind integer :: i integer :: iostat integer , parameter :: default = selected_char_kind ( \"default\" ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) write ( * , * ) 'ASCII     ' , merge ( 'Supported    ' , 'Not Supported' , ascii /= - 1 ), 'KIND=' , ascii write ( * , * ) 'ISO_10646 ' , merge ( 'Supported    ' , 'Not Supported' , ucs4 /= - 1 ), 'KIND=' , ucs4 write ( * , * ) 'DEFAULT   ' , merge ( 'Supported    ' , 'Not Supported' , default /= - 1 ), 'KIND=' , default if ( default . eq . ascii ) then write ( * , * ) 'ASCII is the same as the default on this processor' endif write ( * , * ) write ( * , * ) 'print 1-byte values (from 0 to 255) as characters:' write ( * , * ) ' only 0 to 127 is defined in ASCII, 128-255 specifically not defined in UTF-8;' write ( * , * ) ' but often used for extended ASCII such as latin1 or latin2 encoding, or extended' write ( * , * ) ' characters such as box characters. If your default output is utf-8 values above' write ( * , * ) ' 127 should be a question mark or a shaded box' !  ENCODING= might not be supported open ( output_unit , encoding = 'utf-8' , iostat = iostat ) if ( iostat . ne . 0 ) then write ( * , * ) 'utf-8 encoding not supported' else write ( * , '(10(i3,1x,a,1x))' )( i , char ( i , kind = ucs4 ), i = 0 , 255 ) endif write ( * , * ) write ( * , * ) 'printing the bytes directly' write ( * , * ) 'with encoding=\"ASCII\"' open ( output_unit , encoding = 'ascii' , iostat = iostat ) write ( * , '(10(i3,1x,a,1x))' )( i , i , i = 0 , 255 ) write ( * , * ) 'with encoding=\"UTF-8\"' open ( output_unit , encoding = 'utf-8' , iostat = iostat ) write ( * , '(10(i3,1x,a,1x))' )( i , i , i = 0 , 255 ) write ( * , * ) 'Smiling face with open mouth' , char ( int ( z '1F603' ), kind = ucs4 ) ! 😃 write ( * , * ) 'Smiling face with open mouth' , char ([ int ( z 'F0' ), int ( z '9F' ), int ( z '98' ), int ( z '83' )], kind = ascii ) ! 😃 end program demo_selected_char_kind","tags":"","url":"program/demo_selected_char_kind.html"},{"title":"uni_to_ftn – M_time","text":"Uses iso_fortran_env M_utf8 Variables Type Attributes Name Initial character(len=:), allocatable :: aline character(len=:), allocatable :: command_line character(len=*), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character(len=*), parameter :: g = '(*(g0))' integer :: i integer :: length integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(kind=ucs4, len=:), allocatable :: ustr Source Code program uni_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string use , intrinsic :: iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: i character ( len = :), allocatable :: aline character ( len = :), allocatable :: command_line character ( len = :, kind = ucs4 ), allocatable :: ustr open ( output_unit , encoding = 'UTF-8' ) call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = adjustl ( command_line ( length + 1 :)) ustr = utf8_to_ucs4 ( command_line ) write ( * , g ) 'program testit' write ( * , g ) 'use, intrinsic :: iso_fortran_env, only : output_unit' write ( * , g ) \"integer, parameter :: ucs4 = selected_char_kind ('ISO_10646')\" write ( * , g ) '! OUTPUT:' , command_line write ( * , g ) 'character(len=*,kind=ucs4),parameter :: variable= &' write ( * , form )( ustr ( i : i ), i = 1 , len ( ustr )) write ( * , g ) \"   open (output_unit, encoding='utf-8')\" write ( * , g ) \"   write(output_unit,'(a)' )variable\" write ( * , g ) \"end program testit\" end program uni_to_ftn","tags":"","url":"program/uni_to_ftn~2.html"},{"title":"count_glyphs – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0))' integer :: i character(len=255) :: iomsg integer :: iostat integer :: length integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(kind=ucs4, len=4096) :: uline Source Code program count_glyphs ! @(#) read a utf-8 file and write it out with lines prefixed with glyph counts of the line use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stdin => input_unit implicit none intrinsic selected_char_kind intrinsic is_iostat_end intrinsic len_trim !------ ! NOTE: we will be using the kind name \"ucs4\" for Unicode variables integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) !------ character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: i integer :: iostat !------ ! NOTE: this character variable is the Unicode kind, not ASCII character ( len = 4096 , kind = ucs4 ) :: uline ! specifies maximum line length of 4096 bytes, ! which might be as few as 1024 (ie. 4096/4) glyphs !------ character ( len = 255 ) :: iomsg !------ ! NOTE: you can change the encoding used for a file dynamically, even on pre-assigned files open ( stdin , encoding = 'UTF-8' ) open ( stdout , encoding = 'UTF-8' ) !------ do read ( stdin , '(a)' , iostat = iostat , iomsg = iomsg ) uline if ( iostat . eq . 0 ) then !------ ! NOTE: LEN_TRIM() works with UCS-4 just as with ASCII length = len_trim ( uline ) !------ !------ ! NOTE: String substrings work just like with ASCII as well write ( stdout , '(i9,\": \",a)' ) length , uline (: length ) !------ elseif ( is_iostat_end ( iostat )) then exit else !------ ! NOTE: ! does the ASCII message have to be converted to UCS-4? ! This will be discussed in detail later, but for now ! remember you can change the encoding of a file dynamically open ( stdout , encoding = 'DEFAULT' ) !------ write ( stdout , g ) '<ERROR>' , trim ( iomsg ) exit endif enddo end program count_glyphs","tags":"","url":"program/count_glyphs.html"},{"title":"test_for_iso_10646 – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial integer, parameter :: ucs4 = selected_char_kind('ISO_10646') Source Code program test_for_iso_10646 use iso_fortran_env , only : output_unit implicit none intrinsic selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) open ( output_unit , encoding = 'utf-8' ) write ( * , * ) 'Smiling face with open mouth' , char ( int ( z '1F603' ), kind = ucs4 ) ! 😃 end program test_for_iso_10646","tags":"","url":"program/test_for_iso_10646.html"},{"title":"testit – M_time","text":"Uses iso_fortran_env M_utf8 Variables Type Attributes Name Initial character(len=:), allocatable :: astr integer :: err integer, parameter :: ucs4 = selected_char_kind(\"ISO_10646\") character(kind=ucs4, len=:), allocatable :: ustr Source Code program testit use iso_fortran_env , only : stdout => output_unit use M_utf8 , only : ucs4_to_utf8 implicit none integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = :, kind = ucs4 ), allocatable :: ustr character ( len = :), allocatable :: astr integer :: err open ( stdout , encoding = 'UTF-8' ) ! standard method ustr = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) write ( stdout , * ) ustr write ( stdout , * ) merge ( 'PASSED' , 'FAILED' , storage_size ( ustr ) /= storage_size ( 'Hello World and Ni Hao -- 你好' ) ) astr = ucs4_to_utf8 ( ustr , err ) write ( stdout , * ) merge ( 'PASSED' , 'FAILED' , astr == 'Hello World and Ni Hao -- 你好' ) write ( stdout , * ) ustr write ( stdout , * ) astr end program testit","tags":"","url":"program/testit.html"},{"title":"uni_to_ftn – M_time","text":"Uses iso_fortran_env M_utf8 Variables Type Attributes Name Initial character(len=:), allocatable :: aline character(len=:), allocatable :: command_line character(len=*), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character(len=*), parameter :: g = '(*(g0))' integer :: i integer :: length integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(kind=ucs4, len=:), allocatable :: ustr Source Code program uni_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string as char(3f) calls use , intrinsic :: iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: i character ( len = :), allocatable :: aline character ( len = :), allocatable :: command_line character ( len = :, kind = ucs4 ), allocatable :: ustr open ( output_unit , encoding = 'UTF-8' ) call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = adjustl ( command_line ( length + 1 :)) ustr = utf8_to_ucs4 ( command_line ) write ( * , g ) 'program testit' write ( * , g ) 'use, intrinsic :: iso_fortran_env, only : output_unit' write ( * , g ) \"integer, parameter :: ucs4 = selected_char_kind ('ISO_10646')\" write ( * , g ) '! OUTPUT:' , command_line write ( * , g ) 'character(len=*,kind=ucs4),parameter :: variable = &' write ( * , form )( ustr ( i : i ), i = 1 , len ( ustr )) write ( * , g ) \"   open (output_unit, encoding='utf-8')\" write ( * , g ) \"   write(output_unit,'(a)' )variable\" write ( * , g ) \"end program testit\" end program uni_to_ftn","tags":"","url":"program/uni_to_ftn~3.html"},{"title":"count_glyphs – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0))' integer :: i character(len=255) :: iomsg integer :: iostat integer :: length integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(kind=ucs4, len=4096) :: uline Source Code program count_glyphs ! @(#) read a utf-8 file and write it out with lines prefixed with glyph count of the line use , intrinsic :: iso_fortran_env , only : output_unit , input_unit implicit none intrinsic selected_char_kind intrinsic is_iostat_end intrinsic len_trim integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: i integer :: iostat character ( len = 4096 , kind = ucs4 ) :: uline ! specifies maximum line length of 4096 bytes, ! which might be as few as 1024 (ie. 4096/4) glyphs character ( len = 255 ) :: iomsg open ( input_unit , encoding = 'UTF-8' ) open ( output_unit , encoding = 'UTF-8' ) do read ( input_unit , '(a)' , iostat = iostat , iomsg = iomsg ) uline if ( iostat . eq . 0 ) then length = len_trim ( uline ) write ( output_unit , '(i9,\": \",a)' ) length , uline (: length ) elseif ( is_iostat_end ( iostat )) then exit else ! does the message have to be converted to ucs-4? write ( output_unit , g ) '<ERROR>' , trim ( iomsg ) exit endif enddo end program count_glyphs","tags":"","url":"program/count_glyphs~2.html"},{"title":"demo_selected_char_kind – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(kind=ascii, len=26) :: alphabet integer, parameter :: ascii = selected_char_kind(\"ascii\") character(kind=ucs4, len=:), allocatable :: corrected integer, parameter :: default = selected_char_kind(\"default\") character(kind=ucs4, len=30) :: hello_world integer :: i character(len=*), parameter :: not_ascii = \"ľščťžýáßĄĘ®™√🙂\" character(kind=ucs4, len=30) :: string integer, parameter :: ucs4 = selected_char_kind('ISO_10646') integer, parameter :: utf8 = selected_char_kind('utf-8') Functions function utf8_to_utf32 (string) result(corrected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=ucs4, len=:), allocatable Subroutines subroutine create_date_string (string) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*) :: string Source Code program demo_selected_char_kind use iso_fortran_env implicit none intrinsic date_and_time , selected_char_kind ! set some aliases for common character kinds ! as the numbers can vary from platform to platform integer , parameter :: default = selected_char_kind ( \"default\" ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) integer , parameter :: utf8 = selected_char_kind ( 'utf-8' ) ! assuming ASCII and UCS4 are supported (ie. not equal to -1) ! define some string variables character ( len = 26 , kind = ascii ) :: alphabet character ( len = 30 , kind = ucs4 ) :: hello_world character ( len = 30 , kind = ucs4 ) :: string character ( len =* ), parameter :: not_ascii = \"ľščťžýáßĄĘ®™√🙂\" character ( len = :, kind = ucs4 ), allocatable :: corrected integer :: i write ( * , * ) 'ASCII     ' ,& & merge ( 'Supported    ' , 'Not Supported' , ascii /= - 1 ) write ( * , * ) 'ISO_10646 ' ,& & merge ( 'Supported    ' , 'Not Supported' , ucs4 /= - 1 ) write ( * , * ) 'UTF-8     ' ,& & merge ( 'Supported    ' , 'Not Supported' , utf8 /= - 1 ) if ( default . eq . ascii ) then write ( * , * ) 'ASCII is the default on this processor' endif ! for constants the kind precedes the value, somewhat like a ! BOZ constant alphabet = ascii_ \"abcdefghijklmnopqrstuvwxyz\" write ( * , * ) alphabet hello_world = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) ! an encoding option is required on OPEN for non-default I/O if ( ucs4 /= - 1 ) then open ( output_unit , encoding = 'UTF-8' ) write ( * , * ) trim ( hello_world ) else write ( * , * ) 'cannot use utf-8' endif call create_date_string ( string ) write ( * , * ) trim ( string ) write ( * , * ) 'NOT_ASCII:' , not_ascii write ( * , * ) 'LEN NOT_ASCII:' , len ( not_ascii ) write ( * , * ) 'STORAGE_SIZE:' , storage_size ( not_ascii ) corrected = utf8_to_utf32 ( not_ascii ) write ( * , * ) 'CORRECTED:' , corrected write ( * , * ) 'LEN CORRECTED:' , len ( corrected ) write ( * , * ) 'STORAGE_SIZE:' , storage_size ( corrected ) do i = 1 , len ( corrected ) write ( * , '(\"z''\",z0,\"''\")' ) corrected ( i : i ) enddo contains ! The following produces a Japanese date stamp. subroutine create_date_string ( string ) intrinsic date_and_time , selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = 1 , kind = ucs4 ), parameter :: & nen = char ( int ( z '5e74' ), ucs4 ), & ! year gatsu = char ( int ( z '6708' ), ucs4 ), & ! month nichi = char ( int ( z '65e5' ), ucs4 ) ! day character ( len = * , kind = ucs4 ) string integer values ( 8 ) call date_and_time ( values = values ) write ( string , 101 ) values ( 1 ), nen , values ( 2 ), gatsu , values ( 3 ), nichi 101 format ( * ( i0 , a )) end subroutine create_date_string function utf8_to_utf32 ( string ) result ( corrected ) character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = 255 , kind = ucs4 ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) string rewind ( lun ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) open ( output_unit , encoding = 'UTF-8' ) end function utf8_to_utf32 end program demo_selected_char_kind","tags":"","url":"program/demo_selected_char_kind~2.html"},{"title":"test_utf8 – M_time","text":"Uses iso_fortran_env M_utf8 Variables Type Attributes Name Initial integer, allocatable :: codepoints (:) character(kind=ucs4, len=:), allocatable :: corrected integer :: err integer :: i character(kind=ucs4, len=1) :: letter character(len=*), parameter :: not_ascii = \"ľščťžýáßĄĘ®™√🙂\" character(len=100) :: s integer, parameter :: ucs4 = selected_char_kind('ISO_10646')","tags":"","url":"program/test_utf8.html"},{"title":"note – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(kind=ucs4, len=*), parameter :: pointer = char(int(z'1FBC1'), kind=ucs4)//char(int(z'1FBC2'), kind=ucs4)//char(int(z'1FBC3'), kind=ucs4) integer, parameter :: ucs4 = selected_char_kind('ISO_10646') Source Code program note use iso_fortran_env , only : output_unit implicit none intrinsic selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* , kind = ucs4 ), parameter :: pointer = char ( int ( z '1FBC1' ), kind = ucs4 ) // & char ( int ( z '1FBC2' ), kind = ucs4 ) // & char ( int ( z '1FBC3' ), kind = ucs4 ) open ( output_unit , encoding = 'UTF-8' ) write ( * , * ) pointer end program note","tags":"","url":"program/note.html"},{"title":"testit – M_time","text":"Uses iso_fortran_env M_utf8 Variables Type Attributes Name Initial character(kind=ascii, len=:), allocatable :: aline character(len=*), parameter :: all = '(*(g0))' integer, parameter :: ascii = selected_char_kind(\"ascii\") character(kind=ucs4, len=1) :: glyph integer :: i character(kind=ucs4, len=:), allocatable :: str integer, parameter :: ucs4 = selected_char_kind(\"ISO_10646\") character(kind=ucs4, len=:), allocatable :: uline Source Code program testit use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 , ucs4_to_utf8_via_io , utf8_to_ucs4_via_io implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = :, kind = ucs4 ), allocatable :: str character ( len = 1 , kind = ucs4 ) :: glyph character ( len =* ), parameter :: all = '(*(g0))' character ( len = :, kind = ascii ), allocatable :: aline character ( len = :, kind = ucs4 ), allocatable :: uline integer :: i open ( output_unit , encoding = 'UTF-8' ) ! standard method str = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) write ( * , * ) str ! converting pseudo-utf8 to ucs4 str = utf8_to_ucs4 ( 'Hello World and Ni Hao -- 你好' ) write ( * , * ) str print all print all , 'intrinsics work with ucs4:' print all , 'slice glyph 27:' , str ( 27 : 27 ) print all , 'length        :' , len ( str ) print all , 'bytes         :' , storage_size ( str ) / 8 glyph = str ( 27 : 27 ) print all , 'index         :' , index ( str , glyph ) write ( * , '(a,i0,\",z''\",z0,\"''\")' ) 'ichar         :' , ichar ( glyph ), glyph glyph = char ( int ( z '597D' ), kind = ucs4 ) print all , 'char          :' , glyph print all , 'repeat        :' , repeat ( str ( 27 : 28 ), 3 ) ! SHOULD WRITE INTO ASCII CREATE RAW UTF8 OR WHAT? print all print all , 'internal write into ascii' aline = repeat ( ' ' , len ( str ) * 4 ) write ( aline , all ) str aline = trim ( aline ) print all , 'length        :' , len ( aline ) print all , 'bytes         :' , storage_size ( aline ) / 8 print all , aline ! SHOULD WRITE INTO UCS4 DO ANYTHING DIFFERENT? print all print all , 'internal write into ucs4' uline = repeat ( ' ' , len ( str )) write ( uline , all ) str uline = trim ( uline ) print all , 'length        :' , len ( uline ) print all , 'bytes         :' , storage_size ( uline ) / 8 print all , uline print all print all , 'raw utf8' print all , 'length        :' , len ( 'Hello World and Ni Hao -- 你好' ) print all , 'bytes         :' , storage_size ( 'Hello World and Ni Hao -- 你好' ) / 8 ! WHAT SHOULD ASSIGN DO? print all print all , 'assign' aline = uline print all , 'length        :' , len ( aline ) print all , 'bytes         :' , storage_size ( aline ) / 8 print all , aline print all print all , 'to be or not to be' ! Ikiru ka shinu ka ! \"to live or die\" str = utf8_to_ucs4 ( '生きるか死ぬか' ) print all , 'ucs4 string:' , str print all , 'reverse:    ' ,( str ( i : i ), i = len ( str ), 1 , - 1 ) print all print all , 'ucs4 to utf8' str = utf8_to_ucs4_via_io ( '生きるか死ぬか' ) aline = ucs4_to_utf8_via_io ( str ) print all , merge ( 'PASSED' , 'FAILED' , aline == '生きるか死ぬか' ) end program testit","tags":"","url":"program/testit~2.html"},{"title":"count_glyphs – M_time","text":"Variables Type Attributes Name Initial character(len=4096) :: aline character(len=255) :: iomsg integer :: iostat integer :: length Source Code program count_glyphs implicit none integer :: length , iostat character ( len = 4096 ) :: aline character ( len = 255 ) :: iomsg do read ( * , '(a)' , iostat = iostat , iomsg = iomsg ) aline if ( iostat . eq . 0 ) then length = len_trim ( aline ) write ( * , '(i9,\": \",a)' ) length , aline (: length ) elseif ( is_iostat_end ( iostat )) then exit else write ( * , '(a)' ) '<ERROR>' , trim ( iomsg ) exit endif enddo end program count_glyphs","tags":"","url":"program/count_glyphs~3.html"},{"title":"multi_line – M_time","text":"Uses iso_fortran_env M_utf8 Variables Type Attributes Name Initial integer, parameter :: ascii = selected_char_kind(\"ascii\") integer :: i integer :: j character(kind=ucs4, len=3) :: line integer :: longest integer, parameter :: ucs4 = selected_char_kind(\"ISO_10646\") character(len=255), parameter :: upagain (3) = [character(len=255)::\"七転び八起き。\", \"転んでもまた立ち上がる。\", \"くじけずに前を向いて歩いていこう。\"] character(kind=ucs4, len=4) :: ustr (size(upagain)) Source Code program multi_line use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) integer :: i , j , longest character ( len = 3 , kind = ucs4 ) :: line character ( len = 255 ), parameter :: upagain ( 3 ) = [ character ( len = 255 ) :: & \"七転び八起き。\" , & \"転んでもまた立ち上がる。\" , & \"くじけずに前を向いて歩いていこう。\" ] ! ! Romanization: ! Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! \"Fall seven times, stand up eight. Even if you fall down, you will get up again. Don't be discouraged, just keep walking forward.\" ! character ( len = 4 * len ( upagain ), kind = ucs4 ) :: ustr ( size ( upagain )) open ( output_unit , encoding = 'UTF-8' ) ! convert pseudo-utf-8 ascii to actual Fortran ucs4 unicode longest = 0 ! get longest trimmed line do i = 1 , size ( upagain ) ustr ( i ) = utf8_to_ucs4 ( upagain ( i )) longest = max ( longest , len_trim ( ustr ( i ))) enddo write ( output_unit , * ) write ( output_unit , * ) 'longest=' , longest write ( output_unit , * )( trim ( ustr ( i )), i = 1 , size ( ustr )) write ( output_unit , * ) ! does not work too well if not a fixed-space font, but even when fixed-spaced having problems in mintty anyway, at least do i = 1 , longest ! not lining up write ( output_unit , '(*(A))' ) ( ustr ( j )( i : i ), j = size ( upagain ), 1 , - 1 ) ! numbers for T seems to be for ASCII bytes !write(output_unit,'(T1,A,T5,A,T9,A)') (ustr(j)(i:i),j=1,size(upagain)) !line=ustr(3)(i:i)//ustr(2)(i:i)//ustr(1)(i:i) !write(*,*)line enddo do i = 1 , longest ! not lining up write ( output_unit , '(*(A))' ) ( ustr ( j )( i : i ), j = 1 , size ( upagain )) enddo end program multi_line","tags":"","url":"program/multi_line.html"},{"title":"shouldit – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(kind=ascii, len=*), parameter :: A = 'ľščťžýáßĄĘ®™√🙂' character(kind=ascii, len=512) :: ALINE character(kind=ucs4, len=*), parameter :: B = char(int(z'13E'), kind=ucs4)//char(int(z'161'), kind=ucs4)//char(int(z'10D'), kind=ucs4)//char(int(z'165'), kind=ucs4)//char(int(z'17E'), kind=ucs4)//char(int(z'FD'), kind=ucs4)//char(int(z'E1'), kind=ucs4)//char(int(z'DF'), kind=ucs4)//char(int(z'104'), kind=ucs4)//char(int(z'118'), kind=ucs4)//char(int(z'AE'), kind=ucs4)//char(int(z'2122'), kind=ucs4)//char(int(z'221A'), kind=ucs4)//char(int(z'1F642'), kind=ucs4) character(kind=ucs4, len=512) :: ULINE integer, parameter :: ascii = selected_char_kind('ASCII') integer, parameter :: ucs4 = selected_char_kind('ISO_10646') Source Code program shouldit use iso_fortran_env , only : output_unit , int64 implicit none intrinsic selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) integer , parameter :: ascii = selected_char_kind ( 'ASCII' ) ! can something in quotes only be encoded as ASCII? !NO!character(len=*,kind=ucs4),parameter :: A=ucs4_'ľščťžýáßĄĘ®™√🙂' !NO!character(len=*,kind=ucs4),parameter :: A='ľščťžýáßĄĘ®™√🙂' character ( len =* , kind = ascii ), parameter :: A = 'ľščťžýáßĄĘ®™√🙂' character ( len = 512 , kind = ucs4 ) :: ULINE character ( len = 512 , kind = ascii ) :: ALINE character ( len =* , kind = ucs4 ), parameter :: B = & char ( int ( z '13E' ), kind = ucs4 ) // & char ( int ( z '161' ), kind = ucs4 ) // & char ( int ( z '10D' ), kind = ucs4 ) // & char ( int ( z '165' ), kind = ucs4 ) // & char ( int ( z '17E' ), kind = ucs4 ) // & char ( int ( z 'FD' ), kind = ucs4 ) // & char ( int ( z 'E1' ), kind = ucs4 ) // & char ( int ( z 'DF' ), kind = ucs4 ) // & char ( int ( z '104' ), kind = ucs4 ) // & char ( int ( z '118' ), kind = ucs4 ) // & char ( int ( z 'AE' ), kind = ucs4 ) // & char ( int ( z '2122' ), kind = ucs4 ) // & char ( int ( z '221A' ), kind = ucs4 ) // & char ( int ( z '1F642' ), kind = ucs4 ) !character(len=1,kind=ucs4),parameter :: C(*)=& !char(int([z'13E',z'161',z'10D',z'165',z'17E',z'FD',z'E1',z'DF',z'104',z'118',z'AE',z'2122',z'221A',z'1F642']),kind=ucs4) open ( output_unit , encoding = 'UTF-8' ) write ( * , * ) 'this is not really UTF-8, it a stream of bytes that has the right values' write ( * , * ) A , len ( A ), storage_size ( A ), A ( 10 : 14 ) write ( * , * ) 'Fortran actually understands this, so slice and intrinsics work correctly' write ( * , * ) B , len ( B ), storage_size ( B ), B ( 10 : 14 ) write ( * , * ) 'The data between the quotes is ASCII so this does not work' write ( * , * ) ucs4_ 'ľ' , ucs4_ 'š' , ucs4_ 'č' , ucs4_ 'ť' , ucs4_ 'ž' , & ucs4_ 'ý' , ucs4_ 'á' , ucs4_ 'ß' , ucs4_ 'Ą' , ucs4_ 'Ę' , & ucs4_ '®' , ucs4_ '™' , ucs4_ '√' , ucs4_ '🙂' write ( * , * ) 'might work but not defined by the standard that I can tell' write ( ULINE , '(A)' ) A write ( * , * ) 'ULINE:' , trim ( ULINE ) write ( * , * ) 'A:' , A write ( * , * ) 'might work but not defined by the standard that I can tell' write ( ALINE , '(A)' ) A write ( * , * ) 'ALINE:' , trim ( ALINE ) write ( * , * ) 'biggest code:' write ( * , * ) 'FFFFFFFF:' , int ( z 'FFFFFFFF' , kind = int64 ) end program shouldit","tags":"","url":"program/shouldit.html"},{"title":"euro – M_time","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(len=1) :: euro0 = '€' character(len=*), parameter :: euro00 = '€' character(kind=ucs4, len=1) :: euro1 = '€' character(kind=ucs4, len=1) :: euro2 = ucs4_'€' character(kind=ucs4, len=1) :: euro3 = char(int(z'20AC'), kind=ucs4) character(len=*), parameter :: g5 = '(*(t3,g0,t9,g0,t16,g0,t22,g0))' integer, parameter :: ucs4 = selected_char_kind('ISO_10646') Source Code program euro use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stdin => input_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: g5 = '(*(t3,g0,t9,g0,t16,g0,t22,g0))' character ( len = 1 ) :: euro0 = '€' character ( len =* ), parameter :: euro00 = '€' character ( len = 1 , kind = ucs4 ) :: euro1 = '€' character ( len = 1 , kind = ucs4 ) :: euro2 = ucs4_ '€' character ( len = 1 , kind = ucs4 ) :: euro3 = char ( int ( z '20AC' ), kind = ucs4 ) write ( stdout , g5 ) 'OUTPUT  LEN    BYTES    KIND' open ( stdout , encoding = 'utf-8' ) write ( stdout , g5 ) euro0 , len ( euro0 ), storage_size ( euro0 ) / 8 , kind ( euro0 ) write ( stdout , g5 ) euro00 , len ( euro00 ), storage_size ( euro00 ) / 8 , kind ( euro00 ) write ( stdout , g5 ) euro1 , len ( euro1 ), storage_size ( euro1 ) / 8 , kind ( euro1 ) write ( stdout , g5 ) euro2 , len ( euro2 ), storage_size ( euro2 ) / 8 , kind ( euro2 ) write ( stdout , g5 ) euro3 , len ( euro3 ), storage_size ( euro3 ) / 8 , kind ( euro3 ) end program euro","tags":"","url":"program/euro.html"},{"title":"multi_line – M_time","text":"Uses iso_fortran_env M_utf8 Variables Type Attributes Name Initial character(len=:), allocatable :: aline integer, parameter :: ascii = selected_char_kind(\"ascii\") integer :: i integer :: j integer :: longest character(kind=ucs4, len=3) :: u3 integer, parameter :: ucs4 = selected_char_kind(\"ISO_10646\") character(kind=ucs4, len=:), allocatable :: uline character(len=255), parameter :: upagain (3) = [character(len=255)::\"七転び八起き。\", \"転んでもまた立ち上がる。\", \"くじけずに前を向いて歩いていこう。\"] character(kind=ucs4, len=4) :: ustr (size(upagain)) Source Code program multi_line use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) integer :: i , j , longest character ( len = 3 , kind = ucs4 ) :: u3 character ( len = 255 ), parameter :: upagain ( 3 ) = [ character ( len = 255 ) :: & \"七転び八起き。\" , & \"転んでもまた立ち上がる。\" , & \"くじけずに前を向いて歩いていこう。\" ] character ( len = 4 * len ( upagain ), kind = ucs4 ) :: ustr ( size ( upagain )) character ( len = :), allocatable :: aline character ( len = :, kind = ucs4 ), allocatable :: uline ! ! Romanization: !    Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! !    \"Fall seven times, stand up eight. !    Even if you fall down, you will get up again. !    Don't be discouraged, just keep walking forward.\" ! open ( output_unit , encoding = 'UTF-8' ) ! convert pseudo-utf-8 ascii to actual Fortran ucs4 unicode longest = 0 ! get longest trimmed line do i = 1 , size ( upagain ) ustr ( i ) = utf8_to_ucs4 ( upagain ( i )) longest = max ( longest , len_trim ( ustr ( i ))) write ( * , * ) 'LEN=' , len_trim ( ustr ( i )) enddo write ( output_unit , * ) 'longest=' , longest write ( output_unit , * ) write ( output_unit , * )( trim ( ustr ( i )), i = 1 , size ( ustr )) write ( output_unit , * ) write ( output_unit , '(A)' ) ( trim ( ustr ( i )), i = 1 , size ( ustr )) write ( output_unit , '(*(z8.8))' ) (( ustr ( i )( j : j ), j = 1 , len_trim ( ustr ( i ))), i = 1 , size ( ustr )) write ( output_unit , * ) aline = '& &00004E0300008EE2000030730000516B00008D770000304D0000300200008EE20000309300003067& &000030820000307E0000305F00007ACB0000306100004E0A0000304C0000308B000030020000304F& &00003058000030510000305A0000306B0000524D0000309200005411000030440000306600006B69& &000030440000306600003044000030530000304600003002' allocate ( character ( len = len ( aline ) / 8 , kind = ucs4 ) :: uline ) !   read(aline,'(z288)') uline read ( aline , '(*(z8.8))' ) ( uline ( i : i ), i = 1 , len ( uline )) write ( output_unit , * ) uline end program multi_line","tags":"","url":"program/multi_line~2.html"},{"title":"unifile_to_ftn.f90 – M_time","text":"Source Code program unifile_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string as char(3f) calls use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stdin => input_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' character ( len = 80 ) :: count integer :: i , j , iostat character ( len = 4096 , kind = ucs4 ) :: uline open ( stdin , encoding = 'UTF-8' ) open ( stdout , encoding = 'UTF-8' ) write ( stdout , g ) 'program testit' write ( stdout , g ) 'use, intrinsic :: iso_fortran_env, only : output_unit' write ( stdout , g ) \"integer, parameter :: ucs4 = selected_char_kind ('ISO_10646')\" write ( stdout , g ) \"   open (output_unit, encoding='utf-8')\" do j = 1 , huge ( 0 ) - 1 read ( stdin , '(a)' , iostat = iostat ) uline if ( iostat . ne . 0 ) exit write ( count , g ) \"variable_\" , j , \"= &\" write ( stdout , g ) 'block' write ( stdout , g ) '! Unicode code points for ' , trim ( uline ) write ( stdout , g ) 'character(len=*,kind=ucs4),parameter :: ' // trim ( count ) write ( stdout , form )( uline ( i : i ), i = 1 , len_trim ( uline )) write ( stdout , g ) \"   write(output_unit,'(a)' )variable_\" , j write ( stdout , g ) 'endblock' enddo write ( stdout , g ) \"end program testit\" end program unifile_to_ftn","tags":"","url":"sourcefile/unifile_to_ftn.f90.html"},{"title":"check.f90 – M_time","text":"Source Code program check use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_codepoints , utf8_to_ucs4 , ucs4_to_utf8 , utf8_to_ucs4_via_io , ucs4_to_utf8_via_io implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) ! character ( len =* ), parameter :: upagain = \"七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。\" ! Romanization: ! Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! \"Fall seven times, stand up eight. Even if you fall down, you will get up again. Don't be discouraged, just keep walking forward.\" ! character ( len = 1 , kind = ucs4 ) :: stop character ( len = :, kind = ucs4 ), allocatable :: ustr character ( len = :), allocatable :: astr integer :: total integer :: err ! OUTPUT:七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。 character ( len =* , kind = ucs4 ), parameter :: boz = & char ( int ( z '4E03' ), kind = ucs4 ) // char ( int ( z '8EE2' ), kind = ucs4 ) // char ( int ( z '3073' ), kind = ucs4 ) // & char ( int ( z '516B' ), kind = ucs4 ) // char ( int ( z '8D77' ), kind = ucs4 ) // char ( int ( z '304D' ), kind = ucs4 ) // & char ( int ( z '3002' ), kind = ucs4 ) // char ( int ( z '8EE2' ), kind = ucs4 ) // char ( int ( z '3093' ), kind = ucs4 ) // & char ( int ( z '3067' ), kind = ucs4 ) // char ( int ( z '3082' ), kind = ucs4 ) // char ( int ( z '307E' ), kind = ucs4 ) // & char ( int ( z '305F' ), kind = ucs4 ) // char ( int ( z '7ACB' ), kind = ucs4 ) // char ( int ( z '3061' ), kind = ucs4 ) // & char ( int ( z '4E0A' ), kind = ucs4 ) // char ( int ( z '304C' ), kind = ucs4 ) // char ( int ( z '308B' ), kind = ucs4 ) // & char ( int ( z '3002' ), kind = ucs4 ) // char ( int ( z '304F' ), kind = ucs4 ) // char ( int ( z '3058' ), kind = ucs4 ) // & char ( int ( z '3051' ), kind = ucs4 ) // char ( int ( z '305A' ), kind = ucs4 ) // char ( int ( z '306B' ), kind = ucs4 ) // & char ( int ( z '524D' ), kind = ucs4 ) // char ( int ( z '3092' ), kind = ucs4 ) // char ( int ( z '5411' ), kind = ucs4 ) // & char ( int ( z '3044' ), kind = ucs4 ) // char ( int ( z '3066' ), kind = ucs4 ) // char ( int ( z '6B69' ), kind = ucs4 ) // & char ( int ( z '3044' ), kind = ucs4 ) // char ( int ( z '3066' ), kind = ucs4 ) // char ( int ( z '3044' ), kind = ucs4 ) // & char ( int ( z '3053' ), kind = ucs4 ) // char ( int ( z '3046' ), kind = ucs4 ) // char ( int ( z '3002' ), kind = ucs4 ) total = 0 write ( * , * ) '## utf8_to_ucs4' ustr = utf8_to_ucs4 ( upagain ) write ( * , * ) 'if file is not open for utf-8 encoding automatic conversion does not occur' write ( * , * ) 'utf8:' , upagain ! these are the bytes to represent the utf-8 characters write ( * , * ) 'ucs4:' , ustr ! this is 4-byte unicode that needs converted. Does it print as noise or all \"?\"? write ( * , * ) write ( * , * ) 'encoding can be altered on an open file' open ( output_unit , encoding = 'UTF-8' ) write ( * , * ) 'utf8:' , upagain write ( * , * ) 'ucs4:' , ustr ! so this should get \"automatically\" printed properly now write ( * , * ) stop = ustr ( 7 : 7 ) call checkit ( 'check len() is 36 :' , len ( ustr ) == 36 ) call checkit ( 'check index       :' , index ( ustr , stop , kind = ucs4 , back = . false .) == 7 ) call checkit ( 'check index       :' , index ( ustr , stop , back = . true ., kind = ucs4 ) == len ( ustr ) ) call checkit ( 'storage_size      :' , storage_size ( ustr ) == len ( ustr ) * 4 * 8 ) write ( * , * ) '## ucs4_to_utf8' write ( * , * ) write ( * , * ) 'converted by external routine:' , ucs4_to_utf8 ( boz ) ! it is converted by the routine write ( * , * ) 'converted because file is encoded to utf-8:' , boz ! converted by standard Fortran ! standard method. Note ASCII one-byte characters become 4-byte characters, but multi-byte characters are not recognized ustr = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) astr = ucs4_to_utf8 ( ustr , err ) call checkit ( 'convert to ASCII bytes representing utf8' , astr == 'Hello World and Ni Hao -- 你好' ) if ( total . ne . 0 ) then write ( * , * ) total , 'failures' stop 1 endif contains subroutine checkit ( label , test ) character ( len =* ), intent ( in ) :: label logical , intent ( in ) :: test write ( * , * ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label if (. not . test ) total = total + 1 end subroutine checkit end program check","tags":"","url":"sourcefile/check.f90.html"},{"title":"internal_io.f90 – M_time","text":"Source Code program internal_io use iso_fortran_env , only : stdout => output_unit implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = 1 , kind = ucs4 ) :: glyph character ( len =* ), parameter :: all = '(*(g0))' character ( len = :, kind = ascii ), allocatable :: aline character ( len = :, kind = ascii ), allocatable :: astr character ( len = :, kind = ucs4 ), allocatable :: uline character ( len = :, kind = ucs4 ), allocatable :: ustr integer :: i open ( stdout , encoding = 'UTF-8' ) print all , 'unicode UCS-4 string' ustr = ucs4_ 'Hello World and Ni Hao -- ' // char ( int ( z '4F60' ), ucs4 ) // char ( int ( z '597D' ), ucs4 ) write ( * , * ) ustr print all , 'length  :' , len ( ustr ) print all , 'bytes   :' , storage_size ( ustr ) / 8 print all , 'ASCII bytes' astr = 'Hello World and Ni Hao -- 你好' write ( * , * ) astr print all , 'length  :' , len ( astr ) print all , 'bytes   :' , storage_size ( astr ) / 8 ! SHOULD WRITE INTO ASCII CREATE RAW UTF8 OR WHAT? print all , 'UCS4 characters written to ASCII internal file' aline = repeat ( ' ' , len ( ustr )) write ( aline , all ) ustr aline = trim ( aline ) print all , 'length        :' , len ( aline ) print all , 'bytes         :' , storage_size ( aline ) / 8 print all , aline ! SHOULD WRITE INTO UCS4 DO ANYTHING DIFFERENT? print all print all , 'UCS4 characters written to UCS4 internal file' uline = repeat ( ' ' , len ( ustr )) write ( uline , all ) ustr uline = trim ( uline ) print all , 'length        :' , len ( uline ) print all , 'bytes         :' , storage_size ( uline ) / 8 print all , uline ! SHOULD WRITE INTO ASCII CREATE RAW UTF8 OR WHAT? print all , 'ASCII characters into ASCII internal file' aline = repeat ( ' ' , len ( astr )) write ( aline , all ) astr aline = trim ( aline ) print all , 'length        :' , len ( aline ) print all , 'bytes         :' , storage_size ( aline ) / 8 print all , aline ! SHOULD WRITE INTO UCS4 DO ANYTHING DIFFERENT? print all print all , 'ASCII characters into UCS4 internal file' uline = repeat ( ' ' , len ( astr )) write ( uline , all ) astr uline = trim ( uline ) print all , 'length        :' , len ( uline ) print all , 'bytes         :' , storage_size ( uline ) / 8 print all , uline write ( stdout , all )( ichar ( uline ( i : i )), \",\" , i = 1 , len ( uline )) print all , 'And back again' write ( stdout , all ) 'before' , astr write ( stdout , all )( ichar ( astr ( i : i )), \",\" , i = 1 , len ( astr )) read ( uline , '(a)' ) astr write ( stdout , all ) 'after' , astr write ( stdout , all )( ichar ( astr ( i : i )), \",\" , i = 1 , len ( astr )) end program internal_io ! in gfortran internal I/O does no encoding or decoding like writing into file opened with encoding='utf-8' ! so ASCII into ASCII but not UCS4 into ASCII, UTF4 into UTF4, but not ASCII into UTF4. Is it an extention ! for internal files to be non-default or non-ASCII? ! The A format is a binary transfer of bytes for integers and reals and everything else accept non-default kind UCS-4 characters ! are converted to and from UTF-8, which breaks with the use of the A format to transfer binary data to formatted files","tags":"","url":"sourcefile/internal_io.f90.html"},{"title":"main.f90 – M_time","text":"Source Code program uni_to_ftn ! simplistically copy a utf8 formatted sequential file from stdin to stdout, prefixing lines with number of glyphs use , intrinsic :: iso_fortran_env , only : output_unit , input_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len = 1024 , kind = ucs4 ) :: uline ! arbitrarily assume maximum line length. Stream I/O could be used instead character ( len = :, kind = ucs4 ), allocatable :: ustr integer :: iostat open ( output_unit , encoding = 'UTF-8' ) open ( input_unit , encoding = 'UTF-8' ) do read ( input_unit , '(a)' , iostat = iostat ) uline if ( iostat . ne . 0 ) exit ustr = trim ( uline ) ! assign and trim() works on 4-byte characters write ( output_unit , '(i9.9,\":\",a)' ) len ( ustr ), ustr ! len()  works on 4-byte characters enddo end program uni_to_ftn","tags":"","url":"sourcefile/main.f90.html"},{"title":"supported.f90 – M_time","text":"Source Code program demo_selected_char_kind ! @(#) report if ISO_10646 is supported use iso_fortran_env implicit none intrinsic selected_char_kind integer :: i integer :: iostat integer , parameter :: default = selected_char_kind ( \"default\" ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) write ( * , * ) 'ASCII     ' , merge ( 'Supported    ' , 'Not Supported' , ascii /= - 1 ), 'KIND=' , ascii write ( * , * ) 'ISO_10646 ' , merge ( 'Supported    ' , 'Not Supported' , ucs4 /= - 1 ), 'KIND=' , ucs4 write ( * , * ) 'DEFAULT   ' , merge ( 'Supported    ' , 'Not Supported' , default /= - 1 ), 'KIND=' , default if ( default . eq . ascii ) then write ( * , * ) 'ASCII is the same as the default on this processor' endif write ( * , * ) write ( * , * ) 'print 1-byte values (from 0 to 255) as characters:' write ( * , * ) ' only 0 to 127 is defined in ASCII, 128-255 specifically not defined in UTF-8;' write ( * , * ) ' but often used for extended ASCII such as latin1 or latin2 encoding, or extended' write ( * , * ) ' characters such as box characters. If your default output is utf-8 values above' write ( * , * ) ' 127 should be a question mark or a shaded box' !  ENCODING= might not be supported open ( output_unit , encoding = 'utf-8' , iostat = iostat ) if ( iostat . ne . 0 ) then write ( * , * ) 'utf-8 encoding not supported' else write ( * , '(10(i3,1x,a,1x))' )( i , char ( i , kind = ucs4 ), i = 0 , 255 ) endif write ( * , * ) write ( * , * ) 'printing the bytes directly' write ( * , * ) 'with encoding=\"ASCII\"' open ( output_unit , encoding = 'ascii' , iostat = iostat ) write ( * , '(10(i3,1x,a,1x))' )( i , i , i = 0 , 255 ) write ( * , * ) 'with encoding=\"UTF-8\"' open ( output_unit , encoding = 'utf-8' , iostat = iostat ) write ( * , '(10(i3,1x,a,1x))' )( i , i , i = 0 , 255 ) write ( * , * ) 'Smiling face with open mouth' , char ( int ( z '1F603' ), kind = ucs4 ) ! 😃 write ( * , * ) 'Smiling face with open mouth' , char ([ int ( z 'F0' ), int ( z '9F' ), int ( z '98' ), int ( z '83' )], kind = ascii ) ! 😃 end program demo_selected_char_kind","tags":"","url":"sourcefile/supported.f90.html"},{"title":"command_line_to_char.f90 – M_time","text":"Source Code program uni_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string use , intrinsic :: iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: i character ( len = :), allocatable :: aline character ( len = :), allocatable :: command_line character ( len = :, kind = ucs4 ), allocatable :: ustr open ( output_unit , encoding = 'UTF-8' ) call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = adjustl ( command_line ( length + 1 :)) ustr = utf8_to_ucs4 ( command_line ) write ( * , g ) 'program testit' write ( * , g ) 'use, intrinsic :: iso_fortran_env, only : output_unit' write ( * , g ) \"integer, parameter :: ucs4 = selected_char_kind ('ISO_10646')\" write ( * , g ) '! OUTPUT:' , command_line write ( * , g ) 'character(len=*,kind=ucs4),parameter :: variable= &' write ( * , form )( ustr ( i : i ), i = 1 , len ( ustr )) write ( * , g ) \"   open (output_unit, encoding='utf-8')\" write ( * , g ) \"   write(output_unit,'(a)' )variable\" write ( * , g ) \"end program testit\" end program uni_to_ftn","tags":"","url":"sourcefile/command_line_to_char.f90.html"},{"title":"count_glyphs.f90 – M_time","text":"Source Code program count_glyphs ! @(#) read a utf-8 file and write it out with lines prefixed with glyph counts of the line use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stdin => input_unit implicit none intrinsic selected_char_kind intrinsic is_iostat_end intrinsic len_trim !------ ! NOTE: we will be using the kind name \"ucs4\" for Unicode variables integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) !------ character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: i integer :: iostat !------ ! NOTE: this character variable is the Unicode kind, not ASCII character ( len = 4096 , kind = ucs4 ) :: uline ! specifies maximum line length of 4096 bytes, ! which might be as few as 1024 (ie. 4096/4) glyphs !------ character ( len = 255 ) :: iomsg !------ ! NOTE: you can change the encoding used for a file dynamically, even on pre-assigned files open ( stdin , encoding = 'UTF-8' ) open ( stdout , encoding = 'UTF-8' ) !------ do read ( stdin , '(a)' , iostat = iostat , iomsg = iomsg ) uline if ( iostat . eq . 0 ) then !------ ! NOTE: LEN_TRIM() works with UCS-4 just as with ASCII length = len_trim ( uline ) !------ !------ ! NOTE: String substrings work just like with ASCII as well write ( stdout , '(i9,\": \",a)' ) length , uline (: length ) !------ elseif ( is_iostat_end ( iostat )) then exit else !------ ! NOTE: ! does the ASCII message have to be converted to UCS-4? ! This will be discussed in detail later, but for now ! remember you can change the encoding of a file dynamically open ( stdout , encoding = 'DEFAULT' ) !------ write ( stdout , g ) '<ERROR>' , trim ( iomsg ) exit endif enddo end program count_glyphs","tags":"","url":"sourcefile/count_glyphs.f90.html"},{"title":"test_for_iso_10646.f90 – M_time","text":"Source Code program test_for_iso_10646 use iso_fortran_env , only : output_unit implicit none intrinsic selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) open ( output_unit , encoding = 'utf-8' ) write ( * , * ) 'Smiling face with open mouth' , char ( int ( z '1F603' ), kind = ucs4 ) ! 😃 end program test_for_iso_10646","tags":"","url":"sourcefile/test_for_iso_10646.f90.html"},{"title":"M_utf8.f90 – M_time","text":"Source Code module M_utf8 use iso_fortran_env , only : error_unit implicit none private public :: utf8_to_codepoints , codepoints_to_utf8 public :: utf8_to_ucs4 , ucs4_to_utf8 public :: utf8_to_ucs4_via_io , ucs4_to_utf8_via_io integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) ! The compiler must support UCS-4 characters integer , parameter :: ascii = selected_char_kind ( 'ascii' ) ! maybe should use default, as ASCII is technically 128, not 256 chars contains subroutine utf8_to_codepoints ( utf8 , out , err ) ! convert utf-8 characters to unicode codepoints (ie. integers) without requiring compiler to support unicode character ( len =* ), intent ( in ) :: utf8 integer , allocatable , intent ( out ) :: out (:) ! Unicode code points integer , intent ( out ) :: err integer :: n_out , len8 integer :: i , b1 , b2 , b3 , b4 integer :: cp , nbytes integer :: temp ( len ( utf8 )) ! big enough to hold all of utf8 even if each byte is a glyph err = 0 len8 = len_trim ( utf8 ) i = 1 n_out = 0 do while ( i <= len8 ) b1 = iachar ( utf8 ( i : i )) if ( b1 < 0 ) b1 = b1 + 256 select case ( b1 ) case ( 0 : 127 ) cp = b1 nbytes = 1 case ( 192 : 223 ) if ( i + 1 > len8 ) then err = 1 return else b2 = iachar ( utf8 ( i + 1 : i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 if ( iand ( b2 , 192 ) /= 128 ) then ; err = 2 ; return ; endif cp = iand ( b1 , 31 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) nbytes = 2 endif case ( 224 : 239 ) if ( i + 2 > len8 ) then err = 1 return else b2 = iachar ( utf8 ( i + 1 : i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 b3 = iachar ( utf8 ( i + 2 : i + 2 )); if ( b3 < 0 ) b3 = b3 + 256 if ( iand ( b2 , 192 ) /= 128 . or . iand ( b3 , 192 ) /= 128 ) then err = 2 return else cp = iand ( b1 , 15 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) cp = ishft ( cp , 6 ) + iand ( b3 , 63 ) nbytes = 3 endif endif case ( 240 : 247 ) if ( i + 3 > len8 ) then err = 1 return else b2 = iachar ( utf8 ( i + 1 : i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 b3 = iachar ( utf8 ( i + 2 : i + 2 )); if ( b3 < 0 ) b3 = b3 + 256 b4 = iachar ( utf8 ( i + 3 : i + 3 )); if ( b4 < 0 ) b4 = b4 + 256 if ( iand ( b2 , 192 ) /= 128 . or . iand ( b3 , 192 ) /= 128 . or . iand ( b4 , 192 ) /= 128 ) then err = 2 return endif cp = iand ( b1 , 7 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) cp = ishft ( cp , 6 ) + iand ( b3 , 63 ) cp = ishft ( cp , 6 ) + iand ( b4 , 63 ) nbytes = 4 endif case default err = 3 return end select if ( n_out >= size ( temp )) then err = 4 return endif n_out = n_out + 1 temp ( n_out ) = cp i = i + nbytes enddo allocate ( out ( n_out )) out = temp ( 1 : n_out ) end subroutine utf8_to_codepoints subroutine codepoints_to_utf8 ( codepoints , string , err ) ! ! converting Unicode code points to UTF-8 ! internally without using I/O directly requires manual implementation of ! the UTF-8 encoding rules because there's no direct intrinsic function ! for this conversion. ! !    UTF-8 is a variable-width encoding that uses 1 to 4 bytes to represent !    Unicode characters. ! !    The number of bytes depends on the value of the Unicode code point: !        0x0000  - 0x007F (ASCII): 1 byte (0xxxxxxx). !        0x0080  - 0x07FF: 2 bytes (110xxxxx 10xxxxxx). !        0x0800  - 0xFFFF (Basic Multilingual Plane): 3 bytes (1110xxxx 10xxxxxx 10xxxxxx). !        0x10000 - 0x10FFFF (Supplementary Planes): 4 bytes (11110xxx 10xxxxxx 10xxxxxx 10xxxxxx). ! !    Continuation bytes in multi-byte sequences always start with the !    bit pattern 10xxxxxx. ! ! Conversion Algorithm (Conceptual Example) ! ! Iterate through the 4-byte codepoint integers, each of which identifies a unicode glyph. ! Apply the UTF-8 encoding rules based on the code point's value to ! build a new byte array or a character string with character(len=1) elements, representing the ! UTF-8 sequence. ! ! The Unicode standard doesn't require a BOM for UTF-8, but it may be ! encountered at the start of files. This internal conversion doesn't ! add a BOM. ! ! This procedure does not explicitly handle surrogate pairs, which are ! used in UTF-16 to represent characters outside the Basic Multilingual ! Plane. Since UCS-4 already directly represents code points, surrogates ! are not a direct concern for UCS-4 to UTF-8 conversion, but it's ! good to be aware of them when dealing with other Unicode encodings. ! use iso_fortran_env , only : error_unit integer , intent ( in ) :: codepoints (:) integer , intent ( out ), optional :: err character ( len = :, kind = ascii ), allocatable :: string ! utf8_bytes stores the resulting UTF-8 byte sequence. It's declared ! with kind=ascii and a length determined by the maximum possible ! bytes for the UCS-4 string length (each UCS-4 character can be up ! to 4 bytes in UTF-8). character ( len = size ( codepoints ) * 4 ) :: utf8_bytes ! Max 4 bytes per UCS-4 char integer :: i , j , code_point integer :: num_bytes , utf8_index integer , dimension ( 4 ) :: utf8_code utf8_index = 1 if ( present ( err )) err = 0 do i = 1 , size ( codepoints ) ! iterate through each UCS-4 character. code_point = codepoints ( i ) ! Get the integer value of the UCS-4 char ! The if/elseif statements check the code point value and determine ! the number of bytes required for UTF-8 encoding. ! ! Bitwise operations (ior, ishft, iand) are used to construct the ! individual UTF-8 bytes according to the standard rules. ! if ( code_point < int ( z '80' ) ) then ! 1-byte UTF-8 (ASCII) num_bytes = 1 utf8_code ( 1 ) = code_point else if ( code_point < int ( z '800' ) ) then ! 2-byte UTF-8 num_bytes = 2 utf8_code ( 1 ) = ior ( z 'C0' , ishft ( code_point , - 6 )) utf8_code ( 2 ) = ior ( z '80' , iand ( code_point , z '3F' )) else if ( code_point < int ( z '10000' ) ) then ! 3-byte UTF-8 num_bytes = 3 utf8_code ( 1 ) = ior ( z 'E0' , ishft ( code_point , - 12 )) utf8_code ( 2 ) = ior ( z '80' , iand ( ishft ( code_point , - 6 ), z '3F' )) utf8_code ( 3 ) = ior ( z '80' , iand ( code_point , z '3F' )) else if ( code_point < int ( z '110000' ) ) then ! 4-byte UTF-8 num_bytes = 4 utf8_code ( 1 ) = ior ( z 'F0' , ishft ( code_point , - 18 )) utf8_code ( 2 ) = ior ( z '80' , iand ( ishft ( code_point , - 12 ), z '3F' )) utf8_code ( 3 ) = ior ( z '80' , iand ( ishft ( code_point , - 6 ), z '3F' )) utf8_code ( 4 ) = ior ( z '80' , iand ( code_point , z '3F' )) else ! Handle invalid code points or error conditions as needed write ( error_unit , * ) \"Error: Invalid Unicode code point:\" , code_point if (. not . present ( err )) stop 1 err = err + 1 cycle endif ! Append the UTF-8 bytes to the utf8_bytes string do j = 1 , num_bytes ! The utf8_bytes string is built byte by byte using char with kind=ascii. utf8_bytes ( utf8_index : utf8_index ) = char ( utf8_code ( j ), kind = ascii ) utf8_index = utf8_index + 1 enddo enddo string = trim ( utf8_bytes ( 1 : utf8_index - 1 )) ! the UTF-8 byte sequence end subroutine codepoints_to_utf8 function utf8_to_ucs4 ( string ) result ( corrected ) ! return a string of kind ucs4 from bytes representing utf8 glyphs character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected integer , allocatable :: codepoints (:) integer :: i , n integer :: err call utf8_to_codepoints ( string , codepoints , err ) n = size ( codepoints ) allocate ( character ( len = n , kind = ucs4 ) :: corrected ) do i = 1 , n corrected ( i : i ) = char ( codepoints ( i ), kind = ucs4 ) enddo end function utf8_to_ucs4 function ucs4_to_utf8 ( ucs4_string , err ) result ( string ) ! return bytes representing utf8 glyphs from a string of kind ucs4 character ( len =* , kind = ucs4 ), intent ( in ) :: ucs4_string ! stores the UCS-4 string. integer , intent ( out ), optional :: err character ( len = :, kind = ascii ), allocatable :: string integer :: codepoints ( len ( ucs4_string )) integer :: i codepoints = [( ichar ( ucs4_string ( i : i )), i = 1 , len ( ucs4_string ))] call codepoints_to_utf8 ( codepoints , string , err ) end function ucs4_to_utf8 function utf8_to_ucs4_via_io ( string ) result ( corrected ) character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = ( len ( string )), kind = ucs4 ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) string rewind ( lun ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function utf8_to_ucs4_via_io function ucs4_to_utf8_via_io ( ucs4_string ) result ( corrected ) character ( len =* , kind = ucs4 ), intent ( in ) :: ucs4_string character ( len = :, kind = ascii ), allocatable :: corrected character ( len = ( len ( ucs4_string ) * 4 ), kind = ascii ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) ucs4_string rewind ( lun ) open ( unit = lun , encoding = 'default' ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function ucs4_to_utf8_via_io end module M_utf8","tags":"","url":"sourcefile/m_utf8.f90.html"},{"title":"utf8_to_ucs4.f90 – M_time","text":"Source Code program testit use iso_fortran_env , only : stdout => output_unit use M_utf8 , only : ucs4_to_utf8 implicit none integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = :, kind = ucs4 ), allocatable :: ustr character ( len = :), allocatable :: astr integer :: err open ( stdout , encoding = 'UTF-8' ) ! standard method ustr = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) write ( stdout , * ) ustr write ( stdout , * ) merge ( 'PASSED' , 'FAILED' , storage_size ( ustr ) /= storage_size ( 'Hello World and Ni Hao -- 你好' ) ) astr = ucs4_to_utf8 ( ustr , err ) write ( stdout , * ) merge ( 'PASSED' , 'FAILED' , astr == 'Hello World and Ni Hao -- 你好' ) write ( stdout , * ) ustr write ( stdout , * ) astr end program testit","tags":"","url":"sourcefile/utf8_to_ucs4.f90.html"},{"title":"uni_to_ftn.f90 – M_time","text":"Source Code program uni_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string as char(3f) calls use , intrinsic :: iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: i character ( len = :), allocatable :: aline character ( len = :), allocatable :: command_line character ( len = :, kind = ucs4 ), allocatable :: ustr open ( output_unit , encoding = 'UTF-8' ) call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = adjustl ( command_line ( length + 1 :)) ustr = utf8_to_ucs4 ( command_line ) write ( * , g ) 'program testit' write ( * , g ) 'use, intrinsic :: iso_fortran_env, only : output_unit' write ( * , g ) \"integer, parameter :: ucs4 = selected_char_kind ('ISO_10646')\" write ( * , g ) '! OUTPUT:' , command_line write ( * , g ) 'character(len=*,kind=ucs4),parameter :: variable = &' write ( * , form )( ustr ( i : i ), i = 1 , len ( ustr )) write ( * , g ) \"   open (output_unit, encoding='utf-8')\" write ( * , g ) \"   write(output_unit,'(a)' )variable\" write ( * , g ) \"end program testit\" end program uni_to_ftn","tags":"","url":"sourcefile/uni_to_ftn.f90.html"},{"title":"count_glyphs.f90 – M_time","text":"Source Code program count_glyphs ! @(#) read a utf-8 file and write it out with lines prefixed with glyph count of the line use , intrinsic :: iso_fortran_env , only : output_unit , input_unit implicit none intrinsic selected_char_kind intrinsic is_iostat_end intrinsic len_trim integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: i integer :: iostat character ( len = 4096 , kind = ucs4 ) :: uline ! specifies maximum line length of 4096 bytes, ! which might be as few as 1024 (ie. 4096/4) glyphs character ( len = 255 ) :: iomsg open ( input_unit , encoding = 'UTF-8' ) open ( output_unit , encoding = 'UTF-8' ) do read ( input_unit , '(a)' , iostat = iostat , iomsg = iomsg ) uline if ( iostat . eq . 0 ) then length = len_trim ( uline ) write ( output_unit , '(i9,\": \",a)' ) length , uline (: length ) elseif ( is_iostat_end ( iostat )) then exit else ! does the message have to be converted to ucs-4? write ( output_unit , g ) '<ERROR>' , trim ( iomsg ) exit endif enddo end program count_glyphs","tags":"","url":"sourcefile/count_glyphs.f90~2.html"},{"title":"supported.f90 – M_time","text":"Source Code program demo_selected_char_kind use iso_fortran_env implicit none intrinsic date_and_time , selected_char_kind ! set some aliases for common character kinds ! as the numbers can vary from platform to platform integer , parameter :: default = selected_char_kind ( \"default\" ) integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) integer , parameter :: utf8 = selected_char_kind ( 'utf-8' ) ! assuming ASCII and UCS4 are supported (ie. not equal to -1) ! define some string variables character ( len = 26 , kind = ascii ) :: alphabet character ( len = 30 , kind = ucs4 ) :: hello_world character ( len = 30 , kind = ucs4 ) :: string character ( len =* ), parameter :: not_ascii = \"ľščťžýáßĄĘ®™√🙂\" character ( len = :, kind = ucs4 ), allocatable :: corrected integer :: i write ( * , * ) 'ASCII     ' ,& & merge ( 'Supported    ' , 'Not Supported' , ascii /= - 1 ) write ( * , * ) 'ISO_10646 ' ,& & merge ( 'Supported    ' , 'Not Supported' , ucs4 /= - 1 ) write ( * , * ) 'UTF-8     ' ,& & merge ( 'Supported    ' , 'Not Supported' , utf8 /= - 1 ) if ( default . eq . ascii ) then write ( * , * ) 'ASCII is the default on this processor' endif ! for constants the kind precedes the value, somewhat like a ! BOZ constant alphabet = ascii_ \"abcdefghijklmnopqrstuvwxyz\" write ( * , * ) alphabet hello_world = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) ! an encoding option is required on OPEN for non-default I/O if ( ucs4 /= - 1 ) then open ( output_unit , encoding = 'UTF-8' ) write ( * , * ) trim ( hello_world ) else write ( * , * ) 'cannot use utf-8' endif call create_date_string ( string ) write ( * , * ) trim ( string ) write ( * , * ) 'NOT_ASCII:' , not_ascii write ( * , * ) 'LEN NOT_ASCII:' , len ( not_ascii ) write ( * , * ) 'STORAGE_SIZE:' , storage_size ( not_ascii ) corrected = utf8_to_utf32 ( not_ascii ) write ( * , * ) 'CORRECTED:' , corrected write ( * , * ) 'LEN CORRECTED:' , len ( corrected ) write ( * , * ) 'STORAGE_SIZE:' , storage_size ( corrected ) do i = 1 , len ( corrected ) write ( * , '(\"z''\",z0,\"''\")' ) corrected ( i : i ) enddo contains ! The following produces a Japanese date stamp. subroutine create_date_string ( string ) intrinsic date_and_time , selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = 1 , kind = ucs4 ), parameter :: & nen = char ( int ( z '5e74' ), ucs4 ), & ! year gatsu = char ( int ( z '6708' ), ucs4 ), & ! month nichi = char ( int ( z '65e5' ), ucs4 ) ! day character ( len = * , kind = ucs4 ) string integer values ( 8 ) call date_and_time ( values = values ) write ( string , 101 ) values ( 1 ), nen , values ( 2 ), gatsu , values ( 3 ), nichi 101 format ( * ( i0 , a )) end subroutine create_date_string function utf8_to_utf32 ( string ) result ( corrected ) character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = 255 , kind = ucs4 ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) string rewind ( lun ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) open ( output_unit , encoding = 'UTF-8' ) end function utf8_to_utf32 end program demo_selected_char_kind","tags":"","url":"sourcefile/supported.f90~2.html"},{"title":"codepoints.f90 – M_time","text":"Source Code program test_utf8 use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 , utf8_to_codepoints , utf8_to_ucs4_via_io implicit none character ( len = 100 ) :: s integer , allocatable :: codepoints (:) integer :: i , err intrinsic selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: not_ascii = \"ľščťžýáßĄĘ®™√🙂\" character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = 1 , kind = ucs4 ) :: letter s = \"Héllo 🌍\" ! UTF-8 input string call utf8_to_codepoints ( s , codepoints , err ) if ( err /= 0 ) then print * , \"Decode error:\" , err else print * , \"Code points:\" do i = 1 , size ( codepoints ) write ( * , '(\"U+\",Z8.8)' ) codepoints ( i ) enddo endif !Code points: !U+00000048 !U+000000E9 !U+0000006C !U+0000006C !U+0000006F !U+0001F30D open ( output_unit , encoding = 'UTF-8' ) write ( * , * ) call utf8_to_codepoints ( not_ascii , codepoints , err ) write ( * , * ) 'SIZE:' , size ( codepoints ), merge ( 'PASSED' , 'FAILED' , size ( codepoints ) == 14 ) write ( * , '(*(a))' ) char ( codepoints , kind = ucs4 ) write ( * , '(\"UNICODE NOTATION:\",T20,*(\"U+\",z6.6:,\" \"))' ) codepoints write ( * , '(\"HTML:\",T20,*(\"&#x\",z0,\";\":))' ) codepoints write ( * , '(\"C/PYTHON:\",T20,*(\"\\U\",z8.8:))' ) codepoints write ( * , * ) write ( * , * ) 'properly converted to ucs4' corrected = utf8_to_ucs4 ( not_ascii ) write ( * , * ) 'CORRECTED:' , corrected write ( * , * ) 'LEN CORRECTED:' , len ( corrected ) write ( * , * ) 'STORAGE_SIZE:' , storage_size ( corrected ) write ( * , * ) 'so now slicing, intrinsics, ... work!!' letter = corrected ( 14 : 14 ) write ( * , * ) '14th character' , letter write ( * , * ) 'index position' , index ( corrected , letter ) write ( * , * ) write ( * , * ) 'properly converted to ucs4 via I/O' corrected = utf8_to_ucs4_via_io ( not_ascii ) write ( * , * ) 'CORRECTED:' , corrected write ( * , * ) 'LEN CORRECTED:' , len ( corrected ) write ( * , * ) 'STORAGE_SIZE:' , storage_size ( corrected ) write ( * , * ) 'so now slicing, intrinsics, ... work!!' letter = corrected ( 14 : 14 ) write ( * , * ) '14th character' , letter write ( * , * ) 'index position' , index ( corrected , letter ) write ( * , * ) write ( * , * ) 'variable= &' write ( * , '((\"  char(int(z''\",z0,\"''),kind=ucs4)\",:,\", &\"))' )( corrected ( i : i ), i = 1 , len ( corrected )) end program","tags":"","url":"sourcefile/codepoints.f90.html"},{"title":"note.f90 – M_time","text":"Source Code program note use iso_fortran_env , only : output_unit implicit none intrinsic selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* , kind = ucs4 ), parameter :: pointer = char ( int ( z '1FBC1' ), kind = ucs4 ) // & char ( int ( z '1FBC2' ), kind = ucs4 ) // & char ( int ( z '1FBC3' ), kind = ucs4 ) open ( output_unit , encoding = 'UTF-8' ) write ( * , * ) pointer end program note","tags":"","url":"sourcefile/note.f90.html"},{"title":"hello.f90 – M_time","text":"Source Code program testit use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 , ucs4_to_utf8_via_io , utf8_to_ucs4_via_io implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) character ( len = :, kind = ucs4 ), allocatable :: str character ( len = 1 , kind = ucs4 ) :: glyph character ( len =* ), parameter :: all = '(*(g0))' character ( len = :, kind = ascii ), allocatable :: aline character ( len = :, kind = ucs4 ), allocatable :: uline integer :: i open ( output_unit , encoding = 'UTF-8' ) ! standard method str = ucs4_ 'Hello World and Ni Hao -- ' & // char ( int ( z '4F60' ), ucs4 ) & // char ( int ( z '597D' ), ucs4 ) write ( * , * ) str ! converting pseudo-utf8 to ucs4 str = utf8_to_ucs4 ( 'Hello World and Ni Hao -- 你好' ) write ( * , * ) str print all print all , 'intrinsics work with ucs4:' print all , 'slice glyph 27:' , str ( 27 : 27 ) print all , 'length        :' , len ( str ) print all , 'bytes         :' , storage_size ( str ) / 8 glyph = str ( 27 : 27 ) print all , 'index         :' , index ( str , glyph ) write ( * , '(a,i0,\",z''\",z0,\"''\")' ) 'ichar         :' , ichar ( glyph ), glyph glyph = char ( int ( z '597D' ), kind = ucs4 ) print all , 'char          :' , glyph print all , 'repeat        :' , repeat ( str ( 27 : 28 ), 3 ) ! SHOULD WRITE INTO ASCII CREATE RAW UTF8 OR WHAT? print all print all , 'internal write into ascii' aline = repeat ( ' ' , len ( str ) * 4 ) write ( aline , all ) str aline = trim ( aline ) print all , 'length        :' , len ( aline ) print all , 'bytes         :' , storage_size ( aline ) / 8 print all , aline ! SHOULD WRITE INTO UCS4 DO ANYTHING DIFFERENT? print all print all , 'internal write into ucs4' uline = repeat ( ' ' , len ( str )) write ( uline , all ) str uline = trim ( uline ) print all , 'length        :' , len ( uline ) print all , 'bytes         :' , storage_size ( uline ) / 8 print all , uline print all print all , 'raw utf8' print all , 'length        :' , len ( 'Hello World and Ni Hao -- 你好' ) print all , 'bytes         :' , storage_size ( 'Hello World and Ni Hao -- 你好' ) / 8 ! WHAT SHOULD ASSIGN DO? print all print all , 'assign' aline = uline print all , 'length        :' , len ( aline ) print all , 'bytes         :' , storage_size ( aline ) / 8 print all , aline print all print all , 'to be or not to be' ! Ikiru ka shinu ka ! \"to live or die\" str = utf8_to_ucs4 ( '生きるか死ぬか' ) print all , 'ucs4 string:' , str print all , 'reverse:    ' ,( str ( i : i ), i = len ( str ), 1 , - 1 ) print all print all , 'ucs4 to utf8' str = utf8_to_ucs4_via_io ( '生きるか死ぬか' ) aline = ucs4_to_utf8_via_io ( str ) print all , merge ( 'PASSED' , 'FAILED' , aline == '生きるか死ぬか' ) end program testit","tags":"","url":"sourcefile/hello.f90.html"},{"title":"xx.f90 – M_time","text":"Source Code program count_glyphs implicit none integer :: length , iostat character ( len = 4096 ) :: aline character ( len = 255 ) :: iomsg do read ( * , '(a)' , iostat = iostat , iomsg = iomsg ) aline if ( iostat . eq . 0 ) then length = len_trim ( aline ) write ( * , '(i9,\": \",a)' ) length , aline (: length ) elseif ( is_iostat_end ( iostat )) then exit else write ( * , '(a)' ) '<ERROR>' , trim ( iomsg ) exit endif enddo end program count_glyphs","tags":"","url":"sourcefile/xx.f90.html"},{"title":"multi_line.f90 – M_time","text":"Source Code program multi_line use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) integer :: i , j , longest character ( len = 3 , kind = ucs4 ) :: line character ( len = 255 ), parameter :: upagain ( 3 ) = [ character ( len = 255 ) :: & \"七転び八起き。\" , & \"転んでもまた立ち上がる。\" , & \"くじけずに前を向いて歩いていこう。\" ] ! ! Romanization: ! Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! \"Fall seven times, stand up eight. Even if you fall down, you will get up again. Don't be discouraged, just keep walking forward.\" ! character ( len = 4 * len ( upagain ), kind = ucs4 ) :: ustr ( size ( upagain )) open ( output_unit , encoding = 'UTF-8' ) ! convert pseudo-utf-8 ascii to actual Fortran ucs4 unicode longest = 0 ! get longest trimmed line do i = 1 , size ( upagain ) ustr ( i ) = utf8_to_ucs4 ( upagain ( i )) longest = max ( longest , len_trim ( ustr ( i ))) enddo write ( output_unit , * ) write ( output_unit , * ) 'longest=' , longest write ( output_unit , * )( trim ( ustr ( i )), i = 1 , size ( ustr )) write ( output_unit , * ) ! does not work too well if not a fixed-space font, but even when fixed-spaced having problems in mintty anyway, at least do i = 1 , longest ! not lining up write ( output_unit , '(*(A))' ) ( ustr ( j )( i : i ), j = size ( upagain ), 1 , - 1 ) ! numbers for T seems to be for ASCII bytes !write(output_unit,'(T1,A,T5,A,T9,A)') (ustr(j)(i:i),j=1,size(upagain)) !line=ustr(3)(i:i)//ustr(2)(i:i)//ustr(1)(i:i) !write(*,*)line enddo do i = 1 , longest ! not lining up write ( output_unit , '(*(A))' ) ( ustr ( j )( i : i ), j = 1 , size ( upagain )) enddo end program multi_line","tags":"","url":"sourcefile/multi_line.f90.html"},{"title":"question.f90 – M_time","text":"Source Code program shouldit use iso_fortran_env , only : output_unit , int64 implicit none intrinsic selected_char_kind integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) integer , parameter :: ascii = selected_char_kind ( 'ASCII' ) ! can something in quotes only be encoded as ASCII? !NO!character(len=*,kind=ucs4),parameter :: A=ucs4_'ľščťžýáßĄĘ®™√🙂' !NO!character(len=*,kind=ucs4),parameter :: A='ľščťžýáßĄĘ®™√🙂' character ( len =* , kind = ascii ), parameter :: A = 'ľščťžýáßĄĘ®™√🙂' character ( len = 512 , kind = ucs4 ) :: ULINE character ( len = 512 , kind = ascii ) :: ALINE character ( len =* , kind = ucs4 ), parameter :: B = & char ( int ( z '13E' ), kind = ucs4 ) // & char ( int ( z '161' ), kind = ucs4 ) // & char ( int ( z '10D' ), kind = ucs4 ) // & char ( int ( z '165' ), kind = ucs4 ) // & char ( int ( z '17E' ), kind = ucs4 ) // & char ( int ( z 'FD' ), kind = ucs4 ) // & char ( int ( z 'E1' ), kind = ucs4 ) // & char ( int ( z 'DF' ), kind = ucs4 ) // & char ( int ( z '104' ), kind = ucs4 ) // & char ( int ( z '118' ), kind = ucs4 ) // & char ( int ( z 'AE' ), kind = ucs4 ) // & char ( int ( z '2122' ), kind = ucs4 ) // & char ( int ( z '221A' ), kind = ucs4 ) // & char ( int ( z '1F642' ), kind = ucs4 ) !character(len=1,kind=ucs4),parameter :: C(*)=& !char(int([z'13E',z'161',z'10D',z'165',z'17E',z'FD',z'E1',z'DF',z'104',z'118',z'AE',z'2122',z'221A',z'1F642']),kind=ucs4) open ( output_unit , encoding = 'UTF-8' ) write ( * , * ) 'this is not really UTF-8, it a stream of bytes that has the right values' write ( * , * ) A , len ( A ), storage_size ( A ), A ( 10 : 14 ) write ( * , * ) 'Fortran actually understands this, so slice and intrinsics work correctly' write ( * , * ) B , len ( B ), storage_size ( B ), B ( 10 : 14 ) write ( * , * ) 'The data between the quotes is ASCII so this does not work' write ( * , * ) ucs4_ 'ľ' , ucs4_ 'š' , ucs4_ 'č' , ucs4_ 'ť' , ucs4_ 'ž' , & ucs4_ 'ý' , ucs4_ 'á' , ucs4_ 'ß' , ucs4_ 'Ą' , ucs4_ 'Ę' , & ucs4_ '®' , ucs4_ '™' , ucs4_ '√' , ucs4_ '🙂' write ( * , * ) 'might work but not defined by the standard that I can tell' write ( ULINE , '(A)' ) A write ( * , * ) 'ULINE:' , trim ( ULINE ) write ( * , * ) 'A:' , A write ( * , * ) 'might work but not defined by the standard that I can tell' write ( ALINE , '(A)' ) A write ( * , * ) 'ALINE:' , trim ( ALINE ) write ( * , * ) 'biggest code:' write ( * , * ) 'FFFFFFFF:' , int ( z 'FFFFFFFF' , kind = int64 ) end program shouldit","tags":"","url":"sourcefile/question.f90.html"},{"title":"euro.f90 – M_time","text":"Source Code program euro use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stdin => input_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: g5 = '(*(t3,g0,t9,g0,t16,g0,t22,g0))' character ( len = 1 ) :: euro0 = '€' character ( len =* ), parameter :: euro00 = '€' character ( len = 1 , kind = ucs4 ) :: euro1 = '€' character ( len = 1 , kind = ucs4 ) :: euro2 = ucs4_ '€' character ( len = 1 , kind = ucs4 ) :: euro3 = char ( int ( z '20AC' ), kind = ucs4 ) write ( stdout , g5 ) 'OUTPUT  LEN    BYTES    KIND' open ( stdout , encoding = 'utf-8' ) write ( stdout , g5 ) euro0 , len ( euro0 ), storage_size ( euro0 ) / 8 , kind ( euro0 ) write ( stdout , g5 ) euro00 , len ( euro00 ), storage_size ( euro00 ) / 8 , kind ( euro00 ) write ( stdout , g5 ) euro1 , len ( euro1 ), storage_size ( euro1 ) / 8 , kind ( euro1 ) write ( stdout , g5 ) euro2 , len ( euro2 ), storage_size ( euro2 ) / 8 , kind ( euro2 ) write ( stdout , g5 ) euro3 , len ( euro3 ), storage_size ( euro3 ) / 8 , kind ( euro3 ) end program euro","tags":"","url":"sourcefile/euro.f90.html"},{"title":"boz.f90 – M_time","text":"Source Code program multi_line use iso_fortran_env , only : output_unit use M_utf8 , only : utf8_to_ucs4 implicit none integer , parameter :: ascii = selected_char_kind ( \"ascii\" ) integer , parameter :: ucs4 = selected_char_kind ( \"ISO_10646\" ) integer :: i , j , longest character ( len = 3 , kind = ucs4 ) :: u3 character ( len = 255 ), parameter :: upagain ( 3 ) = [ character ( len = 255 ) :: & \"七転び八起き。\" , & \"転んでもまた立ち上がる。\" , & \"くじけずに前を向いて歩いていこう。\" ] character ( len = 4 * len ( upagain ), kind = ucs4 ) :: ustr ( size ( upagain )) character ( len = :), allocatable :: aline character ( len = :, kind = ucs4 ), allocatable :: uline ! ! Romanization: !    Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! !    \"Fall seven times, stand up eight. !    Even if you fall down, you will get up again. !    Don't be discouraged, just keep walking forward.\" ! open ( output_unit , encoding = 'UTF-8' ) ! convert pseudo-utf-8 ascii to actual Fortran ucs4 unicode longest = 0 ! get longest trimmed line do i = 1 , size ( upagain ) ustr ( i ) = utf8_to_ucs4 ( upagain ( i )) longest = max ( longest , len_trim ( ustr ( i ))) write ( * , * ) 'LEN=' , len_trim ( ustr ( i )) enddo write ( output_unit , * ) 'longest=' , longest write ( output_unit , * ) write ( output_unit , * )( trim ( ustr ( i )), i = 1 , size ( ustr )) write ( output_unit , * ) write ( output_unit , '(A)' ) ( trim ( ustr ( i )), i = 1 , size ( ustr )) write ( output_unit , '(*(z8.8))' ) (( ustr ( i )( j : j ), j = 1 , len_trim ( ustr ( i ))), i = 1 , size ( ustr )) write ( output_unit , * ) aline = '& &00004E0300008EE2000030730000516B00008D770000304D0000300200008EE20000309300003067& &000030820000307E0000305F00007ACB0000306100004E0A0000304C0000308B000030020000304F& &00003058000030510000305A0000306B0000524D0000309200005411000030440000306600006B69& &000030440000306600003044000030530000304600003002' allocate ( character ( len = len ( aline ) / 8 , kind = ucs4 ) :: uline ) !   read(aline,'(z288)') uline read ( aline , '(*(z8.8))' ) ( uline ( i : i ), i = 1 , len ( uline )) write ( output_unit , * ) uline end program multi_line","tags":"","url":"sourcefile/boz.f90.html"}]}